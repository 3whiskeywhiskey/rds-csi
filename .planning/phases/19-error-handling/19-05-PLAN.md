---
phase: 19-error-handling
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/rds/commands.go
  - pkg/rds/ssh_client.go
  - pkg/driver/controller.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "RDS layer returns sentinel errors for volume not found and resource exhausted conditions"
    - "Driver layer uses errors.Is() instead of string matching for error classification"
    - "Error chains are preserved so both sentinel checks and detailed messages work"
  artifacts:
    - path: "pkg/rds/commands.go"
      provides: "Returns ErrVolumeNotFound when volume not found"
      contains: "ErrVolumeNotFound"
    - path: "pkg/rds/ssh_client.go"
      provides: "Uses ErrResourceExhausted sentinel for space errors"
      contains: "ErrResourceExhausted"
    - path: "pkg/driver/controller.go"
      provides: "Uses errors.Is() for error classification"
      contains: "errors.Is"
  key_links:
    - from: "pkg/rds/commands.go"
      to: "pkg/utils/errors.go"
      via: "import and sentinel usage"
      pattern: "utils\\.ErrVolumeNotFound"
    - from: "pkg/rds/ssh_client.go"
      to: "pkg/utils/errors.go"
      via: "sentinel wrapping in runCommandWithRetry"
      pattern: "utils\\.ErrResourceExhausted"
    - from: "pkg/driver/controller.go"
      to: "pkg/rds/commands.go"
      via: "errors.Is() check"
      pattern: "errors\\.Is.*ErrResourceExhausted"
---

<objective>
Integrate sentinel error infrastructure into RDS and driver packages

Purpose: Close gap identified in Phase 19 verification - sentinel errors defined but not integrated into driver code. String matching with error messages is fragile; sentinel errors with errors.Is() provides type-safe error classification.

Output: RDS layer returns sentinel errors, driver layer uses errors.Is() for classification
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-error-handling/19-02-SUMMARY.md
@pkg/utils/errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: RDS layer returns sentinel errors</name>
  <files>pkg/rds/commands.go, pkg/rds/ssh_client.go</files>
  <action>
Update pkg/rds/commands.go:
1. Verify import for "git.srvlab.io/whiskey/rds-csi-driver/pkg/utils" exists (it does at line 13)
2. In GetVolume() at line 174, replace:
   - BEFORE: `return nil, fmt.Errorf("volume not found: %s", slot)`
   - AFTER: `return nil, utils.WrapVolumeError(utils.ErrVolumeNotFound, slot, "")`
3. In GetVolume() at line 184, replace:
   - BEFORE: `return nil, fmt.Errorf("volume not found: %s", slot)`
   - AFTER: `return nil, utils.WrapVolumeError(utils.ErrVolumeNotFound, slot, "")`
4. In DeleteVolume() at line 114, keep the string check for now:
   - `strings.Contains(err.Error(), "not found")` is checking the error returned from GetVolume
   - Once GetVolume returns ErrVolumeNotFound, change to: `errors.Is(err, utils.ErrVolumeNotFound)`
   - Add import "errors" at top of file
5. Line 129 check for "no such item" - keep as-is (this is RouterOS CLI output, not Go error)

Update pkg/rds/ssh_client.go:
1. Add import for "git.srvlab.io/whiskey/rds-csi-driver/pkg/utils"
2. In runCommandWithRetry() at lines 228-230, wrap non-retryable errors with sentinel:
   - BEFORE (lines 227-230):
     ```go
     // Check if error is retryable
     if !isRetryableError(err) {
         klog.V(4).Infof("Non-retryable error: %v", err)
         return "", lastErr
     }
     ```
   - AFTER:
     ```go
     // Check if error is retryable
     if !isRetryableError(err) {
         klog.V(4).Infof("Non-retryable error: %v", err)
         // Wrap with sentinel if it's a known error type
         errStr := lastErr.Error()
         if containsString(errStr, "not enough space") {
             return "", fmt.Errorf("%w: %s", utils.ErrResourceExhausted, errStr)
         }
         return "", lastErr
     }
     ```

Key patterns:
- Use WrapVolumeError for volume-specific errors to include volumeID in context
- Use fmt.Errorf with %w to preserve error chain (sentinel first for errors.Is to work)
- Sentinels wrapped at RDS layer, classification via errors.Is() at driver layer
  </action>
  <verify>
grep -n "utils.ErrVolumeNotFound\|utils.ErrResourceExhausted" pkg/rds/*.go
grep -n "errors.Is" pkg/rds/commands.go
go build ./pkg/rds/...
go test ./pkg/rds/... -v -run TestGetVolume
go test ./pkg/rds/... -v -run TestSentinel
  </verify>
  <done>
RDS package returns sentinel-wrapped errors that can be checked with errors.Is()
  </done>
</task>

<task type="auto">
  <name>Task 2: Driver layer uses errors.Is() for classification</name>
  <files>pkg/driver/controller.go</files>
  <action>
Update pkg/driver/controller.go:
1. Add import for "errors" (stdlib) if not present
2. In CreateVolume() (around line 196), replace string matching:
   - Before: `if containsString(err.Error(), "not enough space")`
   - After: `if errors.Is(err, utils.ErrResourceExhausted)`
3. In ControllerExpandVolume() (around line 879), replace string matching:
   - Before: `if containsString(err.Error(), "not enough space")`
   - After: `if errors.Is(err, utils.ErrResourceExhausted)`
4. Keep the containsString function for now (may be used elsewhere), but add comment marking it for potential removal

Note: The errors.IsNotFound() calls at lines 357 and in reconciler.go are CORRECT - they check for Kubernetes API NotFound errors, not RDS volume errors. Do NOT change those.
  </action>
  <verify>
grep -n "errors.Is.*ErrResourceExhausted" pkg/driver/controller.go
go build ./pkg/driver/...
go test ./pkg/driver/... -v -run TestCreateVolume -count=1
  </verify>
  <done>
Driver uses errors.Is() for type-safe error classification instead of string matching
  </done>
</task>

<task type="auto">
  <name>Task 3: Add test for sentinel error chain preservation</name>
  <files>pkg/rds/commands_test.go</files>
  <action>
Check if commands_test.go exists and has mock infrastructure:
```bash
ls -la pkg/rds/*_test.go
grep -l "Mock\|mock\|fake" pkg/rds/*_test.go
```

If commands_test.go exists with mock support, add test:
```go
func TestGetVolumeNotFoundReturnsSentinel(t *testing.T) {
    // Create client with mock that returns empty output (simulates "not found")
    // Call GetVolume with non-existent slot
    _, err := client.GetVolume("pvc-nonexistent")

    // Verify errors.Is works
    if !errors.Is(err, utils.ErrVolumeNotFound) {
        t.Errorf("Expected ErrVolumeNotFound sentinel, got: %v", err)
    }

    // Verify error message still contains context
    if !strings.Contains(err.Error(), "pvc-nonexistent") {
        t.Errorf("Expected error to contain volume ID, got: %v", err)
    }
}
```

If mock infrastructure is missing:
1. Skip test creation for now
2. Create tech debt note in SUMMARY.md: "TODO: Add TestGetVolumeNotFoundReturnsSentinel once mock infrastructure exists"
3. Verify manually: `go test ./pkg/rds/... -v` to ensure existing tests still pass

The key verification is that errors.Is() works with the wrapped errors - this can be confirmed by:
- Code inspection: WrapVolumeError uses fmt.Errorf("%w: ...", sentinel) pattern
- Existing test coverage if available
  </action>
  <verify>
go test ./pkg/rds/... -v
go test ./pkg/... -v -run Sentinel 2>/dev/null || echo "No sentinel tests yet"
  </verify>
  <done>
Either: Tests verify sentinel errors work with errors.Is(), OR tech debt documented for future test addition
  </done>
</task>

</tasks>

<verification>
```bash
# Build passes
go build ./...

# All tests pass
make test

# Sentinel errors are used in RDS layer
grep -rn "ErrVolumeNotFound\|ErrResourceExhausted" pkg/rds/*.go | grep -v "_test.go"

# errors.Is() used in driver layer
grep -n "errors.Is" pkg/driver/controller.go

# No new string matching for error classification
grep -n "containsString.*not enough space" pkg/driver/controller.go | wc -l  # Should be 0
```
</verification>

<success_criteria>
1. RDS layer returns sentinel-wrapped errors (ErrVolumeNotFound, ErrResourceExhausted)
2. Driver layer uses errors.Is() instead of containsString() for error classification
3. Error chains preserved - both errors.Is() and detailed messages work
4. All existing tests pass (no regressions)
5. Build succeeds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-error-handling/19-05-SUMMARY.md`
</output>
