---
phase: 19-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/mount/mount.go
  - pkg/mount/health.go
  - pkg/mount/recovery.go
  - pkg/utils/validation.go
  - pkg/driver/controller.go
autonomous: true

must_haves:
  truths:
    - "All fmt.Errorf calls with errors use %w for wrapping"
    - "Non-error values formatted with %v remain unchanged"
    - "All tests continue to pass after changes"
  artifacts:
    - path: "pkg/mount/mount.go"
      provides: "Correct %v usage for pids array"
      contains: "pids"
    - path: "pkg/driver/controller.go"
      provides: "Correct %v usage for access mode"
      contains: "access mode"
  key_links:
    - from: "All error wrapping"
      to: "errors.Is/As compatibility"
      via: "%w verb preserves error chain"
      pattern: "fmt\\.Errorf.*%w"
---

<objective>
Audit and verify %v vs %w usage in fmt.Errorf calls across the codebase

Purpose: Ensure proper error chain preservation for errors.Is/As compatibility while maintaining correct formatting for non-error values

Output: Verified codebase where %v is used correctly for values and %w for error wrapping
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-error-handling/19-RESEARCH.md
@pkg/utils/errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit %v usage in fmt.Errorf calls</name>
  <files>
    pkg/mount/mount.go
    pkg/mount/procmounts.go
    pkg/mount/health.go
    pkg/mount/recovery.go
    pkg/utils/validation.go
    pkg/driver/controller.go
  </files>
  <action>
Research found only 6 instances of `fmt.Errorf.*%v` in the codebase. Audit each to determine if it's wrapping an error type (should use %w) or formatting a non-error value (correct as %v):

1. **pkg/mount/mount.go:644**: `processes: %v` - formatting `pids []int` - CORRECT (not an error)
2. **pkg/mount/procmounts.go:184**: `after %v: %w` - duration then error - CORRECT (uses both correctly)
3. **pkg/mount/health.go:53**: `after %v for device` - formatting duration - NEEDS REVIEW for error chain
4. **pkg/mount/recovery.go:117**: `processes %v` - formatting `pids []int` - CORRECT (not an error)
5. **pkg/utils/validation.go:123**: `(allowed: %v)` - formatting `AllowedBasePaths []string` - CORRECT (not an error)
6. **pkg/driver/controller.go:948**: `access mode %v` - formatting accessMode type - CORRECT (not an error)

For each file:
- Read the specific line and surrounding context
- Verify the value being formatted is NOT an error type
- Document the finding
- If the value IS an error type, convert %v to %w

Expected outcome: Most/all are correctly using %v for non-error values. Document the audit results.
  </action>
  <verify>
Run: `rg 'fmt\.Errorf.*%v' --type go` and confirm all 6 instances are correctly using %v for non-error values
Run: `make test` passes
  </verify>
  <done>
All fmt.Errorf calls audited. Non-error values use %v (correct). Any error wrapping uses %w.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify error chain preservation</name>
  <files>pkg/utils/errors_test.go</files>
  <action>
Add a test case to verify that the existing WrapError function preserves error chains for errors.Is/As:

```go
func TestWrapErrorPreservesChain(t *testing.T) {
    // Create a sentinel error
    sentinel := errors.New("sentinel error")

    // Wrap it using WrapError
    wrapped := WrapError(sentinel, "context: %s", "test")

    // Verify errors.Is still works
    if !errors.Is(wrapped, sentinel) {
        t.Errorf("WrapError broke error chain: errors.Is returned false")
    }

    // Verify errors.As still works for SanitizedError
    var se *SanitizedError
    if !errors.As(wrapped, &se) {
        t.Errorf("WrapError should return SanitizedError type")
    }
}
```

This confirms the existing error infrastructure preserves chains correctly.
  </action>
  <verify>
Run: `go test ./pkg/utils/... -run TestWrapErrorPreservesChain -v`
  </verify>
  <done>
Error chain preservation verified with explicit test case
  </done>
</task>

</tasks>

<verification>
1. `rg 'fmt\.Errorf.*%v' --type go` - all instances documented as correct
2. `rg 'fmt\.Errorf.*%w' --type go | wc -l` - confirms 147+ instances use %w
3. `make test` - all tests pass
4. New test case for error chain preservation passes
</verification>

<success_criteria>
- All 6 %v instances audited and documented
- Error chain preservation test added and passing
- No regressions in existing tests (148+ tests pass)
- ERR-01 requirement validated: codebase already 96%+ compliant with %w usage
</success_criteria>

<output>
After completion, create `.planning/phases/19-error-handling/19-01-SUMMARY.md`
</output>
