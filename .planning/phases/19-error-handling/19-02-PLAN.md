---
phase: 19-error-handling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/utils/errors.go
  - pkg/utils/errors_test.go
autonomous: true

must_haves:
  truths:
    - "Sentinel errors enable type-safe error classification"
    - "errors.Is() works reliably for volume/operation errors"
    - "ClassifyError can use sentinel errors instead of string matching"
  artifacts:
    - path: "pkg/utils/errors.go"
      provides: "Sentinel errors for common conditions"
      contains: "ErrVolume"
    - path: "pkg/utils/errors_test.go"
      provides: "Tests for sentinel error behavior"
      contains: "TestSentinelErrors"
  key_links:
    - from: "pkg/utils/errors.go"
      to: "Error classification"
      via: "errors.Is() matching"
      pattern: "errors\\.Is.*ErrVolume"
---

<objective>
Add sentinel errors for common conditions to enable type-safe error classification

Purpose: Replace fragile string matching in error classification with robust errors.Is() checks

Output: Sentinel errors defined in pkg/utils/errors.go with comprehensive tests
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-error-handling/19-RESEARCH.md
@pkg/utils/errors.go
@pkg/rds/pool.go (existing sentinel errors pattern: ErrPoolClosed, ErrPoolExhausted, ErrCircuitOpen)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define sentinel errors</name>
  <files>pkg/utils/errors.go</files>
  <action>
Add sentinel errors at the top of pkg/utils/errors.go (after imports, before ErrorType):

```go
// Sentinel errors for common conditions.
// Use errors.Is() to check for these rather than string matching.
var (
    // ErrVolumeNotFound indicates the requested volume does not exist
    ErrVolumeNotFound = errors.New("volume not found")

    // ErrVolumeExists indicates the volume already exists
    ErrVolumeExists = errors.New("volume already exists")

    // ErrNodeNotFound indicates the requested node does not exist
    ErrNodeNotFound = errors.New("node not found")

    // ErrInvalidParameter indicates an invalid parameter was provided
    ErrInvalidParameter = errors.New("invalid parameter")

    // ErrResourceExhausted indicates insufficient storage capacity
    ErrResourceExhausted = errors.New("resource exhausted")

    // ErrOperationTimeout indicates an operation timed out
    ErrOperationTimeout = errors.New("operation timeout")

    // ErrDeviceNotFound indicates NVMe device was not found
    ErrDeviceNotFound = errors.New("device not found")

    // ErrDeviceInUse indicates the device is currently in use
    ErrDeviceInUse = errors.New("device in use")

    // ErrMountFailed indicates a mount operation failed
    ErrMountFailed = errors.New("mount failed")

    // ErrUnmountFailed indicates an unmount operation failed
    ErrUnmountFailed = errors.New("unmount failed")
)
```

Add import for "errors" package at top if not already present.

These sentinel errors align with the CSI driver's domain and enable type-safe error handling in callers.
  </action>
  <verify>
Run: `go build ./pkg/utils/...` - compiles without errors
Run: `rg 'ErrVolume|ErrNode|ErrDevice|ErrMount' pkg/utils/errors.go` - shows defined sentinels
  </verify>
  <done>
Sentinel errors defined for 10 common conditions: volume, node, parameter, resource, timeout, device, mount
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sentinel error tests</name>
  <files>pkg/utils/errors_test.go</files>
  <action>
Add comprehensive tests for sentinel errors in pkg/utils/errors_test.go:

```go
func TestSentinelErrors(t *testing.T) {
    tests := []struct {
        name     string
        sentinel error
        wantMsg  string
    }{
        {"ErrVolumeNotFound", ErrVolumeNotFound, "volume not found"},
        {"ErrVolumeExists", ErrVolumeExists, "volume already exists"},
        {"ErrNodeNotFound", ErrNodeNotFound, "node not found"},
        {"ErrInvalidParameter", ErrInvalidParameter, "invalid parameter"},
        {"ErrResourceExhausted", ErrResourceExhausted, "resource exhausted"},
        {"ErrOperationTimeout", ErrOperationTimeout, "operation timeout"},
        {"ErrDeviceNotFound", ErrDeviceNotFound, "device not found"},
        {"ErrDeviceInUse", ErrDeviceInUse, "device in use"},
        {"ErrMountFailed", ErrMountFailed, "mount failed"},
        {"ErrUnmountFailed", ErrUnmountFailed, "unmount failed"},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Verify error message
            if tt.sentinel.Error() != tt.wantMsg {
                t.Errorf("got %q, want %q", tt.sentinel.Error(), tt.wantMsg)
            }
        })
    }
}

func TestSentinelErrorsWithWrapping(t *testing.T) {
    // Test that wrapped sentinel errors can be detected with errors.Is
    wrapped := fmt.Errorf("failed to create volume vol-123: %w", ErrResourceExhausted)

    if !errors.Is(wrapped, ErrResourceExhausted) {
        t.Error("errors.Is failed for wrapped ErrResourceExhausted")
    }

    // Test double wrapping
    doubleWrapped := fmt.Errorf("controller error: %w", wrapped)
    if !errors.Is(doubleWrapped, ErrResourceExhausted) {
        t.Error("errors.Is failed for double-wrapped error")
    }
}

func TestSentinelErrorsAreDistinct(t *testing.T) {
    // Ensure sentinel errors are distinct from each other
    sentinels := []error{
        ErrVolumeNotFound,
        ErrVolumeExists,
        ErrNodeNotFound,
        ErrInvalidParameter,
        ErrResourceExhausted,
        ErrOperationTimeout,
        ErrDeviceNotFound,
        ErrDeviceInUse,
        ErrMountFailed,
        ErrUnmountFailed,
    }

    for i, s1 := range sentinels {
        for j, s2 := range sentinels {
            if i != j && errors.Is(s1, s2) {
                t.Errorf("sentinel errors should be distinct: %v and %v", s1, s2)
            }
        }
    }
}
```

Add import for "errors" and "fmt" packages at top if not already present.
  </action>
  <verify>
Run: `go test ./pkg/utils/... -run TestSentinel -v`
All sentinel error tests pass
  </verify>
  <done>
Sentinel errors have comprehensive test coverage for messages, wrapping, and distinctness
  </done>
</task>

<task type="auto">
  <name>Task 3: Add helper functions for wrapping sentinel errors</name>
  <files>pkg/utils/errors.go</files>
  <action>
Add helper functions to wrap sentinel errors with context:

```go
// WrapVolumeError wraps a sentinel error with volume-specific context.
// This preserves the error chain so errors.Is() still works.
func WrapVolumeError(sentinel error, volumeID, details string) error {
    if details != "" {
        return fmt.Errorf("volume %s: %s: %w", volumeID, details, sentinel)
    }
    return fmt.Errorf("volume %s: %w", volumeID, sentinel)
}

// WrapNodeError wraps a sentinel error with node-specific context.
func WrapNodeError(sentinel error, nodeID, details string) error {
    if details != "" {
        return fmt.Errorf("node %s: %s: %w", nodeID, details, sentinel)
    }
    return fmt.Errorf("node %s: %w", nodeID, sentinel)
}

// WrapDeviceError wraps a sentinel error with device-specific context.
func WrapDeviceError(sentinel error, devicePath, details string) error {
    if details != "" {
        return fmt.Errorf("device %s: %s: %w", devicePath, details, sentinel)
    }
    return fmt.Errorf("device %s: %w", devicePath, sentinel)
}

// WrapMountError wraps a sentinel error with mount-specific context.
func WrapMountError(sentinel error, target, details string) error {
    if details != "" {
        return fmt.Errorf("mount %s: %s: %w", target, details, sentinel)
    }
    return fmt.Errorf("mount %s: %w", target, sentinel)
}
```

These helpers ensure consistent error formatting while preserving error chains.
  </action>
  <verify>
Run: `go build ./pkg/utils/...` - compiles
Run: `go test ./pkg/utils/... -v` - all tests pass
  </verify>
  <done>
Helper functions added for wrapping volume, node, device, and mount errors with context
  </done>
</task>

</tasks>

<verification>
1. `go build ./pkg/utils/...` - package compiles
2. `go test ./pkg/utils/... -v` - all tests pass including new sentinel error tests
3. `rg 'Err(Volume|Node|Device|Mount)' pkg/utils/errors.go` - sentinel errors defined
4. `make test` - no regressions in other packages
</verification>

<success_criteria>
- 10 sentinel errors defined covering common CSI driver conditions
- All sentinel errors have tests for messages, wrapping, and distinctness
- Helper functions for wrapping errors with context
- No regressions in existing tests
- ERR-02 enabled: Context can now be added systematically via helpers
</success_criteria>

<output>
After completion, create `.planning/phases/19-error-handling/19-02-SUMMARY.md`
</output>
