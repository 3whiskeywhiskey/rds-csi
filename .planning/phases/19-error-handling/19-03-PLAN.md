---
phase: 19-error-handling
plan: 03
type: execute
wave: 2
depends_on: ["19-02"]
files_modified:
  - .planning/codebase/CONVENTIONS.md
autonomous: true

must_haves:
  truths:
    - "Contributors know when to use %w vs %v"
    - "Error wrapping patterns are documented with examples"
    - "gRPC boundary conversion is clearly explained"
    - "Common mistakes are called out"
  artifacts:
    - path: ".planning/codebase/CONVENTIONS.md"
      provides: "Error handling documentation"
      contains: "Error Handling"
  key_links:
    - from: "CONVENTIONS.md"
      to: "Code reviews"
      via: "Documented standards"
      pattern: "error.*wrapping"
---

<objective>
Document error handling patterns in CONVENTIONS.md

Purpose: Enable consistent error handling by all contributors through clear documentation

Output: Updated CONVENTIONS.md with comprehensive error handling section
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-error-handling/19-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
@pkg/utils/errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand error handling section in CONVENTIONS.md</name>
  <files>.planning/codebase/CONVENTIONS.md</files>
  <action>
Replace the existing "Error Handling" section (currently ~25 lines) with a comprehensive guide (~100 lines). The new section should be placed after "Code Style" and before "Logging".

New content for Error Handling section:

```markdown
## Error Handling

### Quick Reference

- Use `%w` for wrapping errors: `fmt.Errorf("op failed: %w", err)`
- Use `%v` for formatting values: `fmt.Errorf("found %v items", count)`
- Add context at each layer: operation + volumeID/nodeID + reason
- Log errors once at boundaries, not at every layer
- Convert to gRPC status at CSI method boundaries

### Error Wrapping with %w

Go 1.13+ introduced error wrapping with `%w`. Always use `%w` when wrapping errors to preserve the error chain for `errors.Is()` and `errors.As()`:

```go
// ✓ CORRECT: Preserves error chain
if err := someOperation(); err != nil {
    return fmt.Errorf("failed to create volume %s: %w", volumeID, err)
}

// ✗ WRONG: Breaks error chain
if err := someOperation(); err != nil {
    return fmt.Errorf("failed to create volume %s: %v", volumeID, err)
}
```

**When to use %v:**
- Formatting non-error values (integers, strings, slices, structs)
- Example: `fmt.Errorf("pids in use: %v", pids)` where pids is `[]int`

### Sentinel Errors

Use sentinel errors in `pkg/utils/errors.go` for type-safe error classification:

```go
// Define in pkg/utils/errors.go
var ErrVolumeNotFound = errors.New("volume not found")

// Wrap with context
return fmt.Errorf("volume %s: %w", volumeID, ErrVolumeNotFound)

// Check with errors.Is
if errors.Is(err, utils.ErrVolumeNotFound) {
    return status.Error(codes.NotFound, "volume not found")
}
```

Available sentinel errors: `ErrVolumeNotFound`, `ErrVolumeExists`, `ErrNodeNotFound`, `ErrInvalidParameter`, `ErrResourceExhausted`, `ErrOperationTimeout`, `ErrDeviceNotFound`, `ErrDeviceInUse`, `ErrMountFailed`, `ErrUnmountFailed`

### Layered Context Pattern

Each layer adds ONE piece of context. Don't duplicate information:

```go
// Bottom layer (nvme package): Device-specific context
if err := connectDevice(nqn); err != nil {
    return fmt.Errorf("nvme connect failed for NQN %s: %w", nqn, err)
}

// Middle layer (node service): Volume context
if err := stageVolume(volumeID, nqn); err != nil {
    return fmt.Errorf("stage volume %s: %w", volumeID, err)
}

// Top layer (CSI gRPC): Convert to gRPC status
if err := nodeStage(req); err != nil {
    // Don't wrap - convert to gRPC
    return nil, status.Errorf(codes.Internal, "failed: %v", err)
}
```

### gRPC Boundary Conversion

CSI methods (ControllerServer, NodeServer) return gRPC status errors:

**CSI Service Layer (pkg/driver/controller.go, pkg/driver/node.go):**
```go
// Parameter validation - use status.Error directly
if req.GetName() == "" {
    return nil, status.Error(codes.InvalidArgument, "volume name is required")
}

// Internal operation errors - wrap message, not the error
if err := someOperation(); err != nil {
    klog.Errorf("operation failed: %v", err)  // Log full error
    return nil, status.Errorf(codes.Internal, "operation failed: %v", err)
}
```

**Internal Packages (pkg/rds, pkg/nvme, pkg/mount):**
```go
// Always use fmt.Errorf with %w
if err := sshCommand(); err != nil {
    return fmt.Errorf("ssh command failed: %w", err)
}
```

### Error Context Requirements (ERR-02)

Every error should include:
1. **Operation** - what was being attempted
2. **Resource ID** - volumeID, nodeID, or devicePath (if applicable)
3. **Reason** - underlying cause (from wrapped error)

Use helper functions for consistent formatting:
```go
// pkg/utils/errors.go helpers
utils.WrapVolumeError(err, volumeID, "failed to create")
utils.WrapNodeError(err, nodeID, "failed to stage")
utils.WrapDeviceError(err, devicePath, "not found")
utils.WrapMountError(err, target, "already mounted")
```

### Common Mistakes

1. **Using %v for errors:**
   ```go
   // ✗ WRONG
   return fmt.Errorf("failed: %v", err)
   // ✓ CORRECT
   return fmt.Errorf("failed: %w", err)
   ```

2. **Double-wrapping at every layer:**
   ```go
   // ✗ WRONG - duplicates "failed to create volume"
   // rds/client.go
   return fmt.Errorf("failed to create volume: %w", err)
   // driver/controller.go
   if err := rds.CreateVolume(...); err != nil {
       return fmt.Errorf("failed to create volume: %w", err)
   }

   // ✓ CORRECT - each layer adds NEW information
   // rds/client.go
   return fmt.Errorf("ssh command failed: %w", err)
   // driver/controller.go
   return fmt.Errorf("create volume %s: %w", volumeID, err)
   ```

3. **Wrapping gRPC status errors:**
   ```go
   // ✗ WRONG
   return fmt.Errorf("failed: %w", status.Error(codes.NotFound, "not found"))

   // ✓ CORRECT
   return status.Error(codes.NotFound, "volume not found")
   ```

4. **Silent error handling:**
   ```go
   // ✗ WRONG - error silently ignored
   _ = cleanupResource()

   // ✓ CORRECT - log if ignoring
   if err := cleanupResource(); err != nil {
       klog.V(4).Infof("cleanup failed (non-critical): %v", err)
   }
   ```

### Error Inspection

Use `errors.Is()` and `errors.As()` for type-safe error checking:

```go
// Check for sentinel error
if errors.Is(err, utils.ErrVolumeNotFound) {
    // Handle not found case
}

// Extract typed error
var sanitized *utils.SanitizedError
if errors.As(err, &sanitized) {
    // Access sanitized.GetOriginal() for logging
}

// Check for context timeout
if errors.Is(err, context.DeadlineExceeded) {
    // Handle timeout
}
```
```

Place this section after "Code Style" and before "Logging" in CONVENTIONS.md.
  </action>
  <verify>
Run: `cat .planning/codebase/CONVENTIONS.md | grep -A5 "Error Handling"` - shows new section
Verify section includes: %w vs %v, sentinel errors, layered context, gRPC conversion, common mistakes
  </verify>
  <done>
CONVENTIONS.md updated with comprehensive error handling documentation covering wrapping, sentinels, context, gRPC boundaries, and common mistakes
  </done>
</task>

</tasks>

<verification>
1. CONVENTIONS.md contains expanded Error Handling section
2. Section covers all key topics: %w/%v, sentinels, context, gRPC, mistakes
3. Examples are correct and follow Go best practices
4. Addresses ERR-03 requirement: patterns documented
</verification>

<success_criteria>
- Error Handling section expanded from ~25 lines to ~100 lines
- Clear guidance on %w vs %v usage with examples
- Sentinel errors documented with usage patterns
- Layered context pattern explained
- gRPC boundary conversion documented
- Common mistakes called out with corrections
- ERR-03 complete: Error handling patterns documented in CONVENTIONS.md
</success_criteria>

<output>
After completion, create `.planning/phases/19-error-handling/19-03-SUMMARY.md`
</output>
