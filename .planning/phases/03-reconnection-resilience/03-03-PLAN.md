---
phase: 03-reconnection-resilience
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - pkg/driver/node.go
  - pkg/nvme/resolver.go
  - pkg/nvme/orphan.go
  - cmd/rds-csi-plugin/main.go
autonomous: true

must_haves:
  truths:
    - "NodeStageVolume extracts connection parameters from VolumeContext"
    - "NodeStageVolume uses ConnectWithRetry for exponential backoff on connection"
    - "ListConnectedSubsystems scans sysfs to enumerate all connected NQNs"
    - "Node plugin cleans up orphaned NVMe connections on startup"
  artifacts:
    - path: "pkg/driver/node.go"
      provides: "NodeStageVolume with connection parameter extraction and retry"
      contains: "ConnectWithRetry"
    - path: "pkg/nvme/resolver.go"
      provides: "ListConnectedSubsystems method for enumerating connected NQNs"
      exports: ["DeviceResolver.ListConnectedSubsystems"]
    - path: "pkg/nvme/orphan.go"
      provides: "OrphanCleaner for startup cleanup"
      exports: ["OrphanCleaner", "NewOrphanCleaner", "CleanupOrphanedConnections"]
    - path: "cmd/rds-csi-plugin/main.go"
      provides: "Orphan cleanup integration at startup"
      contains: "CleanupOrphanedConnections"
  key_links:
    - from: "pkg/driver/node.go"
      to: "pkg/nvme/nvme.go"
      via: "ConnectWithRetry with extracted params"
      pattern: "ConnectWithRetry.*ConnectionConfig"
    - from: "pkg/nvme/orphan.go"
      to: "pkg/nvme/resolver.go"
      via: "ListConnectedSubsystems and IsOrphanedSubsystem for detection"
      pattern: "ListConnectedSubsystems|IsOrphanedSubsystem"
    - from: "cmd/rds-csi-plugin/main.go"
      to: "pkg/nvme/orphan.go"
      via: "NewOrphanCleaner with connector from nvme.NewConnector"
      pattern: "NewOrphanCleaner"
---

<objective>
Complete the connection resilience integration: extract parameters in NodeStageVolume with retry support, add subsystem enumeration to resolver, and implement orphaned connection cleanup on node startup.

Purpose: Enable end-to-end flow of connection parameters with retry and prevent orphaned NVMe connections from accumulating.
Output: Updated node.go, updated resolver.go with ListConnectedSubsystems, new orphan.go, updated main.go with startup cleanup.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-reconnection-resilience/03-RESEARCH.md

# Prior plan artifacts
@pkg/nvme/config.go
@pkg/driver/params.go
@pkg/nvme/nvme.go
@pkg/utils/retry.go

# Files to modify
@pkg/driver/node.go
@pkg/nvme/resolver.go
@cmd/rds-csi-plugin/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract connection parameters in NodeStageVolume and use ConnectWithRetry</name>
  <files>pkg/driver/node.go</files>
  <action>
Modify pkg/driver/node.go NodeStageVolume:

1. After volumeContext extraction (around line 105), add parameter parsing:
   ```go
   // Extract connection parameters from VolumeContext
   connConfig := nvme.DefaultConnectionConfig()

   if val, ok := volumeContext["ctrlLossTmo"]; ok {
       if parsed, err := strconv.Atoi(val); err == nil {
           connConfig.CtrlLossTmo = parsed
       }
   }

   if val, ok := volumeContext["reconnectDelay"]; ok {
       if parsed, err := strconv.Atoi(val); err == nil {
           connConfig.ReconnectDelay = parsed
       }
   }

   if val, ok := volumeContext["keepAliveTmo"]; ok {
       if parsed, err := strconv.Atoi(val); err == nil {
           connConfig.KeepAliveTmo = parsed
       }
   }
   ```

2. Add import for "strconv" if not present

3. Find where ns.nvmeConn.Connect is called (line 162) and change to use ConnectWithRetry:
   ```go
   devicePath, err := ns.nvmeConn.ConnectWithRetry(ctx, target, connConfig)
   ```

4. Log the connection config at V(2) level before connecting:
   ```go
   klog.V(2).Infof("Connecting with config: ctrl_loss_tmo=%d, reconnect_delay=%d (with retry)",
       connConfig.CtrlLossTmo, connConfig.ReconnectDelay)
   ```

This uses ConnectWithRetry (added in Plan 03-02 Task 3) which wraps ConnectWithConfig with exponential backoff from utils.RetryWithBackoff.
  </action>
  <verify>go build ./pkg/driver/... compiles; go test ./pkg/driver/... passes</verify>
  <done>NodeStageVolume extracts ctrlLossTmo, reconnectDelay, keepAliveTmo from VolumeContext and calls ConnectWithRetry for resilient connection</done>
</task>

<task type="auto">
  <name>Task 2: Add ListConnectedSubsystems method to DeviceResolver</name>
  <files>pkg/nvme/resolver.go</files>
  <action>
Add ListConnectedSubsystems method to pkg/nvme/resolver.go to enumerate all connected NQNs via sysfs:

1. Add method to DeviceResolver struct:
   ```go
   // ListConnectedSubsystems returns all NQNs that have subsystem entries in sysfs.
   // This scans /sys/class/nvme-subsystem/*/subsysnqn for connected subsystems.
   func (r *DeviceResolver) ListConnectedSubsystems() ([]string, error) {
       return r.scanner.ListSubsystemNQNs()
   }
   ```

2. Add ListSubsystemNQNs method to SysfsScanner (in pkg/nvme/sysfs.go or inline):
   ```go
   // ListSubsystemNQNs returns all NQNs from /sys/class/nvme-subsystem/*/subsysnqn
   func (s *SysfsScanner) ListSubsystemNQNs() ([]string, error) {
       subsysDir := filepath.Join(s.sysfsRoot, "class", "nvme-subsystem")

       entries, err := os.ReadDir(subsysDir)
       if err != nil {
           if os.IsNotExist(err) {
               return nil, nil // No subsystems connected
           }
           return nil, fmt.Errorf("failed to read nvme-subsystem directory: %w", err)
       }

       var nqns []string
       for _, entry := range entries {
           if !entry.IsDir() {
               continue
           }
           nqnPath := filepath.Join(subsysDir, entry.Name(), "subsysnqn")
           data, err := os.ReadFile(nqnPath)
           if err != nil {
               klog.V(4).Infof("Could not read NQN from %s: %v", nqnPath, err)
               continue
           }
           nqn := strings.TrimSpace(string(data))
           if nqn != "" {
               nqns = append(nqns, nqn)
           }
       }

       return nqns, nil
   }
   ```

3. Add imports for "path/filepath", "os", "strings" if not present

This provides the enumeration capability needed by OrphanCleaner in Task 3.
  </action>
  <verify>go build ./pkg/nvme/... compiles; go vet ./pkg/nvme/... passes</verify>
  <done>DeviceResolver.ListConnectedSubsystems returns all NQNs from sysfs /sys/class/nvme-subsystem/*/subsysnqn</done>
</task>

<task type="auto">
  <name>Task 3: Create OrphanCleaner for startup cleanup</name>
  <files>pkg/nvme/orphan.go</files>
  <action>
Create pkg/nvme/orphan.go:

1. OrphanCleaner struct:
   ```go
   // OrphanCleaner detects and removes orphaned NVMe subsystem connections
   type OrphanCleaner struct {
       connector Connector
       resolver  *DeviceResolver
   }
   ```

2. NewOrphanCleaner constructor:
   ```go
   // NewOrphanCleaner creates an OrphanCleaner using the connector's resolver
   func NewOrphanCleaner(connector Connector) *OrphanCleaner {
       return &OrphanCleaner{
           connector: connector,
           resolver:  connector.GetResolver(),
       }
   }
   ```

3. CleanupOrphanedConnections method:
   ```go
   // CleanupOrphanedConnections scans for and disconnects orphaned NVMe subsystems.
   // An orphaned subsystem appears connected but has no working block device.
   // This is best-effort: individual disconnect failures are logged but don't stop cleanup.
   func (oc *OrphanCleaner) CleanupOrphanedConnections(ctx context.Context) error {
       klog.V(2).Info("Scanning for orphaned NVMe connections")

       // Get all connected NQNs using ListConnectedSubsystems (Task 2)
       nqns, err := oc.resolver.ListConnectedSubsystems()
       if err != nil {
           return fmt.Errorf("failed to list connected subsystems: %w", err)
       }

       klog.V(3).Infof("Found %d connected NVMe subsystems", len(nqns))

       orphanCount := 0
       for _, nqn := range nqns {
           // Check context cancellation
           select {
           case <-ctx.Done():
               klog.Warning("Orphan cleanup interrupted by context cancellation")
               return ctx.Err()
           default:
           }

           // Check if this subsystem is orphaned
           orphaned, err := oc.resolver.IsOrphanedSubsystem(nqn)
           if err != nil {
               klog.Warningf("Error checking if subsystem %s is orphaned: %v", nqn, err)
               continue
           }

           if !orphaned {
               continue
           }

           klog.Warningf("Found orphaned subsystem: %s", nqn)
           orphanCount++

           // Attempt to disconnect
           if err := oc.connector.DisconnectWithContext(ctx, nqn); err != nil {
               klog.Warningf("Failed to disconnect orphaned subsystem %s: %v", nqn, err)
               // Continue to next orphan - best effort cleanup
           } else {
               klog.V(2).Infof("Successfully disconnected orphaned subsystem: %s", nqn)
           }
       }

       if orphanCount > 0 {
           klog.Infof("Orphan cleanup complete: found %d orphaned subsystems", orphanCount)
       } else {
           klog.V(2).Info("Orphan cleanup complete: no orphaned subsystems found")
       }

       return nil
   }
   ```

4. Add imports: "context", "fmt", "k8s.io/klog/v2"

The connector is obtained from the caller (main.go). NewOrphanCleaner takes the Connector interface and uses connector.GetResolver() to get the resolver (GetResolver is already on the Connector interface from Phase 1).
  </action>
  <verify>go build ./pkg/nvme/... compiles</verify>
  <done>OrphanCleaner can scan and disconnect orphaned NVMe subsystems using resolver.ListConnectedSubsystems and IsOrphanedSubsystem</done>
</task>

<task type="auto">
  <name>Task 4: Integrate orphan cleanup into node plugin startup</name>
  <files>cmd/rds-csi-plugin/main.go</files>
  <action>
Modify cmd/rds-csi-plugin/main.go to run orphan cleanup on node startup:

1. Add import for "git.srvlab.io/whiskey/rds-csi-driver/pkg/nvme" if not present

2. After the driver is created (around line 138) but before signal handling, add orphan cleanup for node mode:
   ```go
   // Cleanup orphaned NVMe connections on node startup
   // This prevents accumulation of orphaned connections after node restarts
   if *nodeMode {
       klog.Info("Running orphan NVMe connection cleanup on startup")

       // Create a connector for cleanup (same as node server uses internally)
       cleanupConnector := nvme.NewConnector()
       cleaner := nvme.NewOrphanCleaner(cleanupConnector)

       ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
       if err := cleaner.CleanupOrphanedConnections(ctx); err != nil {
           // Log warning but don't fail startup - cleanup is best effort
           klog.Warningf("Orphan NVMe cleanup failed (non-fatal): %v", err)
       }
       cancel()
   }
   ```

3. Add import for "context" if not present (should already be there via other imports)

Note: This creates a separate connector instance for cleanup. This is intentional because:
- The driver creates the node server internally via driver.NewDriver()
- We want cleanup to run before the gRPC server starts accepting requests
- A fresh connector instance works fine for cleanup operations

The cleanup runs with a 2-minute timeout and logs warnings on failure without blocking startup.
  </action>
  <verify>go build ./cmd/rds-csi-plugin/... compiles</verify>
  <done>Node plugin runs orphan cleanup on startup before serving requests</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` compiles entire project
2. `go test ./...` passes
3. NodeStageVolume extracts connection parameters and calls ConnectWithRetry
4. DeviceResolver.ListConnectedSubsystems exists and scans sysfs
5. OrphanCleaner exists and can detect/cleanup orphans
6. main.go calls CleanupOrphanedConnections on node startup
</verification>

<success_criteria>
- NodeStageVolume passes user-configured connection parameters to ConnectWithRetry
- ListConnectedSubsystems enumerates all NQNs from /sys/class/nvme-subsystem
- OrphanCleaner uses ListConnectedSubsystems + IsOrphanedSubsystem for detection
- Orphan cleanup runs at node startup before serving CSI requests
- Cleanup failures are logged as warnings, not fatal errors
- All components integrate without breaking existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/03-reconnection-resilience/03-03-SUMMARY.md`
</output>
