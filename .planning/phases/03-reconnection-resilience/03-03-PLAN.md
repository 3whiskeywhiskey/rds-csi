---
phase: 03-reconnection-resilience
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - pkg/driver/node.go
  - pkg/nvme/orphan.go
  - cmd/rds-csi-plugin/main.go
autonomous: true

must_haves:
  truths:
    - "NodeStageVolume extracts connection parameters from VolumeContext"
    - "NodeStageVolume passes ConnectionConfig to connector"
    - "Node plugin cleans up orphaned NVMe connections on startup"
  artifacts:
    - path: "pkg/driver/node.go"
      provides: "NodeStageVolume with connection parameter extraction"
      contains: "ConnectWithConfig"
    - path: "pkg/nvme/orphan.go"
      provides: "OrphanCleaner for startup cleanup"
      exports: ["OrphanCleaner", "NewOrphanCleaner", "CleanupOrphanedConnections"]
    - path: "cmd/rds-csi-plugin/main.go"
      provides: "Orphan cleanup integration at startup"
      contains: "CleanupOrphanedConnections"
  key_links:
    - from: "pkg/driver/node.go"
      to: "pkg/nvme/nvme.go"
      via: "ConnectWithConfig with extracted params"
      pattern: "ConnectWithConfig.*ConnectionConfig"
    - from: "pkg/nvme/orphan.go"
      to: "pkg/nvme/resolver.go"
      via: "IsOrphanedSubsystem for detection"
      pattern: "IsOrphanedSubsystem"
    - from: "cmd/rds-csi-plugin/main.go"
      to: "pkg/nvme/orphan.go"
      via: "NewOrphanCleaner and cleanup call"
      pattern: "NewOrphanCleaner"
---

<objective>
Complete the connection resilience integration: extract parameters in NodeStageVolume and implement orphaned connection cleanup on node startup.

Purpose: Enable end-to-end flow of connection parameters and prevent orphaned NVMe connections from accumulating.
Output: Updated node.go, new orphan.go, updated main.go with startup cleanup.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-reconnection-resilience/03-RESEARCH.md

# Prior plan artifacts
@pkg/nvme/config.go
@pkg/driver/params.go
@pkg/nvme/nvme.go

# Files to modify
@pkg/driver/node.go
@cmd/rds-csi-plugin/main.go

# Existing patterns for orphan detection
@pkg/nvme/resolver.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract connection parameters in NodeStageVolume</name>
  <files>pkg/driver/node.go</files>
  <action>
Modify pkg/driver/node.go NodeStageVolume:

1. After volumeContext extraction (around line 105), add parameter parsing:
   ```go
   // Extract connection parameters from VolumeContext
   connConfig := nvme.DefaultConnectionConfig()

   if val, ok := volumeContext["ctrlLossTmo"]; ok {
       if parsed, err := strconv.Atoi(val); err == nil {
           connConfig.CtrlLossTmo = parsed
       }
   }

   if val, ok := volumeContext["reconnectDelay"]; ok {
       if parsed, err := strconv.Atoi(val); err == nil {
           connConfig.ReconnectDelay = parsed
       }
   }

   if val, ok := volumeContext["keepAliveTmo"]; ok {
       if parsed, err := strconv.Atoi(val); err == nil {
           connConfig.KeepAliveTmo = parsed
       }
   }
   ```

2. Add import for "strconv" if not present

3. Find where ns.nvmeConn.Connect or ns.nvmeConn.ConnectWithContext is called and change to:
   ```go
   devicePath, err := ns.nvmeConn.ConnectWithConfig(ctx, target, connConfig)
   ```

4. Build target as before (it's already built in existing code)

5. Log the connection config at V(2) level:
   ```go
   klog.V(2).Infof("Connecting with config: ctrl_loss_tmo=%d, reconnect_delay=%d",
       connConfig.CtrlLossTmo, connConfig.ReconnectDelay)
   ```
  </action>
  <verify>go build ./pkg/driver/... compiles; go test ./pkg/driver/... passes</verify>
  <done>NodeStageVolume extracts ctrlLossTmo, reconnectDelay, keepAliveTmo from VolumeContext and calls ConnectWithConfig</done>
</task>

<task type="auto">
  <name>Task 2: Create OrphanCleaner for startup cleanup</name>
  <files>pkg/nvme/orphan.go</files>
  <action>
Create pkg/nvme/orphan.go:

1. OrphanCleaner struct:
   ```go
   type OrphanCleaner struct {
       connector Connector
       resolver  *DeviceResolver
   }
   ```

2. NewOrphanCleaner(connector Connector) *OrphanCleaner:
   - Uses connector.GetResolver() to get resolver
   - Returns configured cleaner

3. CleanupOrphanedConnections(ctx context.Context) error:
   - Log "Scanning for orphaned NVMe connections" at V(2)
   - Get all connected NQNs using resolver.ListConnectedSubsystems()
     (Note: may need to add this method if it doesn't exist - check resolver.go)
   - Alternative: Use nvme list-subsys output parsing if method doesn't exist
   - For each NQN:
     - Call resolver.IsOrphanedSubsystem(nqn)
     - If orphaned:
       - Log warning: "Found orphaned subsystem: %s"
       - Call connector.DisconnectWithContext(ctx, nqn)
       - Log result (success or error)
   - Count and log total orphans cleaned
   - Return nil (cleanup is best-effort, don't fail on individual errors)

4. Add helper if needed to list subsystems:
   - May need to add ListConnectedSubsystems() to resolver
   - Or use the existing IsOrphanedSubsystem with known NQNs from sysfs scan

Use klog for logging. Context should have reasonable timeout (2 min set by caller).
  </action>
  <verify>go build ./pkg/nvme/... compiles</verify>
  <done>OrphanCleaner can scan and disconnect orphaned NVMe subsystems</done>
</task>

<task type="auto">
  <name>Task 3: Integrate orphan cleanup into node plugin startup</name>
  <files>cmd/rds-csi-plugin/main.go</files>
  <action>
Modify cmd/rds-csi-plugin/main.go:

1. Find where node service/driver is initialized (look for NewNodeServer or similar)

2. After node service creation but before starting gRPC server, add:
   ```go
   // Cleanup orphaned NVMe connections on startup
   // This prevents accumulation of orphaned connections after node restarts
   if runNode { // or whatever flag indicates node mode
       cleaner := nvme.NewOrphanCleaner(/* connector from node server */)
       ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
       if err := cleaner.CleanupOrphanedConnections(ctx); err != nil {
           klog.Warningf("Orphan cleanup failed (non-fatal): %v", err)
       }
       cancel()
   }
   ```

3. Add import for "git.srvlab.io/whiskey/rds-csi-driver/pkg/nvme" if not present

4. The connector should be accessible from the node server or driver struct
   - May need to expose it via a getter if not accessible
   - Or create a new connector instance for cleanup only

Note: This is a best-effort cleanup. Don't fail startup if cleanup fails.
Log at Warning level for failures, V(2) for success.
  </action>
  <verify>go build ./cmd/rds-csi-plugin/... compiles</verify>
  <done>Node plugin runs orphan cleanup on startup before serving requests</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` compiles entire project
2. `go test ./...` passes
3. NodeStageVolume extracts connection parameters from VolumeContext
4. OrphanCleaner exists and can detect/cleanup orphans
5. main.go calls CleanupOrphanedConnections on node startup
</verification>

<success_criteria>
- NodeStageVolume passes user-configured connection parameters to nvme connect
- OrphanCleaner uses DeviceResolver.IsOrphanedSubsystem for detection
- Orphan cleanup runs at node startup before serving CSI requests
- Cleanup failures are logged as warnings, not fatal errors
- All components integrate without breaking existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/03-reconnection-resilience/03-03-SUMMARY.md`
</output>
