---
phase: 03-reconnection-resilience
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - pkg/nvme/nvme.go
  - pkg/driver/controller.go
autonomous: true

must_haves:
  truths:
    - "ConnectWithConfig accepts ConnectionConfig and passes parameters to nvme connect"
    - "CreateVolume includes connection parameters in VolumeContext"
    - "nvme connect command includes -l and -c flags when config values are set"
    - "Connection attempts use exponential backoff with jitter"
  artifacts:
    - path: "pkg/nvme/nvme.go"
      provides: "ConnectWithConfig and ConnectWithRetry methods using ConnectionConfig"
      exports: ["Connector.ConnectWithConfig", "Connector.ConnectWithRetry"]
    - path: "pkg/driver/controller.go"
      provides: "VolumeContext with connection parameters"
      contains: "ctrlLossTmo"
  key_links:
    - from: "pkg/nvme/nvme.go"
      to: "pkg/nvme/config.go"
      via: "ConnectWithConfig uses BuildConnectArgs"
      pattern: "BuildConnectArgs"
    - from: "pkg/nvme/nvme.go"
      to: "pkg/utils/retry.go"
      via: "ConnectWithRetry wraps ConnectWithConfig with RetryWithBackoff"
      pattern: "RetryWithBackoff"
    - from: "pkg/driver/controller.go"
      to: "pkg/driver/params.go"
      via: "CreateVolume calls ParseNVMEConnectionParams"
      pattern: "ParseNVMEConnectionParams"
---

<objective>
Integrate connection parameters into NVMe connector and controller, enabling kernel parameters to flow from StorageClass through VolumeContext, and add retry wrapper for connection resilience.

Purpose: Pass user-configured resilience parameters through the CSI flow to the nvme connect command, with exponential backoff retry on transient failures.
Output: Modified nvme.go with ConnectWithConfig and ConnectWithRetry, modified controller.go including params in VolumeContext.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-reconnection-resilience/03-RESEARCH.md

# Files from Plan 01 (will exist when this runs)
@pkg/nvme/config.go
@pkg/driver/params.go
@pkg/utils/retry.go

# Files to modify
@pkg/nvme/nvme.go
@pkg/driver/controller.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ConnectWithConfig to NVMe connector</name>
  <files>pkg/nvme/nvme.go</files>
  <action>
Modify pkg/nvme/nvme.go:

1. Add to Connector interface:
   ```go
   // ConnectWithConfig establishes connection with custom connection config
   ConnectWithConfig(ctx context.Context, target Target, config ConnectionConfig) (string, error)
   ```

2. Add method to connector struct:
   ```go
   func (c *connector) ConnectWithConfig(ctx context.Context, target Target, config ConnectionConfig) (string, error)
   ```

3. Implementation:
   - Copy logic from ConnectWithContext (validation, tracking, metrics, timeout)
   - Replace args building with: args := BuildConnectArgs(target, config)
   - Rest of logic remains same (execute command, wait for device, etc.)

4. Update existing ConnectWithContext to call ConnectWithConfig with DefaultConnectionConfig():
   ```go
   func (c *connector) ConnectWithContext(ctx context.Context, target Target) (string, error) {
       return c.ConnectWithConfig(ctx, target, DefaultConnectionConfig())
   }
   ```

This maintains backward compatibility while adding config support.

Important: The BuildConnectArgs function from config.go handles building the args array with the -l, -c, -k flags.
  </action>
  <verify>go build ./pkg/nvme/... compiles; existing nvme tests pass with `go test ./pkg/nvme/...`</verify>
  <done>Connector interface has ConnectWithConfig, implementation uses BuildConnectArgs, ConnectWithContext delegates to ConnectWithConfig with defaults</done>
</task>

<task type="auto">
  <name>Task 2: Include connection parameters in VolumeContext from controller</name>
  <files>pkg/driver/controller.go</files>
  <action>
Modify pkg/driver/controller.go CreateVolume:

1. After parameter extraction (around line 124), add:
   ```go
   // Parse NVMe connection parameters from StorageClass
   nvmeParams, err := ParseNVMEConnectionParams(params)
   if err != nil {
       return nil, status.Errorf(codes.InvalidArgument, "invalid NVMe connection parameters: %v", err)
   }
   ```

2. Update VolumeContext in both CreateVolumeResponse locations (existing volume and new volume):
   Add to the map:
   ```go
   "ctrlLossTmo":    fmt.Sprintf("%d", nvmeParams.CtrlLossTmo),
   "reconnectDelay": fmt.Sprintf("%d", nvmeParams.ReconnectDelay),
   "keepAliveTmo":   fmt.Sprintf("%d", nvmeParams.KeepAliveTmo),
   ```

3. For the existing volume case (around line 111), also add the same parameters:
   - Default values should be used since we can't get the original StorageClass params
   - Or: parse params map (which is available) to get the values

Note: Both the "volume exists" path and "create new volume" path need VolumeContext updated to include connection parameters.
  </action>
  <verify>go build ./pkg/driver/... compiles; existing controller tests pass</verify>
  <done>CreateVolume includes ctrlLossTmo, reconnectDelay, keepAliveTmo in VolumeContext for both new and existing volumes</done>
</task>

<task type="auto">
  <name>Task 3: Add ConnectWithRetry wrapper method</name>
  <files>pkg/nvme/nvme.go</files>
  <action>
Add ConnectWithRetry method to pkg/nvme/nvme.go that wraps ConnectWithConfig with RetryWithBackoff:

1. Add to Connector interface:
   ```go
   // ConnectWithRetry connects with exponential backoff retry on transient failures
   ConnectWithRetry(ctx context.Context, target Target, config ConnectionConfig) (string, error)
   ```

2. Add method implementation to connector struct:
   ```go
   func (c *connector) ConnectWithRetry(ctx context.Context, target Target, config ConnectionConfig) (string, error) {
       var devicePath string
       var lastErr error

       backoff := utils.DefaultBackoffConfig()

       err := utils.RetryWithBackoff(ctx, backoff, func() error {
           path, connectErr := c.ConnectWithConfig(ctx, target, config)
           if connectErr != nil {
               lastErr = connectErr
               klog.V(2).Infof("Connection attempt failed for NQN %s: %v (will retry if transient)", target.NQN, connectErr)
               return connectErr
           }
           devicePath = path
           return nil
       })

       if err != nil {
           if lastErr != nil {
               return "", fmt.Errorf("connection failed after retries: %w", lastErr)
           }
           return "", err
       }

       return devicePath, nil
   }
   ```

3. Add import for "git.srvlab.io/whiskey/rds-csi-driver/pkg/utils" if not present

This provides the exponential backoff with jitter (from RetryWithBackoff) that CONN-02 requires.
The IsRetryableError function from pkg/utils/retry.go determines which errors trigger retry.
  </action>
  <verify>go build ./pkg/nvme/... compiles; go vet ./pkg/nvme/... passes</verify>
  <done>ConnectWithRetry wraps ConnectWithConfig with exponential backoff using utils.RetryWithBackoff</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` compiles entire project
2. `go test ./pkg/nvme/... ./pkg/driver/...` passes
3. Connector interface includes ConnectWithConfig and ConnectWithRetry
4. CreateVolume VolumeContext includes connection parameter keys
5. ConnectWithRetry uses RetryWithBackoff with DefaultBackoffConfig
</verification>

<success_criteria>
- ConnectWithConfig accepts ConnectionConfig and builds nvme connect command with -l, -c flags
- ConnectWithRetry wraps ConnectWithConfig with exponential backoff and jitter
- ConnectWithContext maintains backward compatibility using default config
- CreateVolume parses StorageClass for connection params and includes in VolumeContext
- Invalid StorageClass parameters return InvalidArgument error
</success_criteria>

<output>
After completion, create `.planning/phases/03-reconnection-resilience/03-02-SUMMARY.md`
</output>
