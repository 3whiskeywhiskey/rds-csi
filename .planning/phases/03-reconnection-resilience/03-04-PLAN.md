---
phase: 03-reconnection-resilience
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - pkg/nvme/config_test.go
  - pkg/driver/params_test.go
  - pkg/utils/retry_test.go
  - pkg/nvme/orphan_test.go
autonomous: true

must_haves:
  truths:
    - "ConnectionConfig tests verify default values and BuildConnectArgs output"
    - "ParseNVMEConnectionParams tests cover defaults, valid inputs, and validation errors"
    - "RetryWithBackoff tests verify exponential backoff and retryable error detection"
    - "OrphanCleaner tests verify orphan detection and cleanup behavior"
  artifacts:
    - path: "pkg/nvme/config_test.go"
      provides: "Tests for ConnectionConfig and BuildConnectArgs"
      contains: "TestBuildConnectArgs"
    - path: "pkg/driver/params_test.go"
      provides: "Tests for StorageClass parameter parsing"
      contains: "TestParseNVMEConnectionParams"
    - path: "pkg/utils/retry_test.go"
      provides: "Tests for retry utilities"
      contains: "TestIsRetryableError"
    - path: "pkg/nvme/orphan_test.go"
      provides: "Tests for OrphanCleaner"
      contains: "TestCleanupOrphanedConnections"
  key_links:
    - from: "pkg/nvme/config_test.go"
      to: "pkg/nvme/config.go"
      via: "table-driven tests"
      pattern: "DefaultConnectionConfig|BuildConnectArgs"
    - from: "pkg/utils/retry_test.go"
      to: "pkg/utils/retry.go"
      via: "error pattern testing"
      pattern: "IsRetryableError"
---

<objective>
Add comprehensive unit tests for all Phase 3 components: connection config, parameter parsing, retry utilities, and orphan cleanup.

Purpose: Verify correctness and document expected behavior through tests.
Output: Four new test files covering all Phase 3 functionality.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Source files to test
@pkg/nvme/config.go
@pkg/driver/params.go
@pkg/utils/retry.go
@pkg/nvme/orphan.go

# Existing test patterns
@pkg/nvme/nvme_test.go
@pkg/driver/controller_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test ConnectionConfig and BuildConnectArgs</name>
  <files>pkg/nvme/config_test.go</files>
  <action>
Create pkg/nvme/config_test.go with:

1. TestDefaultConnectionConfig:
   - Verify CtrlLossTmo == -1
   - Verify ReconnectDelay == 5
   - Verify KeepAliveTmo == 0

2. TestBuildConnectArgs - table-driven tests:
   Case: minimal target, default config
   - Expect: connect, -t, tcp, -a, address, -s, port, -n, nqn, -l, -1, -c, 5

   Case: with host NQN
   - Expect: includes -q, hostNQN

   Case: CtrlLossTmo=0 (should NOT add -l flag since 0 means "don't set")
   - Expect: no -l flag

   Case: CtrlLossTmo=600 (kernel default)
   - Expect: -l, 600

   Case: custom ReconnectDelay=10
   - Expect: -c, 10

   Case: KeepAliveTmo=30
   - Expect: -k, 30

3. Use require or testify for assertions (match existing test patterns)

Follow table-driven test patterns from existing tests.
  </action>
  <verify>go test ./pkg/nvme/... -v -run TestDefault\|TestBuild</verify>
  <done>Tests verify DefaultConnectionConfig values and BuildConnectArgs produces correct nvme CLI arguments for all cases</done>
</task>

<task type="auto">
  <name>Task 2: Test StorageClass parameter parsing</name>
  <files>pkg/driver/params_test.go</files>
  <action>
Create pkg/driver/params_test.go with:

1. TestParseNVMEConnectionParams_Defaults:
   - Input: empty map
   - Expect: CtrlLossTmo=-1, ReconnectDelay=5, KeepAliveTmo=0, no error

2. TestParseNVMEConnectionParams_ValidInputs - table-driven:
   Case: ctrlLossTmo=600
   - Expect: CtrlLossTmo=600

   Case: ctrlLossTmo=-1 (explicit unlimited)
   - Expect: CtrlLossTmo=-1

   Case: reconnectDelay=10
   - Expect: ReconnectDelay=10

   Case: all params set
   - Expect: all values match input

3. TestParseNVMEConnectionParams_InvalidInputs - table-driven:
   Case: ctrlLossTmo="abc" (not a number)
   - Expect: error containing "invalid ctrlLossTmo"

   Case: ctrlLossTmo="-2" (below -1)
   - Expect: error about valid range

   Case: reconnectDelay="0" (must be > 0)
   - Expect: error about positive value

   Case: reconnectDelay="-1"
   - Expect: error about positive value

4. TestToVolumeContext:
   - Input: NVMEConnectionParams with known values
   - Expect: map with string representations

Use require.NoError and require.Error from testify.
  </action>
  <verify>go test ./pkg/driver/... -v -run TestParse\|TestToVolume</verify>
  <done>Tests verify parameter parsing defaults, valid inputs, and validation errors</done>
</task>

<task type="auto">
  <name>Task 3: Test retry utilities</name>
  <files>pkg/utils/retry_test.go</files>
  <action>
Create pkg/utils/retry_test.go with:

1. TestDefaultBackoffConfig:
   - Verify Steps == 5
   - Verify Duration == 1 * time.Second
   - Verify Factor == 2.0
   - Verify Jitter == 0.1

2. TestIsRetryableError - table-driven:
   Case: nil error
   - Expect: false

   Case: "connection refused"
   - Expect: true

   Case: "Connection Refused" (case insensitive)
   - Expect: true

   Case: "no route to host"
   - Expect: true

   Case: "network unreachable"
   - Expect: true

   Case: "device did not appear"
   - Expect: true

   Case: "i/o timeout"
   - Expect: true

   Case: "permission denied"
   - Expect: false

   Case: "invalid argument"
   - Expect: false

3. TestRetryWithBackoff_Success:
   - fn succeeds on first attempt
   - Verify no retries, returns nil

4. TestRetryWithBackoff_RetryThenSuccess:
   - fn fails 2 times with retryable error, then succeeds
   - Use counter to track attempts
   - Use very short Duration (1ms) for test speed
   - Verify 3 total attempts

5. TestRetryWithBackoff_NonRetryable:
   - fn returns non-retryable error
   - Verify stops immediately, returns error

6. TestRetryWithBackoff_ContextCanceled:
   - Cancel context during retry
   - Verify returns context error

Use testing short backoff config (Duration=1ms) to speed up tests.
  </action>
  <verify>go test ./pkg/utils/... -v -run TestDefault\|TestIsRetry\|TestRetry</verify>
  <done>Tests verify backoff config, retryable error detection, and retry behavior for all cases</done>
</task>

<task type="auto">
  <name>Task 4: Test OrphanCleaner</name>
  <files>pkg/nvme/orphan_test.go</files>
  <action>
Create pkg/nvme/orphan_test.go with:

1. MockConnector (or use existing mock) that tracks:
   - DisconnectWithContext calls
   - Returns configurable connected NQNs

2. MockResolver (or use test doubles) that:
   - Returns configurable IsOrphanedSubsystem results
   - Can list subsystems

3. TestCleanupOrphanedConnections_NoOrphans:
   - Configure mock with no orphaned subsystems
   - Verify no disconnect calls
   - Verify returns nil

4. TestCleanupOrphanedConnections_WithOrphans:
   - Configure mock with 2 orphaned subsystems
   - Verify DisconnectWithContext called twice with correct NQNs
   - Verify returns nil (cleanup is best-effort)

5. TestCleanupOrphanedConnections_DisconnectError:
   - Configure mock to return error on disconnect
   - Verify continues to next orphan (doesn't fail fast)
   - Verify returns nil (errors are logged, not returned)

6. TestCleanupOrphanedConnections_ContextCanceled:
   - Cancel context
   - Verify stops cleanup early
   - Verify returns context error or nil

Use table-driven tests where appropriate. Match existing mock patterns from nvme_test.go.
  </action>
  <verify>go test ./pkg/nvme/... -v -run TestCleanup</verify>
  <done>Tests verify orphan cleanup for no orphans, with orphans, error handling, and context cancellation</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go test ./...` passes all tests
2. `go test ./... -cover` shows coverage for new code
3. Each new file has table-driven tests where appropriate
4. Test files follow existing project patterns
</verification>

<success_criteria>
- All test files compile and pass
- Tests cover happy path, edge cases, and error cases
- Table-driven tests used for multiple similar cases
- Mocks follow existing codebase patterns
- No flaky tests (use short backoff durations)
</success_criteria>

<output>
After completion, create `.planning/phases/03-reconnection-resilience/03-04-SUMMARY.md`
</output>
