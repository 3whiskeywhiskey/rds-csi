---
phase: 05-attachment-manager-foundation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - pkg/attachment/persist.go
  - pkg/attachment/rebuild.go
  - pkg/attachment/manager.go
  - pkg/driver/driver.go
autonomous: true

must_haves:
  truths:
    - "Attachment state persists to PV annotations when tracking/untracking"
    - "Controller can rebuild full attachment state from PV annotations on startup"
    - "State survives controller pod restarts"
  artifacts:
    - path: "pkg/attachment/persist.go"
      provides: "PV annotation persistence with retry on conflict"
      exports: ["persistAttachment", "clearAttachment"]
      contains: "retry.RetryOnConflict"
    - path: "pkg/attachment/rebuild.go"
      provides: "State rebuild from PV annotations"
      exports: ["RebuildState"]
      contains: "PersistentVolumes().List"
    - path: "pkg/driver/driver.go"
      provides: "AttachmentManager integration in Driver struct"
      contains: "attachmentManager"
  key_links:
    - from: "pkg/attachment/persist.go"
      to: "k8sClient.CoreV1().PersistentVolumes()"
      via: "retry.RetryOnConflict for atomic updates"
      pattern: "RetryOnConflict.*PersistentVolumes"
    - from: "pkg/attachment/rebuild.go"
      to: "k8sClient.CoreV1().PersistentVolumes().List"
      via: "scanning PV annotations"
      pattern: "List.*metav1.ListOptions"
    - from: "pkg/driver/driver.go"
      to: "pkg/attachment"
      via: "import and initialization"
      pattern: "attachment\\.NewAttachmentManager"
---

<objective>
Add PV annotation persistence, state rebuild on startup, and integrate AttachmentManager with the driver.

Purpose: Attachment state must survive controller restarts. This plan persists state to PV annotations using retry.RetryOnConflict, rebuilds state on startup by listing PVs, and wires the AttachmentManager into the Driver lifecycle.

Output: Complete FENCE-02 (annotation persistence) and FENCE-03 (state rebuild) requirements. AttachmentManager ready for use by ControllerPublishVolume in Phase 6.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.3-ROADMAP.md
@.planning/phases/05-attachment-manager-foundation/05-RESEARCH.md
@.planning/phases/05-attachment-manager-foundation/05-01-SUMMARY.md
@pkg/driver/driver.go
@pkg/attachment/manager.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PV annotation persistence</name>
  <files>pkg/attachment/persist.go, pkg/attachment/manager.go</files>
  <action>
Create persist.go with methods to update PV annotations:

**persist.go:**
```go
package attachment

import (
    "context"
    "time"

    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/client-go/util/retry"
    "k8s.io/klog/v2"
)

const (
    AnnotationAttachedNode = "rds.csi.srvlab.io/attached-node"
    AnnotationAttachedAt   = "rds.csi.srvlab.io/attached-at"
)
```

- persistAttachment(ctx context.Context, volumeID, nodeID string) error:
  1. Return nil if am.k8sClient is nil (allows operation without k8s in tests)
  2. Use retry.RetryOnConflict(retry.DefaultRetry, func() error {...})
  3. Inside retry: Get PV by volumeID, update annotations, Update PV
  4. Handle "not found" gracefully - log warning, don't fail (PV may be created later)
  5. Log V(2): "Persisted attachment: volume=%s, node=%s"

- clearAttachment(ctx context.Context, volumeID string) error:
  1. Return nil if am.k8sClient is nil
  2. Use retry.RetryOnConflict
  3. Inside retry: Get PV, delete annotations from map, Update PV
  4. Handle "not found" gracefully
  5. Log V(2): "Cleared attachment annotation: volume=%s"

**Update manager.go TrackAttachment:**
After updating in-memory state (outside the write lock), call:
```go
if err := am.persistAttachment(ctx, volumeID, nodeID); err != nil {
    // Rollback in-memory state on persistence failure
    am.mu.Lock()
    delete(am.attachments, volumeID)
    am.mu.Unlock()
    return fmt.Errorf("failed to persist attachment: %w", err)
}
```

**Update manager.go UntrackAttachment:**
After deleting from in-memory state, call clearAttachment. Log warning if it fails but don't fail the operation (in-memory state is source of truth during runtime).

IMPORTANT: Do NOT hold am.mu lock while calling persistence methods - they do I/O.
  </action>
  <verify>
Run: `go build ./pkg/attachment/...`
Expected: Clean compile
  </verify>
  <done>
- persist.go exports annotation constants
- persistAttachment updates PV annotations with retry on conflict
- clearAttachment removes annotations with retry
- TrackAttachment persists after in-memory update, rolls back on failure
- UntrackAttachment clears annotation but tolerates failures
- Locks not held during I/O operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Add state rebuild from PV annotations</name>
  <files>pkg/attachment/rebuild.go, pkg/attachment/manager.go</files>
  <action>
Create rebuild.go with startup state reconstruction:

**rebuild.go:**
- RebuildState(ctx context.Context) error method on AttachmentManager:
  1. Return nil if am.k8sClient is nil (allows operation without k8s)
  2. Log Info: "Rebuilding attachment state from PersistentVolumes"
  3. List all PVs: am.k8sClient.CoreV1().PersistentVolumes().List(ctx, metav1.ListOptions{})
  4. Acquire write lock am.mu.Lock()
  5. Clear existing state: am.attachments = make(map[string]*AttachmentState)
  6. For each PV:
     - Check pv.Spec.CSI != nil && pv.Spec.CSI.Driver == "rds.csi.srvlab.io"
     - Extract volumeID from pv.Spec.CSI.VolumeHandle
     - Check for AnnotationAttachedNode in pv.Annotations
     - If present, create AttachmentState and add to map
     - Parse AnnotationAttachedAt if present, else use time.Now()
     - Log V(2): "Rebuilt attachment: volume=%s, node=%s"
  7. Release lock
  8. Log Info: "State rebuild complete: %d attachments recovered"
  9. Return nil

**Update manager.go:**
Add Initialize(ctx context.Context) error method:
```go
func (am *AttachmentManager) Initialize(ctx context.Context) error {
    klog.Info("Initializing AttachmentManager")
    if err := am.RebuildState(ctx); err != nil {
        return fmt.Errorf("failed to rebuild state: %w", err)
    }
    klog.Info("AttachmentManager initialized successfully")
    return nil
}
```

Use driver name constant from import if possible, or define locally:
```go
const driverName = "rds.csi.srvlab.io"
```
  </action>
  <verify>
Run: `go build ./pkg/attachment/...`
Expected: Clean compile
  </verify>
  <done>
- RebuildState lists PVs and reconstructs attachments map from annotations
- Only processes PVs belonging to rds.csi.srvlab.io driver
- Initialize method wraps RebuildState for driver startup
- Handles missing k8sClient gracefully (returns nil)
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate AttachmentManager with Driver</name>
  <files>pkg/driver/driver.go</files>
  <action>
Wire AttachmentManager into the Driver struct and lifecycle:

**Driver struct additions:**
```go
// Attachment manager (for controller only)
attachmentManager *attachment.AttachmentManager
```

**DriverConfig struct additions:**
No new fields needed - uses existing K8sClient

**NewDriver() modifications:**
After RDS client initialization and before reconciler initialization (around line 131):
```go
// Initialize attachment manager if controller is enabled
if config.EnableController && config.K8sClient != nil {
    driver.attachmentManager = attachment.NewAttachmentManager(config.K8sClient)
    klog.Info("Attachment manager created")
}
```

**Run() modifications:**
Before starting orphan reconciler, initialize attachment manager:
```go
// Initialize attachment manager state
if d.attachmentManager != nil {
    ctx := context.Background()
    if err := d.attachmentManager.Initialize(ctx); err != nil {
        return fmt.Errorf("failed to initialize attachment manager: %w", err)
    }
    klog.Info("Attachment manager initialized")
}
```

**Add getter method:**
```go
// GetAttachmentManager returns the attachment manager (may be nil if controller disabled)
func (d *Driver) GetAttachmentManager() *attachment.AttachmentManager {
    return d.attachmentManager
}
```

**Add import:**
```go
"git.srvlab.io/whiskey/rds-csi-driver/pkg/attachment"
```
  </action>
  <verify>
Run: `make build-local && make lint`
Expected: Build and lint pass
  </verify>
  <done>
- Driver struct has attachmentManager field
- AttachmentManager created in NewDriver when controller enabled
- AttachmentManager.Initialize() called in Run() before serving requests
- GetAttachmentManager() getter available for controller service
- Import added for pkg/attachment
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./pkg/attachment/...` - all files compile
2. `go build ./...` - full project compiles (no import cycles)
3. `make lint` - passes
4. Code inspection shows:
   - TrackAttachment persists to PV annotations
   - RebuildState lists PVs and rebuilds in-memory state
   - Driver initializes AttachmentManager on startup
</verification>

<success_criteria>
- [ ] persist.go implements persistAttachment and clearAttachment with retry.RetryOnConflict
- [ ] rebuild.go implements RebuildState scanning all PVs for annotations
- [ ] TrackAttachment persists state, rolls back in-memory on persistence failure
- [ ] UntrackAttachment clears annotations (but tolerates failures)
- [ ] Initialize() method calls RebuildState for startup recovery
- [ ] Driver creates and initializes AttachmentManager in controller mode
- [ ] Full project builds and lints clean
</success_criteria>

<output>
After completion, create `.planning/phases/05-attachment-manager-foundation/05-02-SUMMARY.md`
</output>
