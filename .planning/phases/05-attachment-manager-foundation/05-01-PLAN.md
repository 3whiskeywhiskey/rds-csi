---
phase: 05-attachment-manager-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/attachment/types.go
  - pkg/attachment/lock.go
  - pkg/attachment/manager.go
autonomous: true

must_haves:
  truths:
    - "AttachmentManager tracks which volumes are attached to which nodes"
    - "Multiple concurrent attach requests for the same volume are serialized"
    - "Reading attachment state doesn't block other reads"
  artifacts:
    - path: "pkg/attachment/types.go"
      provides: "AttachmentState struct with VolumeID, NodeID, AttachedAt"
      exports: ["AttachmentState"]
    - path: "pkg/attachment/lock.go"
      provides: "VolumeLockManager for per-volume mutex management"
      exports: ["VolumeLockManager", "NewVolumeLockManager"]
    - path: "pkg/attachment/manager.go"
      provides: "AttachmentManager with thread-safe in-memory tracking"
      exports: ["AttachmentManager", "NewAttachmentManager", "TrackAttachment", "UntrackAttachment", "GetAttachment", "ListAttachments"]
  key_links:
    - from: "pkg/attachment/manager.go"
      to: "pkg/attachment/lock.go"
      via: "volumeLocks field using VolumeLockManager"
      pattern: "volumeLocks.*VolumeLockManager"
    - from: "pkg/attachment/manager.go"
      to: "pkg/attachment/types.go"
      via: "attachments map using AttachmentState"
      pattern: "map\\[string\\]\\*AttachmentState"
---

<objective>
Create the core AttachmentManager package with in-memory state tracking and per-volume locking.

Purpose: This is the foundation for volume fencing - the manager tracks which volumes are attached to which nodes, enabling the driver to reject duplicate attachments. Per-volume locks prevent race conditions when multiple CSI requests arrive for the same volume.

Output: New pkg/attachment/ package with types.go, lock.go, and manager.go implementing FENCE-01 (in-memory tracking with RWMutex) and FENCE-04 (per-volume locking).
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.3-ROADMAP.md
@.planning/phases/05-attachment-manager-foundation/05-RESEARCH.md
@pkg/driver/driver.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create attachment types and lock manager</name>
  <files>pkg/attachment/types.go, pkg/attachment/lock.go</files>
  <action>
Create pkg/attachment/ directory and implement two files:

**types.go:**
- Package attachment
- AttachmentState struct with:
  - VolumeID string
  - NodeID string
  - AttachedAt time.Time
- Add doc comment explaining this represents a tracked volume-to-node binding

**lock.go:**
- VolumeLockManager struct with:
  - mu sync.Mutex (protects the locks map)
  - locks map[string]*sync.Mutex (per-volume locks)
- NewVolumeLockManager() *VolumeLockManager constructor
- Lock(volumeID string) method - gets or creates per-volume mutex, then locks it
- Unlock(volumeID string) method - unlocks the per-volume mutex

Critical implementation detail from research: In Lock(), acquire vlm.mu.Lock() to get/create the per-volume lock, then vlm.mu.Unlock() BEFORE calling lock.Lock(). This prevents holding the manager lock while waiting for a per-volume lock.

Follow existing codebase patterns from pkg/nvme/nvme.go and pkg/rds/pool.go for mutex usage.
  </action>
  <verify>
Run: `go build ./pkg/attachment/...`
Expected: Clean compile with no errors
  </verify>
  <done>
- pkg/attachment/types.go exports AttachmentState struct
- pkg/attachment/lock.go exports VolumeLockManager with Lock/Unlock methods
- Lock acquisition order prevents deadlocks (manager lock released before per-volume lock acquired)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AttachmentManager with in-memory tracking</name>
  <files>pkg/attachment/manager.go</files>
  <action>
Create the main AttachmentManager with thread-safe in-memory state:

**manager.go:**
- AttachmentManager struct with:
  - mu sync.RWMutex (protects attachments map)
  - attachments map[string]*AttachmentState (volumeID -> state)
  - volumeLocks *VolumeLockManager (for per-volume operation locks)
  - k8sClient kubernetes.Interface (for future PV annotation updates, can be nil initially)

- NewAttachmentManager(k8sClient kubernetes.Interface) *AttachmentManager constructor

- TrackAttachment(ctx context.Context, volumeID, nodeID string) error:
  1. Acquire per-volume lock: am.volumeLocks.Lock(volumeID), defer Unlock
  2. Check existing under RLock - if exists with same nodeID, return nil (idempotent)
  3. If exists with different nodeID, return error "volume %s already attached to node %s"
  4. Create new AttachmentState with time.Now()
  5. Store under write Lock
  6. Log at V(2): "Tracked attachment: volume=%s, node=%s"
  7. Return nil

- UntrackAttachment(ctx context.Context, volumeID string) error:
  1. Acquire per-volume lock
  2. Delete from map under write Lock
  3. If didn't exist, log V(2) and return nil (idempotent)
  4. Log V(2): "Untracked attachment: volume=%s"
  5. Return nil

- GetAttachment(volumeID string) (*AttachmentState, bool):
  1. RLock, defer RUnlock
  2. Return state and exists bool (don't return error for not-found, it's not exceptional)

- ListAttachments() map[string]*AttachmentState:
  1. RLock, defer RUnlock
  2. Return copy of map (to prevent external mutation)

Use klog.V(2).Infof for operation logging, matching existing codebase patterns.
  </action>
  <verify>
Run: `go build ./pkg/attachment/... && go vet ./pkg/attachment/...`
Expected: Clean compile and vet with no warnings
  </verify>
  <done>
- AttachmentManager exports all four methods
- TrackAttachment is idempotent (returns nil if already attached to same node)
- TrackAttachment returns error if attached to different node
- UntrackAttachment is idempotent (returns nil if not tracked)
- GetAttachment uses RLock for concurrent read access
- Per-volume locks serialize operations on the same volume
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify package compiles and integrates</name>
  <files>pkg/attachment/manager.go</files>
  <action>
Ensure the package compiles correctly and can be imported:

1. Run full project build to verify no import cycles
2. Run go vet to check for common issues
3. Run golangci-lint on the new package

If any issues found, fix them before completing.

Add package documentation comment at top of manager.go explaining the purpose:
```go
// Package attachment provides thread-safe tracking of volume-to-node attachments
// for the RDS CSI driver. It uses in-memory state with RWMutex for concurrent access
// and per-volume locks to serialize operations on individual volumes.
```
  </action>
  <verify>
Run: `make build-local && make lint`
Expected: Build succeeds and linter passes with no new warnings in pkg/attachment/
  </verify>
  <done>
- `make build-local` succeeds
- `make lint` passes for pkg/attachment/
- Package has proper documentation comment
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./pkg/attachment/...` - compiles cleanly
2. `go vet ./pkg/attachment/...` - no warnings
3. `make lint` - passes for new package
4. New files exist: pkg/attachment/types.go, lock.go, manager.go
</verification>

<success_criteria>
- [ ] pkg/attachment/ package created with types.go, lock.go, manager.go
- [ ] AttachmentState struct defined with VolumeID, NodeID, AttachedAt
- [ ] VolumeLockManager implements per-volume locking without deadlock risk
- [ ] AttachmentManager implements TrackAttachment, UntrackAttachment, GetAttachment, ListAttachments
- [ ] TrackAttachment returns error for conflicting node attachment
- [ ] All operations are thread-safe with RWMutex + per-volume locks
- [ ] Code compiles and passes linter
</success_criteria>

<output>
After completion, create `.planning/phases/05-attachment-manager-foundation/05-01-SUMMARY.md`
</output>
