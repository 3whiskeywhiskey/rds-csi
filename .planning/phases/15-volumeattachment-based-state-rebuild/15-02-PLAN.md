---
phase: 15-volumeattachment-based-state-rebuild
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - pkg/attachment/rebuild.go
autonomous: true

must_haves:
  truths:
    - "On startup, controller lists VolumeAttachment objects and rebuilds state from them"
    - "PV annotations are NOT read during rebuild (VolumeAttachment is source of truth)"
    - "Multiple VolumeAttachments for same volume are detected (migration state)"
    - "AccessMode is looked up from PV during rebuild"
  artifacts:
    - path: "pkg/attachment/rebuild.go"
      provides: "VA-based state rebuild replacing PV annotation-based rebuild"
      exports: ["RebuildState", "RebuildStateFromVolumeAttachments"]
      contains: "VolumeAttachments"
  key_links:
    - from: "pkg/attachment/rebuild.go"
      to: "pkg/attachment/va_lister.go"
      via: "ListDriverVolumeAttachments call"
      pattern: "ListDriverVolumeAttachments"
    - from: "pkg/attachment/rebuild.go"
      to: "k8s.io/client-go"
      via: "PV lookup for access mode"
      pattern: "PersistentVolumes\\(\\)\\.Get"
---

<objective>
Replace PV annotation-based RebuildState with VolumeAttachment-based rebuild.

Purpose: VolumeAttachment objects are the authoritative source for attachment state (managed by external-attacher). This eliminates stale annotation problems and aligns with CSI best practices.

Output: rebuild.go that reads VolumeAttachments on startup instead of PV annotations
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-volumeattachment-based-state-rebuild/15-RESEARCH.md

@pkg/attachment/rebuild.go
@pkg/attachment/manager.go
@pkg/attachment/types.go
@pkg/attachment/va_lister.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RebuildStateFromVolumeAttachments</name>
  <files>pkg/attachment/rebuild.go</files>
  <action>
Add new function RebuildStateFromVolumeAttachments to rebuild.go:

```go
func (am *AttachmentManager) RebuildStateFromVolumeAttachments(ctx context.Context) error {
    if am.k8sClient == nil {
        klog.V(2).Info("Skipping state rebuild (no k8s client)")
        return nil
    }

    klog.Info("Rebuilding attachment state from VolumeAttachment objects")

    // Step 1: List all VolumeAttachments for our driver
    allVAs, err := ListDriverVolumeAttachments(ctx, am.k8sClient)
    if err != nil {
        return fmt.Errorf("failed to list VolumeAttachments: %w", err)
    }

    // Step 2: Filter to only attached VAs
    attachedVAs := FilterAttachedVolumeAttachments(allVAs)

    // Step 3: Group by volume ID
    vaByVolume := GroupVolumeAttachmentsByVolume(attachedVAs)

    am.mu.Lock()
    defer am.mu.Unlock()

    // Clear existing state
    am.attachments = make(map[string]*AttachmentState)

    rebuiltCount := 0
    for volumeID, vas := range vaByVolume {
        state, err := am.rebuildVolumeState(ctx, volumeID, vas)
        if err != nil {
            klog.Warningf("Failed to rebuild state for volume %s: %v", volumeID, err)
            continue
        }
        am.attachments[volumeID] = state
        rebuiltCount++
    }

    klog.Infof("State rebuild complete: %d attachments recovered from VolumeAttachment objects", rebuiltCount)
    return nil
}
```

Add helper function rebuildVolumeState:
- Takes volumeID and slice of VolumeAttachments for that volume
- Creates AttachmentState with Nodes populated from each VA
- Uses VA.CreationTimestamp for AttachedAt
- If len(vas) > 1, mark as migration (MigrationStartedAt = older VA's timestamp)
- Look up PV to get AccessMode (call am.k8sClient.CoreV1().PersistentVolumes().Get)
- Handle PV not found gracefully (default to "RWO")
- Log warning if more than 2 VAs for same volume (rebuild first 2 only)

DO NOT delete the old RebuildState function yet - keep it for comparison/fallback during testing.
  </action>
  <verify>
go build ./pkg/attachment/... compiles without errors
  </verify>
  <done>
RebuildStateFromVolumeAttachments function exists and compiles, uses VA listing helpers from 15-01
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Initialize to use VA-based rebuild</name>
  <files>pkg/attachment/rebuild.go</files>
  <action>
Modify the Initialize function to use RebuildStateFromVolumeAttachments:

```go
func (am *AttachmentManager) Initialize(ctx context.Context) error {
    klog.Info("Initializing AttachmentManager")

    // Use VolumeAttachment-based rebuild (authoritative source)
    if err := am.RebuildStateFromVolumeAttachments(ctx); err != nil {
        return fmt.Errorf("failed to rebuild state from VolumeAttachments: %w", err)
    }

    klog.Info("AttachmentManager initialized successfully")
    return nil
}
```

Rename old RebuildState to RebuildStateFromAnnotations with a deprecation comment:
```go
// RebuildStateFromAnnotations reconstructs state from PV annotations.
// Deprecated: Use RebuildStateFromVolumeAttachments instead.
// PV annotations are now informational-only; VolumeAttachment is the authoritative source.
// This function is kept for backward compatibility testing.
func (am *AttachmentManager) RebuildStateFromAnnotations(ctx context.Context) error {
    // ... existing implementation ...
}
```

Keep RebuildState as an alias that calls RebuildStateFromVolumeAttachments for API compatibility:
```go
// RebuildState rebuilds attachment state from VolumeAttachment objects.
// This is the main entry point for state recovery on controller startup.
func (am *AttachmentManager) RebuildState(ctx context.Context) error {
    return am.RebuildStateFromVolumeAttachments(ctx)
}
```
  </action>
  <verify>
go build ./pkg/attachment/... compiles
grep "RebuildStateFromVolumeAttachments" pkg/attachment/rebuild.go
  </verify>
  <done>
Initialize() calls RebuildStateFromVolumeAttachments, old method renamed with deprecation notice
  </done>
</task>

<task type="auto">
  <name>Task 3: Handle AccessMode lookup from PV</name>
  <files>pkg/attachment/rebuild.go</files>
  <action>
Add helper function to look up access mode from PV:

```go
// lookupAccessMode retrieves the access mode from a PersistentVolume.
// Returns "RWX" if any access mode contains ReadWriteMany, otherwise "RWO".
// Returns "RWO" if PV not found or on error (conservative default).
func (am *AttachmentManager) lookupAccessMode(ctx context.Context, volumeID string) string {
    if am.k8sClient == nil {
        return "RWO"
    }

    pv, err := am.k8sClient.CoreV1().PersistentVolumes().Get(ctx, volumeID, metav1.GetOptions{})
    if err != nil {
        klog.V(2).Infof("Could not look up PV %s for access mode: %v (defaulting to RWO)", volumeID, err)
        return "RWO"
    }

    // Check if any access mode is RWX
    for _, mode := range pv.Spec.AccessModes {
        if mode == corev1.ReadWriteMany {
            return "RWX"
        }
    }
    return "RWO"
}
```

Use this in rebuildVolumeState to populate state.AccessMode.

Import corev1 "k8s.io/api/core/v1" for access mode constants.
  </action>
  <verify>
go build ./pkg/attachment/... compiles
grep "lookupAccessMode" pkg/attachment/rebuild.go
  </verify>
  <done>
AccessMode is correctly populated from PV.Spec.AccessModes during rebuild
  </done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
go build ./pkg/attachment/...

# New functions exist
grep "RebuildStateFromVolumeAttachments" pkg/attachment/rebuild.go
grep "RebuildStateFromAnnotations" pkg/attachment/rebuild.go
grep "lookupAccessMode" pkg/attachment/rebuild.go

# Initialize calls VA-based rebuild
grep -A3 "func.*Initialize" pkg/attachment/rebuild.go | grep "RebuildStateFromVolumeAttachments"
```
</verification>

<success_criteria>
1. RebuildStateFromVolumeAttachments function exists and uses VA listing helpers
2. Initialize() calls VA-based rebuild by default
3. Old annotation-based rebuild is preserved but deprecated
4. AccessMode is looked up from PV during rebuild
5. Migration state (multiple VAs) is detected and MigrationStartedAt is set
</success_criteria>

<output>
After completion, create `.planning/phases/15-volumeattachment-based-state-rebuild/15-02-SUMMARY.md`
</output>
