---
phase: 25.1-attachment-reconciliation-rds-resilience
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/observability/prometheus.go
  - pkg/observability/prometheus_test.go
  - pkg/rds/connection_manager.go
  - pkg/rds/connection_manager_test.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "RDS connection loss triggers automatic reconnect with exponential backoff (1s, 2s, 4s, 8s, max 16s)"
    - "Connection manager exposes IsConnected() for health check integration"
    - "Reconnection attempts are logged with backoff duration"
    - "Prometheus metrics expose RDS connection state and reconnection attempts"
    - "Connection manager can be stopped gracefully"
  artifacts:
    - path: "pkg/rds/connection_manager.go"
      provides: "Automatic reconnection with exponential backoff"
      exports: ["ConnectionManager", "NewConnectionManager", "ConnectionManagerConfig"]
    - path: "pkg/rds/connection_manager_test.go"
      provides: "Tests for reconnection logic and backoff behavior"
    - path: "pkg/observability/prometheus.go"
      provides: "RDS connection metrics (state gauge, reconnect counter, reconnect duration)"
      contains: "rds_connection_state"
  key_links:
    - from: "pkg/rds/connection_manager.go"
      to: "pkg/rds/client.go"
      via: "ConnectionManager wraps RDSClient for reconnection"
      pattern: "rds\\.RDSClient"
    - from: "pkg/rds/connection_manager.go"
      to: "pkg/observability/prometheus.go"
      via: "Records connection metrics on state changes"
      pattern: "metrics\\.Record"
    - from: "pkg/rds/connection_manager.go"
      to: "cenkalti/backoff/v4"
      via: "Uses exponential backoff for retry timing"
      pattern: "backoff\\.NewExponentialBackOff"
---

<objective>
Add RDS connection resilience with automatic reconnection and observability metrics.

Purpose: The production incident showed RDS connection loss left the controller unable to serve requests with no automatic recovery. Adding a connection manager with exponential backoff ensures the driver automatically reconnects after RDS restarts or network issues, and Prometheus metrics provide visibility into connection health.

Output: ConnectionManager with configurable backoff + new Prometheus metrics for RDS connection state tracking.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25.1-attachment-reconciliation-rds-resilience/25.1-RESEARCH.md

# Existing code to extend
@pkg/rds/client.go
@pkg/rds/ssh_client.go
@pkg/rds/mock.go
@pkg/observability/prometheus.go
@pkg/observability/prometheus_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RDS connection Prometheus metrics</name>
  <files>pkg/observability/prometheus.go, pkg/observability/prometheus_test.go</files>
  <action>
Add three new metrics to the Metrics struct in pkg/observability/prometheus.go:

1. `rdsConnectionState` - GaugeVec with label "address": 1=connected, 0=disconnected
   - Namespace: rds_csi, Subsystem: rds, Name: connection_state
   - Help: "RDS SSH connection state (1=connected, 0=disconnected)"

2. `rdsReconnectTotal` - CounterVec with label "status" (success, failure): total reconnection attempts
   - Namespace: rds_csi, Subsystem: rds, Name: reconnect_total
   - Help: "Total RDS reconnection attempts by status"

3. `rdsReconnectDuration` - Histogram: duration of reconnection attempts
   - Namespace: rds_csi, Subsystem: rds, Name: reconnect_duration_seconds
   - Help: "Duration of successful RDS reconnections in seconds"
   - Buckets: []float64{0.1, 0.5, 1, 2, 5, 10, 30, 60}

Add recording methods:
- `RecordConnectionState(address string, connected bool)` - sets gauge to 1.0 or 0.0
- `RecordReconnectAttempt(status string, duration time.Duration)` - increments counter, observes duration on success

Register all new metrics in the MustRegister call in NewMetrics().

Add tests in prometheus_test.go:
- Test RecordConnectionState sets gauge correctly for connected and disconnected
- Test RecordReconnectAttempt increments counters for success and failure
  </action>
  <verify>
Run `cd /Users/whiskey/code/rds-csi && go build ./pkg/observability/...` compiles.
Run `cd /Users/whiskey/code/rds-csi && go test ./pkg/observability/... -v` passes.
  </verify>
  <done>
Three new Prometheus metrics registered: rds_csi_rds_connection_state (gauge), rds_csi_rds_reconnect_total (counter), rds_csi_rds_reconnect_duration_seconds (histogram). Recording methods work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RDS ConnectionManager with exponential backoff</name>
  <files>pkg/rds/connection_manager.go, pkg/rds/connection_manager_test.go, go.mod, go.sum</files>
  <action>
First, add cenkalti/backoff/v4 dependency:
```
cd /Users/whiskey/code/rds-csi && go get github.com/cenkalti/backoff/v4
```

Create pkg/rds/connection_manager.go implementing a ConnectionManager that wraps an RDSClient with automatic reconnection.

Implementation:

1. `ConnectionManagerConfig` struct:
   - `Client RDSClient` (the underlying client to manage)
   - `InitialInterval time.Duration` (default: 1s)
   - `MaxInterval time.Duration` (default: 16s)
   - `MaxElapsedTime time.Duration` (default: 0 = never give up for background reconnection)
   - `Multiplier float64` (default: 2.0)
   - `RandomizationFactor float64` (default: 0.1 for jitter per research Pitfall 2)
   - `Metrics *observability.Metrics` (optional, may be nil)
   - `OnReconnect func()` (callback after successful reconnection, used to trigger reconciliation)

2. `ConnectionManager` struct:
   - config ConnectionManagerConfig
   - client RDSClient
   - connected bool (protected by sync.RWMutex)
   - mu sync.RWMutex
   - stopCh chan struct{}
   - doneCh chan struct{}
   - metrics *observability.Metrics

3. `NewConnectionManager(config ConnectionManagerConfig) *ConnectionManager`
   - Validate Client is non-nil
   - Set defaults for zero values
   - Initial connected state = client.IsConnected()

4. `IsConnected() bool` - thread-safe read of connected state

5. `GetClient() RDSClient` - returns the underlying client

6. `StartMonitor(ctx context.Context)` - starts a background goroutine that:
   - Polls client.IsConnected() every 5 seconds
   - When disconnected detected: sets connected=false, records metric, logs warning, starts reconnection loop
   - Reconnection uses cenkalti/backoff ExponentialBackOff with configured parameters
   - On successful reconnect: sets connected=true, records metric, logs info, calls OnReconnect callback if set
   - On each failed attempt: records failure metric, logs with backoff duration
   - Stops on ctx.Done() or stopCh

7. `Stop()` - signals monitor goroutine to stop, blocks until stopped

8. `Reconnect() error` - manual reconnection (closes existing connection, reconnects). Used for startup.

Important: Do NOT wrap every RDSClient method - ConnectionManager is a monitor/reconnector, not a proxy. The driver calls client methods directly. ConnectionManager just manages the connection lifecycle in the background.

Anti-patterns to avoid (from research):
- Do NOT block CSI RPC calls waiting for reconnection (fail fast with codes.Unavailable)
- Do NOT use unbounded retry without jitter (always include RandomizationFactor)
- Close old SSH connection BEFORE reconnecting (Pitfall 4: session leaks)

Create pkg/rds/connection_manager_test.go with tests:
- Test NewConnectionManager with defaults applied
- Test IsConnected reflects actual client state
- Test StartMonitor detects disconnection (use MockClient that returns IsConnected()=false)
- Test reconnection attempts with backoff (verify timing roughly doubles)
- Test OnReconnect callback is called after successful reconnection
- Test Stop() gracefully shuts down monitor
- Test Reconnect() manual reconnection works

For testing: extend MockClient to support configurable IsConnected() behavior:
- Add a `connected bool` field to MockClient
- Add `SetConnected(bool)` method
- Update IsConnected() to return this field
  </action>
  <verify>
Run `cd /Users/whiskey/code/rds-csi && go build ./pkg/rds/...` compiles.
Run `cd /Users/whiskey/code/rds-csi && go test ./pkg/rds/... -run TestConnection -v` passes.
Run `cd /Users/whiskey/code/rds-csi && go mod tidy` succeeds.
  </verify>
  <done>
ConnectionManager detects RDS disconnection, reconnects with exponential backoff (1s->2s->4s->8s->16s max), records Prometheus metrics, and calls OnReconnect callback. MockClient supports configurable connection state for testing.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` compiles without errors (full project)
- `go test ./pkg/rds/... -v` all tests pass
- `go test ./pkg/observability/... -v` all tests pass
- `go mod tidy` no unused dependencies
- `go vet ./pkg/rds/... ./pkg/observability/...` no issues
</verification>

<success_criteria>
1. cenkalti/backoff/v4 added to go.mod
2. Three new Prometheus metrics registered and recordable
3. ConnectionManager monitors connection health in background
4. Exponential backoff with jitter applied to reconnection attempts
5. OnReconnect callback fires after successful reconnection
6. MockClient IsConnected() is now configurable for testing
7. All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/25.1-attachment-reconciliation-rds-resilience/25.1-02-SUMMARY.md`
</output>
