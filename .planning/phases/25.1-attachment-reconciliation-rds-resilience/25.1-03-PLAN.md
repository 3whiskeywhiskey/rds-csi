---
phase: 25.1-attachment-reconciliation-rds-resilience
plan: 03
type: execute
wave: 2
depends_on: ["25.1-01", "25.1-02"]
files_modified:
  - pkg/driver/driver.go
  - pkg/driver/driver_test.go
  - pkg/driver/identity.go
  - pkg/driver/identity_test.go
  - pkg/driver/events.go
autonomous: true

must_haves:
  truths:
    - "Controller performs startup reconciliation detecting stale attachments before serving requests"
    - "Node informer watcher is registered and triggers reconciliation on node failures"
    - "ConnectionManager monitors RDS health and reconnects automatically"
    - "CSI Probe returns ready=false when RDS is disconnected"
    - "Kubernetes events are emitted for RDS connection state changes"
    - "After RDS reconnection, attachment reconciliation is triggered"
  artifacts:
    - path: "pkg/driver/driver.go"
      provides: "Wired startup reconciliation, node watcher, and connection manager"
      contains: "performStartupReconciliation"
    - path: "pkg/driver/identity.go"
      provides: "Connection-aware Probe health check"
      contains: "IsConnected"
    - path: "pkg/driver/identity_test.go"
      provides: "Tests for Probe with connected and disconnected states"
    - path: "pkg/driver/driver_test.go"
      provides: "Integration tests for startup reconciliation and wiring"
  key_links:
    - from: "pkg/driver/driver.go"
      to: "pkg/attachment/node_watcher.go"
      via: "Registers NodeWatcher event handlers on node informer"
      pattern: "nodeInformer\\.AddEventHandler"
    - from: "pkg/driver/driver.go"
      to: "pkg/rds/connection_manager.go"
      via: "Creates and starts ConnectionManager with OnReconnect callback"
      pattern: "rds\\.NewConnectionManager"
    - from: "pkg/driver/driver.go"
      to: "pkg/attachment/reconciler.go"
      via: "OnReconnect triggers reconciler.TriggerReconcile()"
      pattern: "TriggerReconcile"
    - from: "pkg/driver/identity.go"
      to: "pkg/rds/connection_manager.go"
      via: "Probe checks connectionManager.IsConnected()"
      pattern: "connectionManager\\.IsConnected"
---

<objective>
Wire all Phase 25.1 components into the driver: startup reconciliation, node watcher registration, connection manager integration, and health-aware probe.

Purpose: Plans 01 and 02 created the building blocks (NodeWatcher, TriggerReconcile, ConnectionManager, metrics). This plan integrates them into the driver's lifecycle so they actually function in production. Without this wiring, the components exist but never execute.

Output: Fully integrated driver with startup reconciliation, event-driven node watching, automatic RDS reconnection, and connection-aware health checks.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25.1-attachment-reconciliation-rds-resilience/25.1-RESEARCH.md

# Plan 01 outputs (will exist by execution time)
@.planning/phases/25.1-attachment-reconciliation-rds-resilience/25.1-01-SUMMARY.md

# Plan 02 outputs (will exist by execution time)
@.planning/phases/25.1-attachment-reconciliation-rds-resilience/25.1-02-SUMMARY.md

# Existing code to modify
@pkg/driver/driver.go
@pkg/driver/driver_test.go
@pkg/driver/identity.go
@pkg/driver/identity_test.go
@pkg/driver/events.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire startup reconciliation and node watcher into driver</name>
  <files>pkg/driver/driver.go, pkg/driver/events.go, pkg/driver/driver_test.go</files>
  <action>
Modify pkg/driver/driver.go to integrate startup reconciliation, node watcher, and connection manager.

**New fields on Driver struct:**
- `connectionManager *rds.ConnectionManager` (for RDS connection resilience)
- `nodeWatcher *attachment.NodeWatcher` (for event-driven reconciliation)

**In NewDriver():**
No changes needed here - connection manager and node watcher are initialized in Run() after informers are ready (per Pitfall 1: informer cache must be synced first).

**In Run() method, add these steps IN ORDER after existing "Informer caches synced" block:**

1. **Register node watcher on informer** (after informer factory started and synced):
```go
if d.attachmentReconciler != nil && d.informerFactory != nil {
    d.nodeWatcher = attachment.NewNodeWatcher(d.attachmentReconciler, d.metrics)
    nodeInformer := d.informerFactory.Core().V1().Nodes().Informer()
    nodeInformer.AddEventHandler(d.nodeWatcher.GetEventHandlers())
    klog.Info("Node watcher registered for attachment reconciliation triggers")
}
```

2. **Start connection manager** (after RDS client is connected):
```go
if d.rdsClient != nil {
    cmConfig := rds.ConnectionManagerConfig{
        Client:  d.rdsClient,
        Metrics: d.metrics,
    }
    // Set OnReconnect callback to trigger attachment reconciliation
    if d.attachmentReconciler != nil {
        cmConfig.OnReconnect = func() {
            klog.Info("RDS reconnected, triggering attachment reconciliation")
            d.attachmentReconciler.TriggerReconcile()
        }
    }
    d.connectionManager = rds.NewConnectionManager(cmConfig)
    ctx := context.Background()
    d.connectionManager.StartMonitor(ctx)
    klog.Info("RDS connection manager started with automatic reconnection")
}
```

3. **Perform startup reconciliation** (after informers synced AND attachment manager initialized):
```go
if d.attachmentReconciler != nil {
    klog.Info("Performing startup attachment reconciliation...")
    reconcileCtx, reconcileCancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer reconcileCancel()
    d.attachmentReconciler.TriggerReconcile()
    klog.Info("Startup reconciliation triggered")
}
```
Note: Use TriggerReconcile() rather than calling reconcile() directly, since the reconciler is already started by this point and TriggerReconcile handles the deduplication properly.

**In Stop() method:**
Add connection manager shutdown before RDS client close:
```go
if d.connectionManager != nil {
    d.connectionManager.Stop()
    klog.Info("RDS connection manager stopped")
}
```

**In events.go - add new event types for RDS connection state:**
Add event reason constants:
- `EventReasonRDSDisconnected = "RDSDisconnected"`
- `EventReasonRDSReconnected = "RDSReconnected"`
- `EventReasonStartupReconciliation = "StartupReconciliation"`

These are defined for use by the connection manager and startup reconciliation logging. The actual event posting will use the existing EventPoster infrastructure.

**Add tests in driver_test.go:**
- Test that driver initializes with all new components when controller mode is enabled
- Test that Stop() properly shuts down connection manager
- Test that node watcher is nil when controller is disabled
- Test that connection manager is nil when RDS client is nil
  </action>
  <verify>
Run `cd /Users/whiskey/code/rds-csi && go build ./pkg/driver/...` compiles cleanly.
Run `cd /Users/whiskey/code/rds-csi && go test ./pkg/driver/... -run TestDriver -v -count=1` passes.
  </verify>
  <done>
Driver.Run() registers node watcher on informer, starts connection manager with reconciliation callback, and triggers startup reconciliation. Driver.Stop() cleanly shuts down connection manager. All components wired and functioning.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make Probe health check connection-aware with metrics</name>
  <files>pkg/driver/identity.go, pkg/driver/identity_test.go</files>
  <action>
Update pkg/driver/identity.go Probe() method to use ConnectionManager for health checking.

The existing Probe() already checks `ids.driver.rdsClient.IsConnected()` and returns `ready=false` when disconnected. Enhance it to:

1. Check connectionManager if available (preferred over raw client check):
```go
func (ids *IdentityServer) Probe(ctx context.Context, req *csi.ProbeRequest) (*csi.ProbeResponse, error) {
    klog.V(5).Info("Probe called")
    ready := true

    // Check RDS connection state (prefer connectionManager if available)
    if ids.driver.connectionManager != nil {
        if !ids.driver.connectionManager.IsConnected() {
            klog.Warning("RDS client is not connected - reporting not ready")
            ready = false
        }
    } else if ids.driver.rdsClient != nil {
        // Fallback to direct client check
        if !ids.driver.rdsClient.IsConnected() {
            klog.Warning("RDS client is not connected - reporting not ready")
            ready = false
        }
    }

    // Record connection state metric
    if ids.driver.metrics != nil && ids.driver.rdsClient != nil {
        ids.driver.metrics.RecordConnectionState(ids.driver.rdsClient.GetAddress(), ready)
    }

    return &csi.ProbeResponse{
        Ready: wrapperspb.Bool(ready),
    }, nil
}
```

2. Add metric recording for connection state on every probe call (this provides a continuous signal for Prometheus scraping).

**Add tests in identity_test.go:**
- Test Probe returns ready=true when connectionManager.IsConnected()=true
- Test Probe returns ready=false when connectionManager.IsConnected()=false
- Test Probe returns ready=true when no RDS client (node mode)
- Test Probe falls back to rdsClient.IsConnected() when no connectionManager
- Test Probe records metrics when metrics are available
- Test Probe doesn't panic when metrics are nil

Use MockClient with configurable IsConnected for testing. For ConnectionManager testing, create a mock or use the real one with MockClient.
  </action>
  <verify>
Run `cd /Users/whiskey/code/rds-csi && go build ./pkg/driver/...` compiles cleanly.
Run `cd /Users/whiskey/code/rds-csi && go test ./pkg/driver/... -run TestProbe -v -count=1` passes.
Run `cd /Users/whiskey/code/rds-csi && go test ./pkg/driver/... -run TestIdentity -v -count=1` passes.
  </verify>
  <done>
Probe health check reflects actual RDS connection state via ConnectionManager. Returns ready=false when disconnected. Records Prometheus metrics on each probe call. Falls back gracefully when ConnectionManager is not available.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify integration</name>
  <files></files>
  <action>
Run the complete test suite to ensure all components work together without regressions:

1. `cd /Users/whiskey/code/rds-csi && go vet ./...` - ensure no vet issues
2. `cd /Users/whiskey/code/rds-csi && go test ./... -count=1` - full test suite
3. `cd /Users/whiskey/code/rds-csi && make sanity` - CSI sanity tests still pass (critical regression check)

If any tests fail:
- Fix the failures
- Re-run until green

If sanity tests fail due to Probe returning not-ready (since sanity tests may not set up a connected client):
- Ensure Probe returns ready=true when rdsClient is nil (node-only mode and sanity test mode)
- The current implementation already handles this: `if ids.driver.connectionManager != nil` / `else if ids.driver.rdsClient != nil` guards ensure ready=true when neither is set

Check test coverage hasn't regressed:
- `cd /Users/whiskey/code/rds-csi && go test ./pkg/attachment/... -cover` should show coverage
- `cd /Users/whiskey/code/rds-csi && go test ./pkg/rds/... -cover` should show coverage
- `cd /Users/whiskey/code/rds-csi && go test ./pkg/driver/... -cover` should show coverage
  </action>
  <verify>
`go test ./... -count=1` exits 0 (all tests pass).
`make sanity` exits 0 (CSI sanity tests pass).
`go vet ./...` exits 0 (no vet issues).
  </verify>
  <done>
Full test suite passes including CSI sanity tests. No regressions introduced. Test coverage maintained or improved. All Phase 25.1 components (NodeWatcher, TriggerReconcile, ConnectionManager, metrics, startup reconciliation, connection-aware Probe) are integrated and functional.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` compiles without errors
- `go test ./... -count=1` all tests pass
- `make sanity` CSI sanity tests pass
- `go vet ./...` no issues
- Probe returns ready=false when RDS disconnected
- Startup reconciliation triggers on driver startup
- Node watcher registered on informer
- Connection manager running with backoff
</verification>

<success_criteria>
1. Driver.Run() starts NodeWatcher, ConnectionManager, and triggers startup reconciliation
2. Driver.Stop() cleanly shuts down ConnectionManager
3. Probe returns ready=false when RDS is disconnected
4. Post-reconnection triggers attachment reconciliation via callback
5. All existing tests pass (no regressions)
6. CSI sanity tests pass
7. New event reason constants defined for RDS connection lifecycle
</success_criteria>

<output>
After completion, create `.planning/phases/25.1-attachment-reconciliation-rds-resilience/25.1-03-SUMMARY.md`
</output>
