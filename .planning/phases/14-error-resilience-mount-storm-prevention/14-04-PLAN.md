---
phase: 14-error-resilience-mount-storm-prevention
plan: 04
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - cmd/rds-csi-plugin/main.go
  - pkg/driver/driver.go
  - deploy/kubernetes/node.yaml
  - deploy/kubernetes/kustomization.yaml
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Driver shuts down gracefully within 30 seconds"
    - "In-flight operations complete before shutdown"
    - "Kubernetes deployment includes CSI_MANAGED_NQN_PREFIX env var"
    - "Node DaemonSet has terminationGracePeriodSeconds: 60"
  artifacts:
    - path: "cmd/rds-csi-plugin/main.go"
      provides: "Graceful shutdown with 30s timeout"
      contains: "shutdownTimeout"
    - path: "deploy/kubernetes/node.yaml"
      provides: "Node deployment with NQN prefix configuration"
      contains: "CSI_MANAGED_NQN_PREFIX"
  key_links:
    - from: "cmd/rds-csi-plugin/main.go"
      to: "pkg/driver/driver.go"
      via: "ShutdownWithContext call"
      pattern: "ShutdownWithContext"
    - from: "deploy/kubernetes/node.yaml"
      to: "CSI_MANAGED_NQN_PREFIX"
      via: "Environment variable from ConfigMap"
      pattern: "nqn-prefix"
---

<objective>
Implement graceful shutdown and update deployment configuration for Phase 14 features.

Purpose: Ensure the driver shuts down cleanly within 30 seconds even during stuck operations, and update Kubernetes deployment manifests to include the new CSI_MANAGED_NQN_PREFIX configuration.

Output: Graceful shutdown implementation in main.go, updated node.yaml with NQN prefix env var, extended terminationGracePeriodSeconds.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-error-resilience-mount-storm-prevention/14-CONTEXT.md
@.planning/phases/14-error-resilience-mount-storm-prevention/14-RESEARCH.md
@cmd/rds-csi-plugin/main.go
@pkg/driver/driver.go
@deploy/kubernetes/node.yaml
@deploy/kubernetes/controller.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement graceful shutdown with timeout</name>
  <files>cmd/rds-csi-plugin/main.go, pkg/driver/driver.go</files>
  <action>
Update `pkg/driver/driver.go`:

1. Add new method ShutdownWithContext to Driver:
   ```go
   // ShutdownWithContext gracefully stops the driver within the given context timeout.
   // Returns error if shutdown does not complete within the timeout.
   func (d *Driver) ShutdownWithContext(ctx context.Context) error {
       klog.Info("Initiating graceful shutdown")

       // Create channel to signal shutdown complete
       done := make(chan struct{})

       go func() {
           d.Stop()
           close(done)
       }()

       select {
       case <-done:
           klog.Info("Graceful shutdown complete")
           return nil
       case <-ctx.Done():
           klog.Warningf("Shutdown did not complete within timeout: %v", ctx.Err())
           return ctx.Err()
       }
   }
   ```

Update `cmd/rds-csi-plugin/main.go`:

1. Add shutdown timeout constant at top:
   ```go
   const (
       // ShutdownTimeout is the maximum time to wait for graceful shutdown
       ShutdownTimeout = 30 * time.Second
   )
   ```

2. Replace the existing signal handler (around line 204-212) with improved graceful shutdown:
   ```go
   // Handle shutdown gracefully with timeout
   sigChan := make(chan os.Signal, 1)
   signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

   // Start driver in goroutine so we can handle signals
   errChan := make(chan error, 1)
   go func() {
       klog.Infof("Starting driver in modes: controller=%v node=%v", *controllerMode, *nodeMode)
       if err := drv.Run(*endpoint); err != nil {
           errChan <- err
       }
   }()

   // Wait for signal or driver error
   select {
   case sig := <-sigChan:
       klog.Infof("Received signal %s, initiating graceful shutdown", sig)

       // Create shutdown context with timeout
       shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), ShutdownTimeout)
       defer shutdownCancel()

       if err := drv.ShutdownWithContext(shutdownCtx); err != nil {
           klog.Errorf("Graceful shutdown failed: %v", err)
           os.Exit(1)
       }
       klog.Info("Driver stopped gracefully")
       os.Exit(0)

   case err := <-errChan:
       klog.Fatalf("Driver failed: %v", err)
   }
   ```

3. Remove the trailing `select {}` (around line 221) since the new code handles waiting.
  </action>
  <verify>
Run `go build ./...` to verify compilation.
Manual test: Start driver and send SIGTERM - verify it logs shutdown messages and exits cleanly within 30s.
  </verify>
  <done>
Graceful shutdown implemented with 30s timeout. Driver waits for in-flight operations to complete. Clear logging for shutdown progress.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Kubernetes deployment manifests</name>
  <files>deploy/kubernetes/node.yaml, deploy/kubernetes/controller.yaml, deploy/kubernetes/kustomization.yaml</files>
  <action>
Update `deploy/kubernetes/node.yaml`:

1. Add terminationGracePeriodSeconds to pod spec (after tolerations section):
   ```yaml
   spec:
     serviceAccountName: rds-csi-node
     hostNetwork: true
     dnsPolicy: ClusterFirstWithHostNet
     priorityClassName: system-node-critical

     # Allow extra time for volume cleanup before SIGKILL
     terminationGracePeriodSeconds: 60
   ```

2. Add CSI_MANAGED_NQN_PREFIX env var to rds-csi-driver container (in the env section, after NODE_ID):
   ```yaml
   env:
     - name: CSI_ENDPOINT
       value: unix:///csi/csi.sock
     - name: NODE_ID
       valueFrom:
         fieldRef:
           fieldPath: spec.nodeName
     # NQN prefix for volume filtering - REQUIRED for safety
     - name: CSI_MANAGED_NQN_PREFIX
       valueFrom:
         configMapKeyRef:
           name: rds-csi-config
           key: nqn-prefix
   ```

Update `deploy/kubernetes/controller.yaml`:

1. Add nqn-prefix to the ConfigMap (rds-csi-config, in the data section):
   ```yaml
   data:
     # RDS connection settings (SSH management interface)
     rds-address: "10.42.241.3"
     rds-port: "22"
     rds-user: "metal-csi"
     rds-volume-base-path: "/storage-pool/metal-csi"
     # NQN prefix for CSI-managed volumes (safety filter)
     nqn-prefix: "nqn.2000-02.com.mikrotik:pvc-"
   ```

Note: Controller does not need CSI_MANAGED_NQN_PREFIX since it doesn't use the orphan cleaner or NVMe connections.
  </action>
  <verify>
Run `kubectl apply --dry-run=client -f deploy/kubernetes/` to verify YAML syntax.
Grep for changes: `grep -n "terminationGracePeriodSeconds\|CSI_MANAGED_NQN_PREFIX\|nqn-prefix" deploy/kubernetes/*.yaml`
  </verify>
  <done>
Node DaemonSet has terminationGracePeriodSeconds: 60. CSI_MANAGED_NQN_PREFIX env var configured from ConfigMap. ConfigMap includes nqn-prefix setting.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Phase 14 documentation and update ROADMAP</name>
  <files>docs/configuration.md (if exists, otherwise skip)</files>
  <action>
Create or update configuration documentation to document new settings:

1. If docs/configuration.md exists, add section for Phase 14 settings:
   ```markdown
   ## Error Resilience Settings (Phase 14)

   ### NQN Prefix Filtering

   The driver only manages NVMe volumes that match the configured NQN prefix. This prevents
   accidental disconnection of system volumes (e.g., NixOS diskless nodes that mount /var
   from RDS).

   **Environment Variable:** `CSI_MANAGED_NQN_PREFIX`
   **Default:** `nqn.2000-02.com.mikrotik:pvc-`
   **Required:** Yes (driver refuses to start without it)

   Configure via Kubernetes ConfigMap:
   ```yaml
   data:
     nqn-prefix: "nqn.2000-02.com.mikrotik:pvc-"
   ```

   ### Circuit Breaker

   The driver uses per-volume circuit breakers to prevent retry storms on repeatedly
   failing volumes. After 3 consecutive failures, the circuit opens and returns
   `Unavailable` error until reset.

   **Reset via PV annotation:**
   ```yaml
   metadata:
     annotations:
       rds.csi.srvlab.io/reset-circuit-breaker: "true"
   ```

   ### Graceful Shutdown

   The driver waits up to 30 seconds for in-flight operations to complete during
   shutdown. Set `terminationGracePeriodSeconds: 60` in the pod spec to give
   Kubernetes enough time before SIGKILL.
   ```

2. If docs/configuration.md does not exist, skip this step (documentation is optional).

3. Log completion message indicating Phase 14 configuration is ready.
  </action>
  <verify>
If docs/configuration.md was updated, verify markdown syntax is valid.
Run `ls -la docs/` to check if docs directory exists.
  </verify>
  <done>
Configuration documentation updated (if exists). Phase 14 settings documented for operators.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `go build ./...`
2. YAML syntax valid: `kubectl apply --dry-run=client -f deploy/kubernetes/`
3. Graceful shutdown works: Start driver, send SIGTERM, verify clean exit within 30s
4. NQN prefix in deployment: `grep "nqn-prefix" deploy/kubernetes/controller.yaml`
5. terminationGracePeriodSeconds set: `grep "terminationGracePeriodSeconds" deploy/kubernetes/node.yaml`
</verification>

<success_criteria>
- ShutdownWithContext method handles graceful shutdown with timeout
- main.go uses 30s shutdown timeout with proper signal handling
- node.yaml has terminationGracePeriodSeconds: 60
- node.yaml has CSI_MANAGED_NQN_PREFIX env var from ConfigMap
- controller.yaml ConfigMap includes nqn-prefix setting
- All builds and dry-run validations pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-error-resilience-mount-storm-prevention/14-04-SUMMARY.md`
</output>
