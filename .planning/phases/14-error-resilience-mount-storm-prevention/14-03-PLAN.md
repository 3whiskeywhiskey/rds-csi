---
phase: 14-error-resilience-mount-storm-prevention
plan: 03
type: execute
wave: 2
depends_on: ["14-01", "14-02"]
files_modified:
  - pkg/circuitbreaker/breaker.go
  - pkg/circuitbreaker/breaker_test.go
  - pkg/mount/health.go
  - pkg/mount/health_test.go
  - pkg/driver/node.go
  - go.mod
  - go.sum
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Circuit breaker opens after 3 consecutive failures for a volume"
    - "Circuit breaker returns Unavailable error when open"
    - "Filesystem health check runs before mount on filesystem volumes"
    - "Health check detects corrupted ext4/xfs filesystems"
    - "Circuit breaker can be reset via PV annotation"
  artifacts:
    - path: "pkg/circuitbreaker/breaker.go"
      provides: "Per-volume circuit breaker with exponential backoff"
      exports: ["VolumeCircuitBreaker", "NewVolumeCircuitBreaker"]
    - path: "pkg/circuitbreaker/breaker_test.go"
      provides: "Circuit breaker unit tests"
      min_lines: 60
    - path: "pkg/mount/health.go"
      provides: "Filesystem health check before mount"
      exports: ["CheckFilesystemHealth"]
    - path: "pkg/mount/health_test.go"
      provides: "Health check unit tests"
      min_lines: 40
  key_links:
    - from: "pkg/driver/node.go"
      to: "pkg/circuitbreaker/breaker.go"
      via: "Circuit breaker check in NodeStageVolume"
      pattern: "circuitBreaker.Execute"
    - from: "pkg/driver/node.go"
      to: "pkg/mount/health.go"
      via: "Health check before mount"
      pattern: "CheckFilesystemHealth"
---

<objective>
Implement circuit breaker for mount operations and filesystem health checks.

Purpose: Prevent retry storms on repeatedly failing volumes. When a volume fails to mount multiple times (often due to filesystem corruption), the circuit breaker opens and returns an error immediately instead of retrying indefinitely. The filesystem health check runs before mount to detect corruption early.

Output: Circuit breaker module with per-volume tracking, filesystem health check module, integrated into NodeStageVolume.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-error-resilience-mount-storm-prevention/14-CONTEXT.md
@.planning/phases/14-error-resilience-mount-storm-prevention/14-RESEARCH.md
@pkg/driver/node.go
@pkg/mount/mount.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create filesystem health check module</name>
  <files>pkg/mount/health.go, pkg/mount/health_test.go, go.mod, go.sum</files>
  <action>
Create `pkg/mount/health.go` with filesystem health check:

```go
package mount

import (
    "context"
    "fmt"
    "os/exec"
    "time"

    "k8s.io/klog/v2"
)

const (
    // HealthCheckTimeout is the maximum time to wait for filesystem health check
    HealthCheckTimeout = 60 * time.Second
)

// CheckFilesystemHealth runs a read-only filesystem check before mounting.
// This detects corruption early before attempting mount operations.
// Returns nil if filesystem is healthy, error if corrupted or check fails.
//
// IMPORTANT: Only call this on UNMOUNTED devices. Running fsck on mounted
// filesystems can cause false positives or corruption.
func CheckFilesystemHealth(ctx context.Context, devicePath, fsType string) error {
    ctx, cancel := context.WithTimeout(ctx, HealthCheckTimeout)
    defer cancel()

    var cmd *exec.Cmd
    startTime := time.Now()

    switch fsType {
    case "ext4", "ext3", "ext2":
        // fsck.ext4 -n: read-only check, no modifications
        // -p: automatically repair if safe (not used with -n)
        cmd = exec.CommandContext(ctx, "fsck.ext4", "-n", devicePath)
    case "xfs":
        // xfs_repair -n: dry-run check only
        cmd = exec.CommandContext(ctx, "xfs_repair", "-n", devicePath)
    default:
        // Unknown filesystem - skip check (don't fail on unknown types)
        klog.V(2).Infof("Skipping health check for unsupported filesystem type: %s", fsType)
        return nil
    }

    output, err := cmd.CombinedOutput()
    duration := time.Since(startTime)

    if duration > 10*time.Second {
        klog.Warningf("Filesystem health check took %v (device: %s, fsType: %s)", duration, devicePath, fsType)
    }

    if ctx.Err() == context.DeadlineExceeded {
        return fmt.Errorf("filesystem health check timed out after %v for device %s. "+
            "Device may be unresponsive or severely corrupted", HealthCheckTimeout, devicePath)
    }

    if err != nil {
        return fmt.Errorf("filesystem health check failed for device %s (fsType: %s): %w. "+
            "Filesystem may be corrupted. Output: %s. "+
            "Consider running fsck manually after unmounting any existing mounts",
            devicePath, fsType, err, string(output))
    }

    klog.V(3).Infof("Filesystem health check passed for %s (fsType: %s, duration: %v)", devicePath, fsType, duration)
    return nil
}
```

Create `pkg/mount/health_test.go`:

```go
package mount

import (
    "context"
    "testing"
)

func TestCheckFilesystemHealth_UnsupportedFS(t *testing.T) {
    // Unsupported filesystem types should be skipped (return nil)
    ctx := context.Background()
    err := CheckFilesystemHealth(ctx, "/dev/null", "btrfs")
    if err != nil {
        t.Errorf("Expected nil for unsupported filesystem, got: %v", err)
    }
}

func TestCheckFilesystemHealth_EmptyFS(t *testing.T) {
    // Empty fsType should be skipped
    ctx := context.Background()
    err := CheckFilesystemHealth(ctx, "/dev/null", "")
    if err != nil {
        t.Errorf("Expected nil for empty filesystem type, got: %v", err)
    }
}

func TestCheckFilesystemHealth_ContextCancelled(t *testing.T) {
    ctx, cancel := context.WithCancel(context.Background())
    cancel() // Cancel immediately

    // Should respect context cancellation
    // Note: This test may pass or fail depending on timing
    // The important thing is it doesn't hang
    _ = CheckFilesystemHealth(ctx, "/dev/null", "ext4")
}

// Note: Testing actual filesystem checks requires root and real devices.
// These tests verify the function handles edge cases gracefully.
// Integration tests with real devices should be done in E2E tests.
```
  </action>
  <verify>
Run `go build ./pkg/mount/...` to verify compilation.
Run `go test ./pkg/mount/... -v -run Health` to verify tests pass.
  </verify>
  <done>
CheckFilesystemHealth function created with ext4/xfs support, 60s timeout, clear error messages. Unit tests cover edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create circuit breaker module</name>
  <files>pkg/circuitbreaker/breaker.go, pkg/circuitbreaker/breaker_test.go, go.mod, go.sum</files>
  <action>
First, add the sony/gobreaker dependency:
```bash
go get github.com/sony/gobreaker@latest
```

Create directory: `mkdir -p pkg/circuitbreaker`

Create `pkg/circuitbreaker/breaker.go`:

```go
package circuitbreaker

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/sony/gobreaker"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "k8s.io/klog/v2"
)

const (
    // DefaultConsecutiveFailures is the number of failures before circuit opens
    DefaultConsecutiveFailures = 3

    // DefaultTimeout is how long circuit stays open before allowing a retry
    DefaultTimeout = 5 * time.Minute

    // DefaultInterval is the cyclic period of closed state to clear failure counts
    DefaultInterval = 1 * time.Minute

    // ResetAnnotation is the PV annotation to reset circuit breaker
    ResetAnnotation = "rds.csi.srvlab.io/reset-circuit-breaker"
)

// VolumeCircuitBreaker manages per-volume circuit breakers to prevent retry storms
type VolumeCircuitBreaker struct {
    breakers map[string]*gobreaker.CircuitBreaker
    mu       sync.RWMutex
}

// NewVolumeCircuitBreaker creates a new per-volume circuit breaker manager
func NewVolumeCircuitBreaker() *VolumeCircuitBreaker {
    return &VolumeCircuitBreaker{
        breakers: make(map[string]*gobreaker.CircuitBreaker),
    }
}

// getBreaker returns or creates a circuit breaker for the given volume
func (vcb *VolumeCircuitBreaker) getBreaker(volumeID string) *gobreaker.CircuitBreaker {
    vcb.mu.RLock()
    cb, exists := vcb.breakers[volumeID]
    vcb.mu.RUnlock()

    if exists {
        return cb
    }

    vcb.mu.Lock()
    defer vcb.mu.Unlock()

    // Double-check after acquiring write lock
    if cb, exists := vcb.breakers[volumeID]; exists {
        return cb
    }

    settings := gobreaker.Settings{
        Name:        volumeID,
        MaxRequests: 1, // Only 1 request allowed in half-open state
        Interval:    DefaultInterval,
        Timeout:     DefaultTimeout,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            return counts.ConsecutiveFailures >= DefaultConsecutiveFailures
        },
        OnStateChange: func(name string, from, to gobreaker.State) {
            klog.Infof("Circuit breaker for volume %s: %s -> %s", name, from, to)
        },
    }

    cb = gobreaker.NewCircuitBreaker(settings)
    vcb.breakers[volumeID] = cb
    klog.V(3).Infof("Created circuit breaker for volume %s", volumeID)
    return cb
}

// Execute runs the given function with circuit breaker protection.
// Returns gRPC Unavailable error if circuit is open.
func (vcb *VolumeCircuitBreaker) Execute(ctx context.Context, volumeID string, fn func() error) error {
    cb := vcb.getBreaker(volumeID)

    _, err := cb.Execute(func() (interface{}, error) {
        return nil, fn()
    })

    if err == gobreaker.ErrOpenState {
        return status.Errorf(codes.Unavailable,
            "Volume %s circuit breaker is OPEN due to %d consecutive failures. "+
                "Filesystem may be corrupted. To retry: add annotation '%s=true' to the PV "+
                "and delete the pod. The circuit will reset on next mount attempt.",
            volumeID, DefaultConsecutiveFailures, ResetAnnotation)
    }

    if err == gobreaker.ErrTooManyRequests {
        return status.Errorf(codes.Unavailable,
            "Volume %s circuit breaker is HALF-OPEN and already has a request in progress. "+
                "Wait for the current request to complete.",
            volumeID)
    }

    return err
}

// CheckReset checks if the circuit breaker should be reset based on PV annotations.
// If the reset annotation is present and true, removes the breaker to allow fresh start.
func (vcb *VolumeCircuitBreaker) CheckReset(volumeID string, annotations map[string]string) bool {
    if annotations == nil {
        return false
    }

    if annotations[ResetAnnotation] == "true" {
        vcb.mu.Lock()
        defer vcb.mu.Unlock()

        if _, exists := vcb.breakers[volumeID]; exists {
            delete(vcb.breakers, volumeID)
            klog.Infof("Circuit breaker reset for volume %s via annotation", volumeID)
            return true
        }
    }
    return false
}

// State returns the current state of the circuit breaker for a volume.
// Returns "closed" if no breaker exists (default safe state).
func (vcb *VolumeCircuitBreaker) State(volumeID string) string {
    vcb.mu.RLock()
    cb, exists := vcb.breakers[volumeID]
    vcb.mu.RUnlock()

    if !exists {
        return "closed"
    }

    return cb.State().String()
}
```

Create `pkg/circuitbreaker/breaker_test.go`:

```go
package circuitbreaker

import (
    "context"
    "errors"
    "strings"
    "testing"

    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

func TestVolumeCircuitBreaker_Success(t *testing.T) {
    vcb := NewVolumeCircuitBreaker()
    ctx := context.Background()

    err := vcb.Execute(ctx, "vol-1", func() error {
        return nil
    })

    if err != nil {
        t.Errorf("Expected nil error for success, got: %v", err)
    }
}

func TestVolumeCircuitBreaker_OpensAfterFailures(t *testing.T) {
    vcb := NewVolumeCircuitBreaker()
    ctx := context.Background()
    testErr := errors.New("test failure")

    // Fail 3 times to open circuit
    for i := 0; i < DefaultConsecutiveFailures; i++ {
        err := vcb.Execute(ctx, "vol-fail", func() error {
            return testErr
        })
        if err != testErr {
            t.Errorf("Iteration %d: expected test error, got: %v", i, err)
        }
    }

    // Next call should get circuit open error
    err := vcb.Execute(ctx, "vol-fail", func() error {
        return nil
    })

    if err == nil {
        t.Error("Expected error when circuit is open")
    }

    st, ok := status.FromError(err)
    if !ok {
        t.Fatalf("Expected gRPC status error, got: %v", err)
    }

    if st.Code() != codes.Unavailable {
        t.Errorf("Expected Unavailable code, got: %v", st.Code())
    }

    if !strings.Contains(st.Message(), "OPEN") {
        t.Errorf("Error message should mention OPEN state: %s", st.Message())
    }
}

func TestVolumeCircuitBreaker_Reset(t *testing.T) {
    vcb := NewVolumeCircuitBreaker()
    ctx := context.Background()
    testErr := errors.New("test failure")

    // Open the circuit
    for i := 0; i < DefaultConsecutiveFailures; i++ {
        _ = vcb.Execute(ctx, "vol-reset", func() error {
            return testErr
        })
    }

    // Verify circuit is open
    if vcb.State("vol-reset") != "open" {
        t.Errorf("Expected open state, got: %s", vcb.State("vol-reset"))
    }

    // Reset via annotation
    annotations := map[string]string{ResetAnnotation: "true"}
    if !vcb.CheckReset("vol-reset", annotations) {
        t.Error("Expected reset to return true")
    }

    // Verify circuit is gone (defaults to closed)
    if vcb.State("vol-reset") != "closed" {
        t.Errorf("Expected closed state after reset, got: %s", vcb.State("vol-reset"))
    }
}

func TestVolumeCircuitBreaker_IsolatedVolumes(t *testing.T) {
    vcb := NewVolumeCircuitBreaker()
    ctx := context.Background()
    testErr := errors.New("test failure")

    // Fail vol-a
    for i := 0; i < DefaultConsecutiveFailures; i++ {
        _ = vcb.Execute(ctx, "vol-a", func() error {
            return testErr
        })
    }

    // vol-b should still work
    err := vcb.Execute(ctx, "vol-b", func() error {
        return nil
    })

    if err != nil {
        t.Errorf("vol-b should not be affected by vol-a failures: %v", err)
    }
}
```
  </action>
  <verify>
Run `go build ./pkg/circuitbreaker/...` to verify compilation.
Run `go test ./pkg/circuitbreaker/... -v` to verify all tests pass.
  </verify>
  <done>
VolumeCircuitBreaker module created with per-volume isolation, 3-failure threshold, annotation-based reset, gRPC status errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate circuit breaker and health check into NodeStageVolume</name>
  <files>pkg/driver/node.go</files>
  <action>
Update `pkg/driver/node.go` to use circuit breaker and health check:

1. Add import:
   ```go
   import (
       "git.srvlab.io/whiskey/rds-csi-driver/pkg/circuitbreaker"
       // ... existing imports
   )
   ```

2. Add field to NodeServer struct:
   ```go
   type NodeServer struct {
       // ... existing fields ...
       circuitBreaker *circuitbreaker.VolumeCircuitBreaker
   }
   ```

3. Initialize in NewNodeServer:
   ```go
   func NewNodeServer(driver *Driver, nodeID string, k8sClient kubernetes.Interface) *NodeServer {
       // ... existing code ...

       return &NodeServer{
           // ... existing fields ...
           circuitBreaker: circuitbreaker.NewVolumeCircuitBreaker(),
       }
   }
   ```

4. In NodeStageVolume, after NVMe connect succeeds but BEFORE Format/Mount for filesystem volumes, add:
   ```go
   // For filesystem volumes, run health check and mount with circuit breaker protection
   if !isBlockVolume {
       // Wrap format and mount in circuit breaker
       err = ns.circuitBreaker.Execute(ctx, volumeID, func() error {
           // Step 2a: Check filesystem health before mount (only for existing filesystems)
           formatted, formatErr := ns.mounter.IsFormatted(devicePath)
           if formatErr != nil {
               klog.Warningf("Could not check if device is formatted, skipping health check: %v", formatErr)
           } else if formatted {
               klog.V(2).Infof("Running filesystem health check for %s", devicePath)
               if healthErr := mount.CheckFilesystemHealth(ctx, devicePath, fsType); healthErr != nil {
                   return fmt.Errorf("filesystem health check failed: %w", healthErr)
               }
           }

           // Step 2b: Format filesystem if needed
           if formatErr := ns.mounter.Format(devicePath, fsType); formatErr != nil {
               return fmt.Errorf("failed to format device: %w", formatErr)
           }

           // Step 3: Mount to staging path
           mountOptions := []string{}
           if mnt := req.GetVolumeCapability().GetMount(); mnt != nil {
               mountOptions = mnt.MountFlags
           }

           if mountErr := ns.mounter.Mount(devicePath, stagingPath, fsType, mountOptions); mountErr != nil {
               return fmt.Errorf("failed to mount device: %w", mountErr)
           }

           return nil
       })

       if err != nil {
           // Post failure event if this is a circuit breaker or mount error
           if ns.eventPoster != nil && pvcNamespace != "" && pvcName != "" {
               _ = ns.eventPoster.PostMountFailure(ctx, pvcNamespace, pvcName, volumeID, ns.nodeID,
                   fmt.Sprintf("stage volume failed: %v", err))
           }
           // Cleanup NVMe connection on failure
           _ = ns.nvmeConn.Disconnect(nqn)
           secLogger.LogVolumeStage(volumeID, ns.nodeID, nqn, nvmeAddress, security.OutcomeFailure, err, time.Since(startTime))
           return nil, status.Errorf(codes.Internal, "failed to stage filesystem volume: %v", err)
       }

       // Existing success logging and return
   }
   ```

5. Remove the existing separate Format and Mount calls for filesystem volumes (lines ~283-311) since they're now inside the circuit breaker.

Note: Block volumes do NOT need health checks or circuit breaker since they don't have filesystems.
  </action>
  <verify>
Run `go build ./...` to verify compilation.
Run `go test ./pkg/driver/... -v` to verify existing tests pass.
  </verify>
  <done>
NodeStageVolume uses circuit breaker for filesystem mount operations. Health check runs before mount on existing filesystems. Clear error messages for failures.
  </done>
</task>

</tasks>

<verification>
1. Dependencies added: `grep "gobreaker" go.mod`
2. Build succeeds: `go build ./...`
3. Health check module tests pass: `go test ./pkg/mount/... -v -run Health`
4. Circuit breaker tests pass: `go test ./pkg/circuitbreaker/... -v`
5. Driver tests pass: `go test ./pkg/driver/... -v`
</verification>

<success_criteria>
- CheckFilesystemHealth function detects corrupted ext4/xfs filesystems
- VolumeCircuitBreaker opens after 3 consecutive failures
- Circuit breaker returns gRPC Unavailable when open
- Circuit breaker can be reset via PV annotation
- NodeStageVolume integrates health check and circuit breaker for filesystem volumes
- Block volumes bypass health check (no filesystem)
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-error-resilience-mount-storm-prevention/14-03-SUMMARY.md`
</output>
