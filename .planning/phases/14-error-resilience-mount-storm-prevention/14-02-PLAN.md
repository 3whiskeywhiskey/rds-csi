---
phase: 14-error-resilience-mount-storm-prevention
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/mount/procmounts.go
  - pkg/mount/procmounts_test.go
  - go.mod
  - go.sum
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Procmounts parsing times out after 10 seconds"
    - "Duplicate mount detection triggers when device has 100+ mount entries"
    - "Mount storm detection returns error with actionable message"
    - "Timeout returns error with clear timeout message"
  artifacts:
    - path: "pkg/mount/procmounts.go"
      provides: "Safe procmounts parsing with timeout and duplicate detection"
      exports: ["GetMountsWithTimeout", "DetectDuplicateMounts"]
    - path: "pkg/mount/procmounts_test.go"
      provides: "Tests for timeout and duplicate detection"
      min_lines: 80
  key_links:
    - from: "pkg/mount/procmounts.go"
      to: "context"
      via: "Context timeout for procmounts parsing"
      pattern: "context.WithTimeout"
    - from: "pkg/mount/procmounts.go"
      to: "moby/sys/mountinfo"
      via: "Production-ready mount parsing library"
      pattern: "mountinfo.GetMounts"
---

<objective>
Implement safe procmounts parsing with timeout protection and duplicate mount detection.

Purpose: Prevent mount storms from hanging the driver. During Phase 13, a corrupted filesystem caused thousands of duplicate mounts that overwhelmed /proc/mounts parsing. This plan adds timeout protection (10s max) and duplicate detection (threshold: 100 mounts per device) to fail fast and prevent cascading failures.

Output: Updated procmounts module with GetMountsWithTimeout and DetectDuplicateMounts functions.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-error-resilience-mount-storm-prevention/14-CONTEXT.md
@.planning/phases/14-error-resilience-mount-storm-prevention/14-RESEARCH.md
@pkg/mount/procmounts.go
@pkg/mount/procmounts_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add moby/sys/mountinfo dependency</name>
  <files>go.mod, go.sum</files>
  <action>
Add the moby/sys/mountinfo library for production-ready mount parsing:

```bash
go get github.com/moby/sys/mountinfo@latest
```

This library is used by Docker and containerd for mount parsing. It handles edge cases (spaces in paths, special characters, format variations) that the current manual parser may miss.

Verify the import works by checking go.mod shows the dependency.
  </action>
  <verify>
Run `grep "moby/sys/mountinfo" go.mod` - should show the dependency.
Run `go mod tidy` to ensure clean dependency graph.
  </verify>
  <done>
moby/sys/mountinfo dependency added to go.mod.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GetMountsWithTimeout and DetectDuplicateMounts</name>
  <files>pkg/mount/procmounts.go</files>
  <action>
Update `pkg/mount/procmounts.go` to add timeout-protected parsing and duplicate detection.

1. Add imports:
   ```go
   import (
       "context"
       "time"
       "github.com/moby/sys/mountinfo"
   )
   ```

2. Add constants:
   ```go
   const (
       // ProcmountsTimeout is the maximum time to wait for /proc/mounts parsing
       ProcmountsTimeout = 10 * time.Second

       // MaxDuplicateMountsPerDevice is the threshold for mount storm detection
       MaxDuplicateMountsPerDevice = 100
   )
   ```

3. Implement GetMountsWithTimeout:
   ```go
   // GetMountsWithTimeout parses mount information with a timeout to prevent hangs
   // on corrupted filesystems. Returns error if parsing takes longer than ProcmountsTimeout.
   func GetMountsWithTimeout(ctx context.Context) ([]*mountinfo.Info, error) {
       ctx, cancel := context.WithTimeout(ctx, ProcmountsTimeout)
       defer cancel()

       type result struct {
           mounts []*mountinfo.Info
           err    error
       }
       resultCh := make(chan result, 1)

       go func() {
           mounts, err := mountinfo.GetMounts(nil)
           resultCh <- result{mounts: mounts, err: err}
       }()

       select {
       case res := <-resultCh:
           return res.mounts, res.err
       case <-ctx.Done():
           return nil, fmt.Errorf("procmounts parsing timed out after %v: %w. "+
               "This may indicate filesystem corruption or an excessive number of mount entries. "+
               "Check /proc/mounts manually and consider unmounting stale entries.",
               ProcmountsTimeout, ctx.Err())
       }
   }
   ```

4. Implement DetectDuplicateMounts:
   ```go
   // DetectDuplicateMounts checks if a device has an excessive number of mount entries,
   // indicating a mount storm (often caused by filesystem corruption).
   // Returns (count, error) where error is non-nil if threshold exceeded.
   func DetectDuplicateMounts(mounts []*mountinfo.Info, devicePath string) (int, error) {
       count := 0
       for _, mount := range mounts {
           if mount.Source == devicePath {
               count++
           }
       }

       if count >= MaxDuplicateMountsPerDevice {
           return count, fmt.Errorf(
               "mount storm detected: device %s has %d mount entries (threshold: %d). "+
                   "This indicates filesystem corruption or a runaway mount loop. "+
                   "Manual cleanup required: identify and unmount duplicate entries with 'findmnt' and 'umount'.",
               devicePath, count, MaxDuplicateMountsPerDevice)
       }

       return count, nil
   }
   ```

5. Keep existing GetMounts() function for backward compatibility, but add deprecation comment:
   ```go
   // GetMounts parses /proc/self/mountinfo and returns all mount points.
   // Deprecated: Use GetMountsWithTimeout for production code to prevent hangs.
   func GetMounts() ([]MountInfo, error) {
   ```

6. Add helper to convert moby mountinfo to our MountInfo type:
   ```go
   // ConvertMobyMount converts moby/sys/mountinfo.Info to our MountInfo type
   func ConvertMobyMount(m *mountinfo.Info) MountInfo {
       return MountInfo{
           Source:  m.Source,
           Target:  m.Mountpoint,
           FSType:  m.FSType,
           Options: strings.Join(m.Options, ","),
       }
   }
   ```
  </action>
  <verify>
Run `go build ./pkg/mount/...` to verify compilation.
Run `grep -n "ProcmountsTimeout\|MaxDuplicateMountsPerDevice\|GetMountsWithTimeout\|DetectDuplicateMounts" pkg/mount/procmounts.go` to verify functions exist.
  </verify>
  <done>
GetMountsWithTimeout implemented with 10s timeout. DetectDuplicateMounts implemented with 100 mount threshold. Clear error messages for both failure modes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for timeout and duplicate detection</name>
  <files>pkg/mount/procmounts_test.go</files>
  <action>
Add comprehensive tests to `pkg/mount/procmounts_test.go`:

1. Test GetMountsWithTimeout success case:
   ```go
   func TestGetMountsWithTimeout_Success(t *testing.T) {
       ctx := context.Background()
       mounts, err := GetMountsWithTimeout(ctx)
       if err != nil {
           t.Fatalf("GetMountsWithTimeout failed: %v", err)
       }
       // Should return at least one mount (/ at minimum)
       if len(mounts) == 0 {
           t.Error("Expected at least one mount, got zero")
       }
   }
   ```

2. Test GetMountsWithTimeout respects context cancellation:
   ```go
   func TestGetMountsWithTimeout_ContextCancelled(t *testing.T) {
       ctx, cancel := context.WithCancel(context.Background())
       cancel() // Cancel immediately
       _, err := GetMountsWithTimeout(ctx)
       if err == nil {
           t.Error("Expected error for cancelled context")
       }
   }
   ```

3. Test DetectDuplicateMounts under threshold:
   ```go
   func TestDetectDuplicateMounts_UnderThreshold(t *testing.T) {
       mounts := make([]*mountinfo.Info, 10)
       for i := range mounts {
           mounts[i] = &mountinfo.Info{Source: "/dev/test"}
       }
       count, err := DetectDuplicateMounts(mounts, "/dev/test")
       if err != nil {
           t.Errorf("Expected no error for %d mounts, got: %v", count, err)
       }
       if count != 10 {
           t.Errorf("Expected count 10, got %d", count)
       }
   }
   ```

4. Test DetectDuplicateMounts at threshold:
   ```go
   func TestDetectDuplicateMounts_AtThreshold(t *testing.T) {
       mounts := make([]*mountinfo.Info, MaxDuplicateMountsPerDevice)
       for i := range mounts {
           mounts[i] = &mountinfo.Info{Source: "/dev/storm"}
       }
       count, err := DetectDuplicateMounts(mounts, "/dev/storm")
       if err == nil {
           t.Error("Expected error at threshold")
       }
       if count != MaxDuplicateMountsPerDevice {
           t.Errorf("Expected count %d, got %d", MaxDuplicateMountsPerDevice, count)
       }
       if !strings.Contains(err.Error(), "mount storm detected") {
           t.Errorf("Error message should mention mount storm: %v", err)
       }
   }
   ```

5. Test DetectDuplicateMounts with mixed devices:
   ```go
   func TestDetectDuplicateMounts_MixedDevices(t *testing.T) {
       mounts := make([]*mountinfo.Info, 150)
       for i := range mounts {
           if i < 50 {
               mounts[i] = &mountinfo.Info{Source: "/dev/good"}
           } else {
               mounts[i] = &mountinfo.Info{Source: "/dev/bad"}
           }
       }
       // /dev/good should be fine (50 mounts)
       count, err := DetectDuplicateMounts(mounts, "/dev/good")
       if err != nil {
           t.Errorf("Expected no error for /dev/good, got: %v", err)
       }
       if count != 50 {
           t.Errorf("Expected count 50 for /dev/good, got %d", count)
       }
       // /dev/bad should trigger storm (100 mounts)
       count, err = DetectDuplicateMounts(mounts, "/dev/bad")
       if err == nil {
           t.Error("Expected error for /dev/bad mount storm")
       }
       if count != 100 {
           t.Errorf("Expected count 100 for /dev/bad, got %d", count)
       }
   }
   ```

6. Test ConvertMobyMount:
   ```go
   func TestConvertMobyMount(t *testing.T) {
       mobyMount := &mountinfo.Info{
           Source:     "/dev/nvme0n1",
           Mountpoint: "/mnt/test",
           FSType:     "ext4",
           Options:    []string{"rw", "relatime"},
       }
       converted := ConvertMobyMount(mobyMount)
       if converted.Source != "/dev/nvme0n1" {
           t.Errorf("Source mismatch: %s", converted.Source)
       }
       if converted.Target != "/mnt/test" {
           t.Errorf("Target mismatch: %s", converted.Target)
       }
       if converted.FSType != "ext4" {
           t.Errorf("FSType mismatch: %s", converted.FSType)
       }
       if converted.Options != "rw,relatime" {
           t.Errorf("Options mismatch: %s", converted.Options)
       }
   }
   ```
  </action>
  <verify>
Run `go test ./pkg/mount/... -v -run "Timeout\|Duplicate\|Convert"` and confirm all new tests pass.
Run `go test ./pkg/mount/... -v` to confirm existing tests still pass.
  </verify>
  <done>
Comprehensive tests for GetMountsWithTimeout and DetectDuplicateMounts. Tests cover success, timeout, threshold, and mixed device scenarios.
  </done>
</task>

</tasks>

<verification>
1. Dependency added: `grep "moby/sys/mountinfo" go.mod`
2. Build succeeds: `go build ./...`
3. All tests pass: `go test ./pkg/mount/... -v`
4. GetMountsWithTimeout works: Successful call returns mounts
5. DetectDuplicateMounts triggers at threshold: Test confirms 100+ mounts triggers error
</verification>

<success_criteria>
- moby/sys/mountinfo dependency added to go.mod
- GetMountsWithTimeout implemented with 10s timeout
- DetectDuplicateMounts implemented with 100 mount threshold
- Clear, actionable error messages for both failure modes
- Comprehensive unit tests pass
- Existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-error-resilience-mount-storm-prevention/14-02-SUMMARY.md`
</output>
