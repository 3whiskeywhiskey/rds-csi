# Phase 28.1: Fix rds_csi_nvme_connections_active Metric Accuracy - Research

**Researched:** 2026-02-06
**Domain:** Prometheus metrics, Go instrumentation, state synchronization
**Confidence:** HIGH

## Summary

The `rds_csi_nvme_connections_active` gauge metric currently uses a counter-derived approach (increment on connect, decrement on disconnect) which breaks on controller restarts since counters reset to 0 while actual NVMe/TCP connections persist. The attachment manager already maintains authoritative state of all active connections via its in-memory `attachments` map and provides `ListAttachments()` to query this state.

The solution is to replace the counter-derived gauge with a Prometheus `GaugeFunc` that queries the attachment manager's current state on each scrape. This pattern is already used successfully for `rds_csi_rds_connection_state` and aligns with Prometheus best practices for gauges representing current state.

**Primary recommendation:** Use `prometheus.NewGaugeFunc()` with a callback that queries `len(attachmentManager.ListAttachments())` to derive the gauge value directly from authoritative state instead of maintaining a separate counter.

## Standard Stack

The established libraries/tools for Prometheus metrics in Go:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| prometheus/client_golang | v1.x | Prometheus client library for Go | Official Prometheus Go client, widely adopted |
| GaugeFunc | Built-in | Callback-based gauge metric | Standard pattern for querying dynamic state |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Gauge.Set() | Built-in | Manual gauge updates | When you control update timing explicitly |
| GaugeVec.WithLabelValues() | Built-in | Multi-dimensional gauges | When tracking state per label (e.g., per-node) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| GaugeFunc (callback) | Manual Set() calls | Set() requires explicit updates at every state change point; GaugeFunc automatically queries on scrape |
| Derive from counters | Query source of truth | Counter derivation breaks on restarts; querying state is accurate |

**Installation:**
Already installed in project:
```bash
# Already in go.mod
github.com/prometheus/client_golang v1.x
```

## Architecture Patterns

### Current Implementation (Broken)

**File:** `pkg/observability/prometheus.go`

```go
// Lines 28, 106-110
nvmeConnectionsActive prometheus.Gauge

nvmeConnectionsActive: prometheus.NewGauge(prometheus.GaugeOpts{
    Namespace: namespace,
    Name:      "nvme_connections_active",
    Help:      "Number of currently active NVMe/TCP connections",
}),
```

**Recording Methods:**

```go
// Lines 316-328 - RecordNVMeConnect
func (m *Metrics) RecordNVMeConnect(err error, duration time.Duration) {
    status := "success"
    if err != nil {
        status = "failure"
    }
    m.nvmeConnectsTotal.WithLabelValues(status).Inc()
    if err == nil {
        m.nvmeConnectDuration.Observe(duration.Seconds())
        m.nvmeConnectionsActive.Inc()  // ← PROBLEM: Inc/Dec breaks on restart
    }
}

// Lines 330-334 - RecordNVMeDisconnect
func (m *Metrics) RecordNVMeDisconnect() {
    m.nvmeConnectionsActive.Dec()  // ← PROBLEM: Dec without knowing actual state
}
```

**Where Called:**
- `pkg/nvme/nvme.go:540` - After NVMe connect succeeds
- `pkg/nvme/nvme.go:715` - After NVMe disconnect succeeds

**Root Cause:**
1. Gauge value derived from Inc/Dec operations, not from actual state
2. Controller restart resets gauge to 0 (new Metrics instance created)
3. Existing NVMe connections persist across restarts (managed by attachment manager)
4. Result: Metric reports 0 when actual count is 16 (production issue)

### Attachment Manager State (Source of Truth)

**File:** `pkg/attachment/manager.go`

```go
// Lines 20-38
type AttachmentManager struct {
    mu sync.RWMutex
    attachments map[string]*AttachmentState  // ← SOURCE OF TRUTH
    detachTimestamps map[string]time.Time
    volumeLocks *VolumeLockManager
    k8sClient kubernetes.Interface
    metrics *observability.Metrics
}

// Lines 206-219 - Query current state
func (am *AttachmentManager) ListAttachments() map[string]*AttachmentState {
    am.mu.RLock()
    defer am.mu.RUnlock()

    // Returns copy of all active attachments
    copy := make(map[string]*AttachmentState, len(am.attachments))
    for volumeID, state := range am.attachments {
        copy[volumeID] = state
    }
    return copy
}
```

**State Rebuild on Restart:**
- `pkg/attachment/rebuild.go:18-22` - `RebuildState()` called during controller startup
- Rebuilds `attachments` map from VolumeAttachment objects in Kubernetes API
- Attachment state persists across controller restarts (VolumeAttachments are cluster resources)

**Integration with Driver:**
- `pkg/driver/driver.go:206-211` - Attachment manager created during driver initialization
- Metrics wired via `SetMetrics()` call on line 209

### Recommended Pattern: GaugeFunc

**Source:** [Prometheus client_golang examples](https://github.com/prometheus/client_golang/blob/main/prometheus/examples_test.go)

```go
// Example from prometheus/client_golang
prometheus.NewGaugeFunc(
    prometheus.GaugeOpts{
        Subsystem: "runtime",
        Name: "goroutines_count",
        Help: "Number of goroutines that currently exist.",
    },
    func() float64 { return float64(runtime.NumGoroutine()) },
)
```

**Key Characteristics:**
- Callback function invoked on each Prometheus scrape
- Queries live state instead of maintaining separate counter
- Thread-safe: Prometheus handles concurrent collection
- Survives restarts: Derives value from persistent state

**Existing Usage in Codebase:**

```go
// pkg/observability/prometheus.go:238-246, 425-433
rdsConnectionState: prometheus.NewGaugeVec(
    prometheus.GaugeOpts{
        Namespace: namespace,
        Subsystem: "rds",
        Name: "connection_state",
        Help: "RDS SSH connection state (1=connected, 0=disconnected)",
    },
    []string{"address"},
),

func (m *Metrics) RecordConnectionState(address string, connected bool) {
    value := 0.0
    if connected {
        value = 1.0
    }
    m.rdsConnectionState.WithLabelValues(address).Set(value)
}
```

Note: `rdsConnectionState` uses `Set()` not `GaugeFunc`, but both query external state.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Tracking active connections | Custom counter with Inc/Dec | GaugeFunc querying AttachmentManager | Counters reset on restart, state manager is source of truth |
| Periodic metric updates | Manual goroutine updating gauge | GaugeFunc with callback | Prometheus handles collection timing |
| Thread-safe metric access | Custom mutex around gauge | GaugeFunc (built-in concurrency safety) | Prometheus client handles synchronization |
| State synchronization | Explicit metric updates at 10+ callsites | Single callback querying one source | Eliminates drift between state and metrics |

**Key insight:** When a gauge represents "current state" (not a cumulative value), derive it from the source of truth on-demand rather than tracking updates.

## Common Pitfalls

### Pitfall 1: Deriving Gauges from Counters
**What goes wrong:** Counter-derived gauges (attach_total - detach_total) break on restarts because counters reset while state persists.

**Why it happens:** Confusion between counters (monotonically increasing) and gauges (point-in-time values). Natural to think "count the events" instead of "query the state."

**How to avoid:**
- Use counters for "total events over time" (nvme_connects_total)
- Use gauges for "current value" (nvme_connections_active)
- Derive gauge values from source of truth, not from counters

**Warning signs:**
- Gauge value = counter1 - counter2
- Metric accuracy depends on restart frequency
- Production metric shows 0 when you know state exists

### Pitfall 2: Missing AttachmentManager Reference
**What goes wrong:** GaugeFunc callback needs access to AttachmentManager, but Metrics is created before AttachmentManager exists.

**Why it happens:** Chicken-and-egg problem in initialization order:
1. Metrics created in main.go or driver init
2. AttachmentManager created later in driver init
3. GaugeFunc needs AttachmentManager reference at Metrics creation time

**How to avoid:**
- Pass AttachmentManager to Metrics after both are created
- Store weak reference in Metrics struct
- Use lazy initialization: GaugeFunc checks if manager is set, returns 0 if nil

**Warning signs:**
- Nil pointer panic in GaugeFunc callback
- Metrics shows 0 even after attachments exist
- Integration tests pass but production fails

### Pitfall 3: Forgetting Controller vs Node Plugin Split
**What goes wrong:** AttachmentManager only exists in controller, not node plugin. GaugeFunc would panic in node plugin.

**Why it happens:** Metrics package is used by both controller and node plugin, but attachment manager only exists in controller.

**How to avoid:**
- GaugeFunc callback must check if AttachmentManager is nil
- Only register GaugeFunc when running as controller
- Node plugin should not expose nvme_connections_active (only controller tracks global state)

**Warning signs:**
- Node plugin crashes on startup
- Metric disappears when controller disabled
- Tests fail with different driver configs

### Pitfall 4: Not Handling Concurrent Access
**What goes wrong:** GaugeFunc callback called concurrently during Prometheus scrapes, needs thread-safe access to AttachmentManager.

**Why it happens:** Prometheus may collect metrics from multiple endpoints simultaneously. AttachmentManager.ListAttachments() already handles this with RWMutex.

**How to avoid:**
- Use AttachmentManager.ListAttachments() (already thread-safe)
- Don't directly access am.attachments map
- Don't hold locks during metric collection

**Warning signs:**
- Race condition warnings during tests
- Panic: concurrent map read and write
- Inconsistent metric values between scrapes

## Code Examples

Verified patterns from official sources and existing codebase:

### GaugeFunc Pattern (Recommended Solution)

```go
// Source: https://github.com/prometheus/client_golang/blob/main/prometheus/examples_test.go
// Adapted for AttachmentManager

// In pkg/observability/prometheus.go

type Metrics struct {
    registry *prometheus.Registry

    // Remove: nvmeConnectionsActive prometheus.Gauge
    // Add: Reference to attachment manager for query
    attachmentManager AttachmentManagerInterface  // Interface for testing

    // ... other fields
}

// Interface for attachment manager (supports mocking in tests)
type AttachmentManagerInterface interface {
    ListAttachments() map[string]*AttachmentState
}

func NewMetrics() *Metrics {
    reg := prometheus.NewRegistry()

    m := &Metrics{
        registry: reg,
        // ... other metric initialization
    }

    // Note: nvmeConnectionsActive GaugeFunc registered later in SetAttachmentManager
    // Cannot create here because AttachmentManager doesn't exist yet

    return m
}

// SetAttachmentManager registers the GaugeFunc with access to attachment state
func (m *Metrics) SetAttachmentManager(am AttachmentManagerInterface) {
    m.attachmentManager = am

    // Create and register GaugeFunc that queries AttachmentManager
    nvmeConnectionsActive := prometheus.NewGaugeFunc(
        prometheus.GaugeOpts{
            Namespace: "rds_csi",
            Name:      "nvme_connections_active",
            Help:      "Number of currently active NVMe/TCP connections (derived from AttachmentManager state)",
        },
        func() float64 {
            if m.attachmentManager == nil {
                return 0
            }
            return float64(len(m.attachmentManager.ListAttachments()))
        },
    )

    m.registry.MustRegister(nvmeConnectionsActive)
}

// Remove RecordNVMeConnect increment:
func (m *Metrics) RecordNVMeConnect(err error, duration time.Duration) {
    status := "success"
    if err != nil {
        status = "failure"
    }
    m.nvmeConnectsTotal.WithLabelValues(status).Inc()
    if err == nil {
        m.nvmeConnectDuration.Observe(duration.Seconds())
        // REMOVE: m.nvmeConnectionsActive.Inc()
    }
}

// Remove RecordNVMeDisconnect decrement:
func (m *Metrics) RecordNVMeDisconnect() {
    // REMOVE: m.nvmeConnectionsActive.Dec()
    // Gauge now derived from AttachmentManager, no manual updates needed
}
```

### Driver Initialization Wire

```go
// Source: pkg/driver/driver.go:206-211
// Add SetAttachmentManager call after metrics and manager both exist

// Initialize attachment manager if controller is enabled
if config.EnableController && config.K8sClient != nil {
    driver.attachmentManager = attachment.NewAttachmentManager(config.K8sClient)
    if config.Metrics != nil {
        driver.attachmentManager.SetMetrics(config.Metrics)

        // NEW: Wire AttachmentManager into Metrics for nvme_connections_active gauge
        config.Metrics.SetAttachmentManager(driver.attachmentManager)
    }
    klog.Info("Attachment manager created")
}
```

### Unit Test Pattern

```go
// Source: Similar to pkg/observability/prometheus_test.go patterns
// Test GaugeFunc queries AttachmentManager state

func TestNVMeConnectionsActive_QueriesAttachmentManager(t *testing.T) {
    m := NewMetrics()

    // Create mock attachment manager with 3 attachments
    mockAM := &mockAttachmentManager{
        attachments: map[string]*AttachmentState{
            "vol1": {VolumeID: "vol1", NodeID: "node1"},
            "vol2": {VolumeID: "vol2", NodeID: "node2"},
            "vol3": {VolumeID: "vol3", NodeID: "node3"},
        },
    }

    // Wire attachment manager to metrics
    m.SetAttachmentManager(mockAM)

    // Scrape metrics
    handler := m.Handler()
    req := httptest.NewRequest("GET", "/metrics", nil)
    rec := httptest.NewRecorder()
    handler.ServeHTTP(rec, req)

    body := rec.Body.String()

    // Verify gauge reflects AttachmentManager state
    if !strings.Contains(body, "rds_csi_nvme_connections_active 3") {
        t.Errorf("expected nvme_connections_active to be 3, got:\n%s", body)
    }
}

type mockAttachmentManager struct {
    attachments map[string]*AttachmentState
}

func (m *mockAttachmentManager) ListAttachments() map[string]*AttachmentState {
    return m.attachments
}
```

### Integration Test: Controller Restart

```go
// Test metric accuracy after controller restart

func TestNVMeConnectionsActive_AfterRestart(t *testing.T) {
    // Setup: Create 3 VolumeAttachment objects in cluster
    // ... kubernetes test fixtures ...

    // Create first controller instance
    controller1 := createController(t, k8sClient)
    controller1.Start()

    // Attach 3 volumes
    controller1.AttachmentManager.TrackAttachment(ctx, "vol1", "node1")
    controller1.AttachmentManager.TrackAttachment(ctx, "vol2", "node2")
    controller1.AttachmentManager.TrackAttachment(ctx, "vol3", "node3")

    // Verify metric shows 3
    assertMetricValue(t, controller1.Metrics, "rds_csi_nvme_connections_active", 3)

    // Simulate controller restart
    controller1.Stop()

    // Create new controller instance (new Metrics instance)
    controller2 := createController(t, k8sClient)
    controller2.Start()

    // Rebuild state from VolumeAttachments
    controller2.AttachmentManager.RebuildState(ctx)

    // Verify metric STILL shows 3 (not 0)
    assertMetricValue(t, controller2.Metrics, "rds_csi_nvme_connections_active", 3)
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Counter-derived gauges (attach - detach) | GaugeFunc querying source of truth | Prometheus best practices since v1.0 | Gauges survive restarts, always accurate |
| Manual Set() calls at every state change | Callback invoked on scrape | GaugeFunc introduced early in prometheus/client_golang | Eliminates state drift, reduces callsites |
| Metrics own state | Metrics query authoritative state | Modern observability pattern | Single source of truth, metrics are view layer |

**Deprecated/outdated:**
- **Counter arithmetic for gauges**: Common anti-pattern, breaks on restarts
- **Manual gauge updates**: Error-prone, requires updates at 10+ callsites
- **Metrics as source of truth**: Observability layer should query domain state, not duplicate it

## Open Questions

1. **Should node plugin expose nvme_connections_active?**
   - What we know: AttachmentManager only exists in controller
   - What's unclear: Should node plugin expose per-node connection count?
   - Recommendation: Controller-only metric for global view. Node plugin could add separate per-node metric if needed.

2. **What about counter-derived calculation during migration?**
   - What we know: During migration, volume attached to 2 nodes temporarily
   - What's unclear: Should metric count volumes (16) or total attachments (17 during migration)?
   - Recommendation: Count volumes (len(attachments)), document that migration dual-attach doesn't inflate count

3. **Should we keep RecordNVMeConnect/Disconnect methods?**
   - What we know: Still needed for nvme_connects_total counter and duration histogram
   - What's unclear: Naming now misleading (implies they update active gauge)
   - Recommendation: Keep methods for counter/histogram, remove gauge updates, add comment explaining gauge is derived

## Sources

### Primary (HIGH confidence)
- [prometheus/client_golang examples](https://github.com/prometheus/client_golang/blob/main/prometheus/examples_test.go) - GaugeFunc pattern
- pkg/observability/prometheus.go - Current metric implementation
- pkg/attachment/manager.go - AttachmentManager state tracking
- pkg/driver/driver.go - Driver initialization and wiring

### Secondary (MEDIUM confidence)
- [Prometheus Go Client Documentation](https://pkg.go.dev/github.com/prometheus/client_golang/prometheus) - API reference
- [How does a Prometheus Gauge work?](https://www.robustperception.io/how-does-a-prometheus-gauge-work/) - Best practices

### Tertiary (LOW confidence)
- Production observation: rds_csi_nvme_connections_active reports 0 with 16 VolumeAttachments (from issue #19)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Official Prometheus Go client, well-documented
- Architecture: HIGH - Existing code shows clear pattern, AttachmentManager is source of truth
- Pitfalls: HIGH - Production issue confirms counter-derivation problem

**Research date:** 2026-02-06
**Valid until:** 90 days (stable Prometheus client API, unlikely to change)

## Sources

- [prometheus package - github.com/prometheus/client_golang/prometheus - Go Packages](https://pkg.go.dev/github.com/prometheus/client_golang/prometheus)
- [client_golang/prometheus/examples_test.go at main · prometheus/client_golang](https://github.com/prometheus/client_golang/blob/main/prometheus/examples_test.go)
- [Instrumenting a Go application for Prometheus | Prometheus](https://prometheus.io/docs/guides/go-application/)
- [How does a Prometheus Gauge work? – Robust Perception | Prometheus Monitoring Experts](https://www.robustperception.io/how-does-a-prometheus-gauge-work/)
