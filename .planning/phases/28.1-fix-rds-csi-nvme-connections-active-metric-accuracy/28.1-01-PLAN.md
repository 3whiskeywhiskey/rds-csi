---
phase: 28.1-fix-rds-csi-nvme-connections-active-metric-accuracy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/observability/prometheus.go
  - pkg/observability/prometheus_test.go
  - pkg/driver/driver.go
autonomous: true

must_haves:
  truths:
    - "rds_csi_nvme_connections_active gauge reports actual count of active NVMe/TCP connections from attachment manager state"
    - "Metric value persists correctly across controller restarts (derived from persistent AttachmentManager, not ephemeral counters)"
    - "Node plugin does not panic when nvme_connections_active is scraped (nil AttachmentManager returns 0)"
    - "Unit tests verify metric updates when attachments change"
    - "Existing NVMe counter and duration metrics continue to work (RecordNVMeConnect still records nvme_connects_total and duration)"
  artifacts:
    - path: "pkg/observability/prometheus.go"
      provides: "GaugeFunc-based nvme_connections_active metric"
      contains: "NewGaugeFunc"
    - path: "pkg/observability/prometheus_test.go"
      provides: "Tests for GaugeFunc-based active connections metric"
      contains: "SetAttachmentManager"
    - path: "pkg/driver/driver.go"
      provides: "Wire AttachmentManager into Metrics"
      contains: "SetAttachmentManager"
  key_links:
    - from: "pkg/driver/driver.go"
      to: "pkg/observability/prometheus.go"
      via: "SetAttachmentManager call after attachment manager creation"
      pattern: "SetAttachmentManager"
    - from: "pkg/observability/prometheus.go"
      to: "pkg/attachment/manager.go"
      via: "GaugeFunc callback calling ListAttachments"
      pattern: "ListAttachments"
---

<objective>
Fix the rds_csi_nvme_connections_active metric to report actual connection count instead of 0 after controller restart.

Purpose: Production observability is broken -- the metric reports 0 despite 16 active NVMe/TCP connections (GitHub Issue #19). Root cause: gauge derived from Inc/Dec counters that reset on restart, while actual connections persist in AttachmentManager state rebuilt from VolumeAttachments.

Output: Working metric that queries AttachmentManager.ListAttachments() on each Prometheus scrape via GaugeFunc callback, with updated unit tests.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28.1-fix-rds-csi-nvme-connections-active-metric-accuracy/28.1-RESEARCH.md
@pkg/observability/prometheus.go
@pkg/observability/prometheus_test.go
@pkg/driver/driver.go
@pkg/attachment/manager.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace counter-derived gauge with GaugeFunc querying AttachmentManager</name>
  <files>pkg/observability/prometheus.go, pkg/driver/driver.go</files>
  <action>
In `pkg/observability/prometheus.go`:

1. Add an interface type for the attachment counter callback (avoids importing attachment package, supports testing):

```go
// AttachmentCounter provides the count of active attachments.
// This interface decouples metrics from the attachment package.
type AttachmentCounter interface {
    ListAttachments() map[string]*any // Only len() is used
}
```

IMPORTANT: Do NOT use `*any` -- instead define a minimal interface that only needs `len()` of its return value. The simplest approach: just store a `func() int` callback instead of an interface. This avoids import cycles entirely:

```go
// In Metrics struct, add field:
attachmentCountFunc func() int
```

2. Remove the `nvmeConnectionsActive prometheus.Gauge` field from the Metrics struct (line 28). The GaugeFunc will be registered separately, not stored as a struct field.

3. Remove `nvmeConnectionsActive` from the struct literal initialization in `NewMetrics()` (lines 106-110).

4. Remove `m.nvmeConnectionsActive` from the `reg.MustRegister(...)` call (line 273).

5. Add a `SetAttachmentManager` method that registers the GaugeFunc:

```go
// SetAttachmentManager registers a GaugeFunc that derives nvme_connections_active
// from the attachment manager's current state. This must be called after the
// AttachmentManager is created. If not called (e.g., node plugin), the metric
// is not registered and won't appear in scrapes.
func (m *Metrics) SetAttachmentManager(countFunc func() int) {
    m.attachmentCountFunc = countFunc

    nvmeConnectionsActive := prometheus.NewGaugeFunc(
        prometheus.GaugeOpts{
            Namespace: namespace,
            Name:      "nvme_connections_active",
            Help:      "Number of active volumes with NVMe/TCP connections (counts volumes, not per-node attachments during migration)",
        },
        func() float64 {
            if m.attachmentCountFunc == nil {
                return 0
            }
            return float64(m.attachmentCountFunc())
        },
    )

    m.registry.MustRegister(nvmeConnectionsActive)
}
```

6. Update `RecordNVMeConnect` (lines 316-328): Remove the `m.nvmeConnectionsActive.Inc()` line. Keep the rest (counter and histogram are still needed). Add a comment explaining the gauge is now derived from AttachmentManager:

```go
func (m *Metrics) RecordNVMeConnect(err error, duration time.Duration) {
    status := "success"
    if err != nil {
        status = "failure"
    }
    m.nvmeConnectsTotal.WithLabelValues(status).Inc()
    if err == nil {
        m.nvmeConnectDuration.Observe(duration.Seconds())
        // nvme_connections_active gauge is derived from AttachmentManager state via GaugeFunc,
        // not incremented here. This survives controller restarts.
    }
}
```

7. Update `RecordNVMeDisconnect` (lines 330-334): Remove the `m.nvmeConnectionsActive.Dec()` line. The method body becomes empty (no counter to decrement). Add a comment:

```go
// RecordNVMeDisconnect is retained for API compatibility.
// The nvme_connections_active gauge is now derived from AttachmentManager state
// via GaugeFunc, so no manual decrement is needed.
func (m *Metrics) RecordNVMeDisconnect() {
    // nvme_connections_active gauge is derived from AttachmentManager state via GaugeFunc.
    // No manual decrement needed -- the gauge queries current state on each scrape.
}
```

In `pkg/driver/driver.go`:

8. After line 210 (after `driver.attachmentManager.SetMetrics(config.Metrics)`), add the wiring call:

```go
// Wire AttachmentManager into Metrics for nvme_connections_active gauge.
// GaugeFunc callback queries current attachment count on each Prometheus scrape,
// surviving controller restarts (attachment state rebuilt from VolumeAttachments).
//
// NOTE: This counts volumes (len(attachments)), not per-node attachments.
// During live migration with dual-attach, a volume attached to 2 nodes temporarily
// is counted as 1, not 2. This matches the VolumeAttachment count in the cluster.
config.Metrics.SetAttachmentManager(func() int {
    return len(driver.attachmentManager.ListAttachments())
})
```

This goes inside the existing `if config.Metrics != nil {` block, after the `driver.attachmentManager.SetMetrics(config.Metrics)` call.

IMPORTANT: Do NOT import the attachment package in prometheus.go. The func() int callback pattern avoids any import cycle issues.
  </action>
  <verify>
Run `make build-local` to confirm the code compiles without errors. Run `make vet` to check for vet issues.
  </verify>
  <done>
nvmeConnectionsActive is no longer a counter-derived gauge. It is a GaugeFunc registered via SetAttachmentManager that queries AttachmentManager.ListAttachments() length on each Prometheus scrape. RecordNVMeConnect no longer calls Inc(), RecordNVMeDisconnect no longer calls Dec(). The driver wires AttachmentManager into Metrics during initialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update and add unit tests for GaugeFunc-based active connections metric</name>
  <files>pkg/observability/prometheus_test.go</files>
  <action>
Update existing tests and add new tests in `pkg/observability/prometheus_test.go`:

1. **Update `TestRecordNVMeConnect` (line 104):** The test checks that nvme_connects_total and nvme_connect_duration_seconds metrics exist. It should still pass since those metrics remain. However, remove the check for `rds_csi_nvme_connections_active` from this test since the metric is no longer registered without SetAttachmentManager. The test should verify counters/histograms still work without SetAttachmentManager being called.

2. **Update `TestRecordNVMeConnect_ActiveConnectionsGauge` (line 131):** This test currently calls RecordNVMeConnect 3 times and expects nvme_connections_active to be 3. Rewrite it to use SetAttachmentManager:

```go
func TestRecordNVMeConnect_ActiveConnectionsGauge(t *testing.T) {
    m := NewMetrics()

    // Create a mock attachment count function
    attachmentCount := 3
    m.SetAttachmentManager(func() int {
        return attachmentCount
    })

    // RecordNVMeConnect should still work for counters
    m.RecordNVMeConnect(nil, 100*time.Millisecond)

    handler := m.Handler()
    req := httptest.NewRequest("GET", "/metrics", nil)
    rec := httptest.NewRecorder()
    handler.ServeHTTP(rec, req)

    body := rec.Body.String()
    if !strings.Contains(body, "rds_csi_nvme_connections_active 3") {
        t.Errorf("expected nvme_connections_active to be 3, got:\n%s", body)
    }
}
```

3. **Update `TestRecordNVMeDisconnect` (line 150):** Rewrite to verify that with 0 attachments, the gauge reports 0:

```go
func TestRecordNVMeDisconnect(t *testing.T) {
    m := NewMetrics()

    // Set up attachment manager with 0 attachments
    m.SetAttachmentManager(func() int {
        return 0
    })

    // RecordNVMeDisconnect should not panic
    m.RecordNVMeDisconnect()

    handler := m.Handler()
    req := httptest.NewRequest("GET", "/metrics", nil)
    rec := httptest.NewRecorder()
    handler.ServeHTTP(rec, req)

    body := rec.Body.String()
    if !strings.Contains(body, "rds_csi_nvme_connections_active 0") {
        t.Errorf("expected nvme_connections_active to be 0, got:\n%s", body)
    }
}
```

4. **Update `TestRecordNVMeDisconnect_MultipleConnections` (line 171):** Rewrite to verify dynamic count:

```go
func TestRecordNVMeDisconnect_MultipleConnections(t *testing.T) {
    m := NewMetrics()

    // Start with 3 attachments, then reduce to 2
    attachmentCount := 3
    m.SetAttachmentManager(func() int {
        return attachmentCount
    })

    // Verify starts at 3
    body := scrapeMetrics(t, m)
    if !strings.Contains(body, "rds_csi_nvme_connections_active 3") {
        t.Errorf("expected nvme_connections_active to be 3, got:\n%s", body)
    }

    // Simulate detach (reduce count)
    attachmentCount = 2

    // Verify now shows 2
    body = scrapeMetrics(t, m)
    if !strings.Contains(body, "rds_csi_nvme_connections_active 2") {
        t.Errorf("expected nvme_connections_active to be 2, got:\n%s", body)
    }
}
```

5. **Add helper function** `scrapeMetrics` to reduce boilerplate:

```go
// scrapeMetrics is a test helper that scrapes the /metrics endpoint and returns the body.
func scrapeMetrics(t *testing.T, m *Metrics) string {
    t.Helper()
    handler := m.Handler()
    req := httptest.NewRequest("GET", "/metrics", nil)
    rec := httptest.NewRecorder()
    handler.ServeHTTP(rec, req)
    if rec.Code != http.StatusOK {
        t.Fatalf("metrics endpoint returned status %d", rec.Code)
    }
    return rec.Body.String()
}
```

6. **Add new test: GaugeFunc queries AttachmentManager state correctly:**

```go
func TestNVMeConnectionsActive_QueriesAttachmentManager(t *testing.T) {
    m := NewMetrics()

    // Without SetAttachmentManager, metric should not appear
    body := scrapeMetrics(t, m)
    if strings.Contains(body, "nvme_connections_active") {
        t.Error("nvme_connections_active should not appear without SetAttachmentManager")
    }

    // Set up with 5 attachments
    m.SetAttachmentManager(func() int {
        return 5
    })

    body = scrapeMetrics(t, m)
    if !strings.Contains(body, "rds_csi_nvme_connections_active 5") {
        t.Errorf("expected nvme_connections_active to be 5, got:\n%s", body)
    }
}
```

7. **Add new test: Restart scenario (simulates controller restart):**

```go
func TestNVMeConnectionsActive_SurvivesRestart(t *testing.T) {
    // Simulate first controller instance
    m1 := NewMetrics()
    count1 := 16
    m1.SetAttachmentManager(func() int {
        return count1
    })

    body := scrapeMetrics(t, m1)
    if !strings.Contains(body, "rds_csi_nvme_connections_active 16") {
        t.Errorf("first instance should show 16, got:\n%s", body)
    }

    // Simulate controller restart: new Metrics instance, same attachment count
    // (AttachmentManager rebuilds state from VolumeAttachments on startup)
    m2 := NewMetrics()
    count2 := 16 // Same count - rebuilt from VolumeAttachments
    m2.SetAttachmentManager(func() int {
        return count2
    })

    body = scrapeMetrics(t, m2)
    if !strings.Contains(body, "rds_csi_nvme_connections_active 16") {
        t.Errorf("after restart, should still show 16 (rebuilt from VolumeAttachments), got:\n%s", body)
    }
}
```

8. **Add new test: Dynamic updates reflected in real-time:**

```go
func TestNVMeConnectionsActive_DynamicUpdates(t *testing.T) {
    m := NewMetrics()
    count := 0
    m.SetAttachmentManager(func() int {
        return count
    })

    // Start at 0
    body := scrapeMetrics(t, m)
    if !strings.Contains(body, "rds_csi_nvme_connections_active 0") {
        t.Errorf("expected 0, got:\n%s", body)
    }

    // Add attachments
    count = 5
    body = scrapeMetrics(t, m)
    if !strings.Contains(body, "rds_csi_nvme_connections_active 5") {
        t.Errorf("expected 5, got:\n%s", body)
    }

    // Remove some
    count = 2
    body = scrapeMetrics(t, m)
    if !strings.Contains(body, "rds_csi_nvme_connections_active 2") {
        t.Errorf("expected 2, got:\n%s", body)
    }

    // Remove all
    count = 0
    body = scrapeMetrics(t, m)
    if !strings.Contains(body, "rds_csi_nvme_connections_active 0") {
        t.Errorf("expected 0, got:\n%s", body)
    }
}
```

9. **Update `TestMetricsNamespace` (line 373):** This test calls `m.RecordNVMeConnect(nil, 100*time.Millisecond)` which previously caused `nvme_connections_active` to appear. Since the metric is no longer registered without SetAttachmentManager, either: (a) add `m.SetAttachmentManager(func() int { return 1 })` before the assertion loop, OR (b) confirm the test still passes since `nvme_connections_active` is no longer emitted and therefore no non-rds_csi_ prefixed lines appear. The test should still pass either way since it only checks that metric lines start with rds_csi_.

IMPORTANT: Add SetAttachmentManager to this test to ensure nvme_connections_active is included in namespace validation.
  </action>
  <verify>
Run `make test` and verify all tests pass. Run `go test -v ./pkg/observability/... -run "NVMe"` to specifically check all NVMe-related tests including the new TestNVMeConnectionsActive_* tests.
  </verify>
  <done>
All existing tests updated to use SetAttachmentManager pattern instead of Inc/Dec pattern. 4 new tests added: QueriesAttachmentManager (verifies metric absent without SetAttachmentManager, present with it), SurvivesRestart (new Metrics instance shows correct count), DynamicUpdates (count changes reflected in real-time), and scrapeMetrics helper. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `make build-local` passes (code compiles)
2. `make test` passes (all unit tests pass including updated NVMe connection tests)
3. `make verify` passes (fmt + vet + lint + test all green)
4. Grep for `nvmeConnectionsActive.Inc` and `nvmeConnectionsActive.Dec` returns no matches (counter pattern fully removed)
5. Grep for `SetAttachmentManager` returns matches in prometheus.go, prometheus_test.go, and driver.go (wiring complete)
6. Grep for `NewGaugeFunc` returns match in prometheus.go (GaugeFunc registered)
</verification>

<success_criteria>
1. rds_csi_nvme_connections_active metric is derived from AttachmentManager state via GaugeFunc callback
2. Metric is NOT registered when SetAttachmentManager is not called (node plugin safety)
3. RecordNVMeConnect no longer modifies the active connections gauge
4. RecordNVMeDisconnect no longer modifies the active connections gauge
5. Counter (nvme_connects_total) and histogram (nvme_connect_duration_seconds) continue to work
6. Driver.go wires AttachmentManager into Metrics during initialization
7. All unit tests pass including new restart-survival and dynamic-update tests
8. No import cycle between observability and attachment packages (func() int callback pattern)
9. Restart scenario validated: TestNVMeConnectionsActive_SurvivesRestart simulates controller restart (new Metrics instance + SetAttachmentManager = correct count from rebuilt state)
10. Dual-attach behavior documented: Metric counts volumes (not per-node attachments), so migration dual-attach doesn't inflate count
</success_criteria>

<output>
After completion, create `.planning/phases/28.1-fix-rds-csi-nvme-connections-active-metric-accuracy/28.1-01-SUMMARY.md`
</output>
