---
phase: 29-snapshot-implementation-fix
plan: 02
type: execute
wave: 2
depends_on: ["29-01"]
files_modified:
  - pkg/driver/controller.go
  - pkg/driver/controller_test.go
autonomous: true

must_haves:
  truths:
    - "CreateSnapshot CSI RPC generates snapshot ID as snap-<source-uuid>-at-<timestamp> and passes basePath (not FSLabel)"
    - "DeleteSnapshot CSI RPC delegates to rdsClient.DeleteSnapshot without Btrfs-specific logic"
    - "ListSnapshots extracts source volume ID from snapshot name for filtering"
    - "createVolumeFromSnapshot delegates to rdsClient.RestoreSnapshot with correct options"
    - "getBtrfsFSLabel helper is removed (no longer needed)"
  artifacts:
    - path: "pkg/driver/controller.go"
      provides: "Updated CSI controller RPCs for snapshot operations"
      contains: "GenerateSnapshotIDFromSource"
    - path: "pkg/driver/controller_test.go"
      provides: "Updated controller tests for new snapshot flow"
  key_links:
    - from: "pkg/driver/controller.go CreateSnapshot"
      to: "pkg/utils/snapshotid.go GenerateSnapshotIDFromSource"
      via: "function call"
      pattern: "utils\\.GenerateSnapshotIDFromSource"
    - from: "pkg/driver/controller.go CreateSnapshot"
      to: "pkg/rds/commands.go CreateSnapshot"
      via: "rdsClient.CreateSnapshot"
      pattern: "rdsClient\\.CreateSnapshot"
    - from: "pkg/driver/controller.go ListSnapshots"
      to: "pkg/utils/snapshotid.go ExtractSourceVolumeIDFromSnapshotID"
      via: "function call for source filtering"
      pattern: "ExtractSourceVolumeIDFromSnapshotID"
---

<objective>
Update CSI controller snapshot RPCs (CreateSnapshot, DeleteSnapshot, ListSnapshots, CreateVolume from snapshot) to use the rewritten SSH backend from Plan 29-01.

Purpose: The controller layer in pkg/driver/controller.go still uses FSLabel-based logic, SnapshotNameToID for deterministic IDs, and Btrfs-specific error handling. This plan updates the CSI RPC layer to match the new `/disk add copy-from` backend, new snapshot naming format, and simplified options.

Output: Working CSI controller snapshot operations that correctly interface with the rewritten SSH layer, with all controller tests passing.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-snapshot-implementation-fix/29-CONTEXT.md
@.planning/phases/29-snapshot-implementation-fix/29-01-SUMMARY.md
@pkg/driver/controller.go
@pkg/driver/controller_test.go
@pkg/rds/types.go
@pkg/utils/snapshotid.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update CreateSnapshot and DeleteSnapshot CSI RPCs</name>
  <files>
    pkg/driver/controller.go
  </files>
  <action>
  **Update CreateSnapshot (lines ~984-1077):**

  1. **Snapshot ID generation** — Replace `utils.SnapshotNameToID(req.GetName())` with `utils.GenerateSnapshotIDFromSource(sourceVolumeID)`.
     - The new ID embeds the source volume UUID and a timestamp, making it unique per snapshot creation.
     - NOTE: This means CreateSnapshot is NOT strictly idempotent on the CSI name alone (each call generates a new timestamp). However, the idempotency check still works: before creating, we call `rdsClient.GetSnapshot()` and if a snapshot already exists for this source, the external-snapshotter won't call again.
     - For idempotency: Instead of generating a new ID, first check if any existing snapshot matches by listing snapshots and filtering by source + CSI name. If found, return it. If not, generate new ID and create.
     - **Alternative simpler approach (preferred):** Keep using `utils.SnapshotNameToID(req.GetName())` for the deterministic UUID portion but append `-at-<timestamp>`. Actually, per the locked decision, the format is `snap-<source-pvc-uuid>-at-<timestamp>`, which means the snapshot ID is NOT derived from the CSI snapshot name at all. The CSI name is the VolumeSnapshot CR name, and the snapshot ID is the RDS-side identifier.
     - **Idempotency strategy:** Before creating, list existing snapshots filtered by source volume. If any snapshot's name was generated from the same CSI snapshot name (match via annotation or naming convention), return it. Since we can't store the CSI name in RDS, use this approach: check if a snapshot with matching source already exists within the same second (timestamp collision = same request). If that's too fragile, store CSI-name-to-snapshot-ID mapping in the response and rely on external-snapshotter's own idempotency (it tracks by VolumeSnapshotContent).
     - **Simplest correct approach:** Generate ID, attempt create. If a snapshot already exists for this source from a previous call with the SAME CSI name, external-snapshotter already handles this via VolumeSnapshotContent — it won't re-call CreateSnapshot if the content already exists. So we can safely generate a new ID each time and let external-snapshotter handle idempotency.

  2. **Remove FSLabel logic** — Delete the call to `cs.getBtrfsFSLabel(req.GetParameters())`.

  3. **Add basePath** — Extract `volumeBasePath` from `req.GetParameters()` (same as CreateVolume does):
     ```go
     volumeBasePath := defaultVolumeBasePath
     if path, ok := params[paramVolumePath]; ok {
         volumeBasePath = path
     }
     ```

  4. **Build CreateSnapshotOptions:**
     ```go
     createOpts := rds.CreateSnapshotOptions{
         Name:         snapshotID,
         SourceVolume: sourceVolumeID,
         BasePath:     volumeBasePath,
     }
     ```

  5. **Update response building** — The `snapshotInfo` returned from `rdsClient.CreateSnapshot()` now has `FilePath` instead of `ReadOnly`/`FSLabel`. Use `snapshotInfo.FileSizeBytes` and `snapshotInfo.CreatedAt` as before.

  6. **Update idempotency check** — The existing check calls `rdsClient.GetSnapshot(snapshotID)`. Since snapshot ID now contains a timestamp, the same CSI name would generate different IDs on retry. To handle this correctly:
     - On entry, list all snapshots for the source volume.
     - Check if any existing snapshot was created for this CSI name. Since we can't store the CSI name in RDS, we rely on: if external-snapshotter already has a VolumeSnapshotContent for this name, it won't call CreateSnapshot again. So the idempotency check is effectively handled by Kubernetes.
     - Remove the pre-creation GetSnapshot idempotency check (it can't work with timestamp-based IDs). Instead, just create the snapshot. If external-snapshotter retries, it already has the content object and won't call again.
     - HOWEVER: for CSI sanity tests which DO test CreateSnapshot idempotency, we need a workaround. The sanity test calls CreateSnapshot twice with the same name and expects the same snapshot ID back. Since our ID includes a timestamp, this breaks sanity.
     - **Resolution:** Use a hybrid approach. Generate snapshot ID deterministically from CSI name + source volume (like existing `SnapshotNameToID`) BUT also embed source UUID for lineage. Format: `snap-<source-uuid>-at-<deterministic-hash>`. Use a hash of the CSI snapshot name as the "timestamp" portion for determinism.
     - **Actually, simplest correct approach:** Keep `SnapshotNameToID()` logic (deterministic from CSI name) but change the OUTPUT format to include source UUID. New function: `GenerateSnapshotID(csiName string, sourceVolumeID string) string` that produces `snap-<source-uuid>-at-<hash-of-csi-name>`. This gives determinism (idempotent) AND embeds source lineage AND satisfies CSI sanity tests. The "timestamp" portion becomes a hash, not a real timestamp — but it's still unique per CSI name.
     - Update `pkg/utils/snapshotid.go` if not already done in plan 01: add `GenerateSnapshotID(csiName, sourceVolumeID string) string` that extracts UUID from sourceVolumeID and appends a deterministic hash suffix.

  **Update DeleteSnapshot (lines ~1080-1110):**

  Minimal changes needed — the RPC already delegates to `rdsClient.DeleteSnapshot()`. The RDS layer (plan 01) now handles both disk removal and file deletion.

  1. Remove any Btrfs-specific error handling if present.
  2. The rest stays the same (validation, idempotency, error mapping).

  **Remove getBtrfsFSLabel helper** (lines ~1400-1411):
  - Delete the entire `getBtrfsFSLabel()` method — no longer needed.
  </action>
  <verify>
  Run `cd /Users/whiskey/code/rds-csi && go build ./pkg/driver/...` — compiles.
  Run `go vet ./pkg/driver/...` — no issues.
  </verify>
  <done>
  - CreateSnapshot uses new snapshot ID format with source UUID embedded
  - CreateSnapshot passes BasePath instead of FSLabel
  - getBtrfsFSLabel helper is removed
  - DeleteSnapshot delegates cleanly to rewritten rdsClient.DeleteSnapshot
  - Code compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ListSnapshots, createVolumeFromSnapshot, and controller tests</name>
  <files>
    pkg/driver/controller.go
    pkg/driver/controller_test.go
    pkg/utils/snapshotid.go
  </files>
  <action>
  **Update ListSnapshots (lines ~1112-1219):**

  1. The `ListSnapshots` RPC already uses `rdsClient.ListSnapshots()` and `rdsClient.GetSnapshot()`. These are rewritten in plan 01 to use `/disk print` instead of `/disk/btrfs/subvolume/print`. The RPC code mostly just needs type field updates.

  2. **Source volume filtering:** The existing code filters by `s.SourceVolume == req.GetSourceVolumeId()`. With the new approach, `SnapshotInfo.SourceVolume` is populated either from the snapshot slot name (via `ExtractSourceVolumeIDFromSnapshotID()`) or from the mock server. Update the filtering:
     - If `snap.SourceVolume` is empty (real RDS doesn't store this), derive it from the snapshot name using `utils.ExtractSourceVolumeIDFromSnapshotID(snap.Name)`.
     - This works because snapshot names embed the source UUID: `snap-<source-uuid>-at-<suffix>`.

  3. **Response building:** Update to use the new `SnapshotInfo` fields. `snap.Name` is the snapshot ID (CSI snapshot ID = RDS slot name per locked decision). `snap.SourceVolume` is derived as above.

  **Update createVolumeFromSnapshot (lines ~255-358):**

  1. This function calls `rdsClient.GetSnapshot(snapshotID)` and `rdsClient.RestoreSnapshot(snapshotID, restoreOpts)`. Both are rewritten in plan 01.

  2. Update `snapshotInfo` field access: remove any reference to `ReadOnly` or `FSLabel`. Use `FileSizeBytes` as before.

  3. The rest of the function (NQN generation, file path, NVMe params) stays the same — it creates a normal volume from the snapshot data.

  **Update pkg/utils/snapshotid.go if needed:**

  If plan 01 created `GenerateSnapshotIDFromSource(sourceVolumeID)` with a real timestamp, add an additional function for CSI controller use:
  - `GenerateSnapshotID(csiName string, sourceVolumeID string) string`:
    - Extracts source UUID from `sourceVolumeID` (strip `pvc-` prefix).
    - Generates a deterministic suffix from `csiName` using UUID v5 (same namespace as `SnapshotNameToID`).
    - Takes first 10 chars of the UUID hex (no dashes) as the suffix.
    - Returns `snap-<source-uuid>-at-<10-char-hash>`.
    - This is deterministic (same name + source always produces same ID) for CSI idempotency.

  **Update controller_test.go:**

  1. Update any test cases that reference `FSLabel`, `ReadOnly`, or old snapshot ID format.
  2. Update mock setup: use new `SnapshotInfo` struct (no `ReadOnly`/`FSLabel`, add `FilePath`).
  3. Update expected snapshot IDs in assertions to match new format.
  4. Ensure CreateSnapshot idempotency test still passes (same name + source -> same ID).
  5. Ensure DeleteSnapshot test handles the new two-step deletion (disk + file).
  6. Ensure ListSnapshots test works with source volume derivation from snapshot name.

  **Verify no stale references:**
  - Grep for `getBtrfsFSLabel` — should be zero.
  - Grep for `btrfsFSLabel` in controller.go — should be zero.
  - Grep for `/disk/btrfs/subvolume` in controller.go — should be zero.
  - Grep for `ReadOnly` in snapshot-related code paths — should be zero.
  </action>
  <verify>
  Run `cd /Users/whiskey/code/rds-csi && go test ./pkg/driver/... -v -run TestCreate.*Snapshot` — snapshot creation tests pass.
  Run `go test ./pkg/driver/... -v -run TestDelete.*Snapshot` — snapshot deletion tests pass.
  Run `go test ./pkg/driver/... -v -run TestList.*Snapshot` — snapshot listing tests pass.
  Run `make test` — full test suite passes.
  Run `make lint` — no lint errors.
  Grep for `btrfs` in `pkg/driver/controller.go` — zero matches.
  Grep for `FSLabel` in `pkg/driver/controller.go` — zero matches.
  </verify>
  <done>
  - ListSnapshots derives source volume from snapshot name when not stored in RDS
  - createVolumeFromSnapshot works with rewritten RestoreSnapshot backend
  - getBtrfsFSLabel completely removed
  - No references to Btrfs subvolumes, FSLabel, or ReadOnly in controller.go
  - All controller snapshot tests pass
  - `make test` passes with zero failures
  - `make lint` clean
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` — entire project compiles
2. `go test ./pkg/driver/... -v` — all controller tests pass
3. `make test` — full test suite passes
4. `make lint` — no lint errors
5. Grep for `btrfs` in `pkg/driver/controller.go` — zero matches
6. Grep for `FSLabel` in `pkg/driver/controller.go` — zero matches
7. Grep for `getBtrfsFSLabel` in entire codebase — zero matches (removed)
8. Grep for `/disk/btrfs/subvolume` in `pkg/driver/controller.go` — zero matches
</verification>

<success_criteria>
- CSI CreateSnapshot generates snapshot ID with source UUID embedded and passes basePath to RDS layer
- CSI DeleteSnapshot delegates to RDS layer cleanly (disk + file removal)
- CSI ListSnapshots can filter by source volume using snapshot name parsing
- CSI CreateVolume from snapshot delegates to RDS RestoreSnapshot correctly
- No Btrfs subvolume references remain in controller code
- All tests pass, code compiles, linter clean
</success_criteria>

<output>
After completion, create `.planning/phases/29-snapshot-implementation-fix/29-02-SUMMARY.md`
</output>
