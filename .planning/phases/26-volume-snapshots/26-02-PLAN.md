---
phase: 26-volume-snapshots
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - pkg/rds/commands.go
autonomous: true

must_haves:
  truths:
    - "CreateSnapshot executes /disk/btrfs/subvolume/add with read-only=yes via SSH to create Btrfs snapshot"
    - "DeleteSnapshot executes /disk/btrfs/subvolume/remove via SSH and is idempotent (not found = success)"
    - "GetSnapshot queries /disk/btrfs/subvolume/print to retrieve snapshot metadata"
    - "ListSnapshots returns only snap-* prefixed subvolumes from RouterOS"
    - "RestoreSnapshot creates writable snapshot-of-snapshot (no read-only flag) for volume restore"
  artifacts:
    - path: "pkg/rds/commands.go"
      provides: "SSH command implementations for all 5 snapshot operations on sshClient"
      contains: "btrfs/subvolume"
  key_links:
    - from: "pkg/rds/commands.go"
      to: "pkg/rds/types.go"
      via: "Uses SnapshotInfo, CreateSnapshotOptions, SnapshotNotFoundError types"
      pattern: "SnapshotInfo"
    - from: "pkg/rds/commands.go"
      to: "pkg/utils/snapshotid.go"
      via: "Validates snapshot IDs before SSH command execution"
      pattern: "ValidateSnapshotID"
---

<objective>
Implement the RDS SSH command layer for Btrfs snapshot operations on sshClient.

Purpose: Replace the stub implementations from Plan 01 with real RouterOS SSH commands. This is the control plane bridge between CSI controller RPCs and the MikroTik RDS storage backend.
Output: Five working sshClient methods that execute RouterOS `/disk/btrfs/subvolume` commands via SSH.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-volume-snapshots/26-CONTEXT.md
@.planning/phases/26-volume-snapshots/26-RESEARCH.md
@.planning/phases/26-volume-snapshots/26-01-SUMMARY.md
@pkg/rds/commands.go
@pkg/rds/types.go
@pkg/utils/snapshotid.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement sshClient snapshot SSH commands</name>
  <files>pkg/rds/commands.go</files>
  <action>
  Replace the 5 stub snapshot methods at the bottom of commands.go with full implementations. Follow the existing patterns in commands.go (validateSlotName, runCommandWithRetry, error handling, klog levels).

  **1. CreateSnapshot(opts CreateSnapshotOptions) (*SnapshotInfo, error)**
  - Validate opts.Name using utils.ValidateSnapshotID (import pkg/utils if not already)
  - Validate opts.SourceVolume using validateSlotName
  - Validate opts.FSLabel is not empty
  - Build command: `/disk/btrfs/subvolume/add read-only=yes parent=<opts.SourceVolume> fs=<opts.FSLabel> name=<opts.Name>`
  - Execute with runCommandWithRetry (3 retries, same as CreateVolume)
  - After creation, call GetSnapshot to verify and return the result
  - Log at V(2): "Created snapshot %s from volume %s"
  - Log at V(4): "Created snapshot %s (source=%s, fs=%s)"
  - On error, attempt cleanup: run `/disk/btrfs/subvolume/remove [find where name=<opts.Name>]` (best-effort, log warning if cleanup fails -- per CONTEXT.md "auto-cleanup partial snapshot")

  **2. DeleteSnapshot(snapshotID string) error**
  - Validate snapshotID using utils.ValidateSnapshotID
  - Check if snapshot exists via GetSnapshot. If SnapshotNotFoundError, return nil (idempotent, per CSI spec)
  - Build command: `/disk/btrfs/subvolume/remove [find where name=<snapshotID>]`
  - Execute with runCommandWithRetry (3 retries)
  - If error contains "no such item", treat as success (idempotent)
  - Log at V(2): "Deleted snapshot %s"

  **3. GetSnapshot(snapshotID string) (*SnapshotInfo, error)**
  - Validate snapshotID using utils.ValidateSnapshotID
  - Build command: `/disk/btrfs/subvolume/print detail where name=<snapshotID>`
  - Execute with runCommand (no retry needed for reads)
  - Parse output using a new `parseSnapshotInfo(output string) (*SnapshotInfo, error)` function
  - If output is empty/no match, return &SnapshotNotFoundError{Name: snapshotID}
  - The parser should extract: name, read-only flag, and any available metadata
  - NOTE: RouterOS may not return all fields we want (like source volume or creation time). For fields not available from RouterOS output, the controller layer will track them. The parser should handle missing fields gracefully.

  **4. ListSnapshots() ([]SnapshotInfo, error)**
  - Build command: `/disk/btrfs/subvolume/print where name~"snap-"`
  - Execute with runCommand
  - Parse output using a new `parseSnapshotList(output string) ([]SnapshotInfo, error)` function
  - Only return entries matching `snap-*` prefix (filter in parsing, not just command)
  - Return empty slice (not nil) if no snapshots found

  **5. RestoreSnapshot(snapshotID string, newVolumeOpts CreateVolumeOptions) error**
  - Validate snapshotID using utils.ValidateSnapshotID
  - Validate newVolumeOpts using existing validateCreateVolumeOptions
  - Verify snapshot exists via GetSnapshot (return error if not found)
  - Get FSLabel from the snapshot info
  - Step 1: Create writable snapshot-of-snapshot (Btrfs clone):
    `/disk/btrfs/subvolume/add parent=<snapshotID> fs=<fsLabel> name=<newVolumeOpts.Slot>`
    (Note: NO read-only=yes -- this creates a writable clone)
  - Step 2: Create /disk entry for NVMe/TCP export using the standard CreateVolume command:
    `/disk add type=file file-path=<newVolumeOpts.FilePath> file-size=<size> slot=<newVolumeOpts.Slot> nvme-tcp-export=yes nvme-tcp-server-port=<port> nvme-tcp-server-nqn=<nqn>`
  - NOTE: The exact relationship between Btrfs subvolumes and /disk entries on RouterOS is an open research question (see RESEARCH.md Open Question 1). Implement the most logical approach: create the subvolume clone first, then create the disk entry. If the /disk add command needs to reference the subvolume path differently, this will be caught during hardware validation. Add a comment noting this is the expected flow but may need adjustment based on RouterOS behavior.
  - On partial failure (Step 1 succeeds, Step 2 fails), attempt cleanup of the Btrfs subvolume
  - Log at V(2): "Restored snapshot %s to new volume %s"

  **Parser functions (add as private functions):**
  - `parseSnapshotInfo(output string) (*SnapshotInfo, error)` -- parse single snapshot detail output
  - `parseSnapshotList(output string) ([]SnapshotInfo, error)` -- parse list of snapshots

  RouterOS `/disk/btrfs/subvolume/print detail` output format is expected to be similar to `/disk print detail` with key=value pairs. Parse using the same approach as `parseVolumeInfo` -- look for fields like `name=`, `read-only=`. Since exact output format needs hardware validation, add TODO comments for fields that may need adjustment.

  IMPORTANT: Import `"git.srvlab.io/whiskey/rds-csi-driver/pkg/utils"` at the top of commands.go if not already imported (it likely is, for validateSlotName usage via utils package).
  </action>
  <verify>
  Run `go build ./pkg/rds/...` to verify compilation. Run `go vet ./pkg/rds/...`. Run `go test ./pkg/rds/... -count=1` to verify existing tests still pass.
  </verify>
  <done>All 5 sshClient snapshot methods implemented with real RouterOS commands. Parser functions handle snapshot output. Error handling follows existing patterns (retry, idempotency, cleanup). Compilation succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for snapshot command parsing and mock integration</name>
  <files>pkg/rds/commands_test.go</files>
  <action>
  Add unit tests for the new snapshot parsing functions and verify mock client snapshot operations work correctly. Add tests to the existing `commands_test.go` file (or create it if it doesn't exist).

  **Tests to add:**

  1. `TestParseSnapshotInfo` -- test parsing RouterOS output for a single snapshot
     - Valid snapshot output with all fields
     - Empty output (should return SnapshotNotFoundError)
     - Partial output (missing optional fields)

  2. `TestParseSnapshotList` -- test parsing RouterOS output for snapshot list
     - Multiple snapshots
     - Empty list (should return empty slice, not nil)
     - Mixed snap- and non-snap entries (should filter)

  3. `TestMockClientSnapshotOperations` -- integration test using MockClient
     - Create a volume, then create snapshot from it
     - Verify snapshot has correct source volume and read-only=true
     - Create duplicate snapshot with same name and source (idempotent -- returns existing)
     - Create duplicate snapshot with same name but different source (error)
     - Delete snapshot, verify gone
     - Delete non-existent snapshot (idempotent -- no error)
     - Get non-existent snapshot (SnapshotNotFoundError)
     - List snapshots (returns all, empty when none)

  4. `TestValidateSnapshotID` -- test snapshot ID validation
     - Valid snap-<uuid> format
     - Valid alphanumeric (sanity test IDs)
     - Empty string (error)
     - Command injection characters (error)
     - snap- prefix with invalid UUID (error)
     - Too long (error)

  Follow existing test patterns in the codebase (table-driven tests where appropriate).
  </action>
  <verify>
  Run `go test ./pkg/rds/... -v -count=1` and `go test ./pkg/utils/... -v -count=1` to verify all tests pass.
  </verify>
  <done>Unit tests cover snapshot parsing, mock client snapshot CRUD, and snapshot ID validation. All tests pass.</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles without errors
- `go test ./pkg/rds/... -v -count=1` passes all tests (existing + new)
- `go test ./pkg/utils/... -v -count=1` passes all tests
- sshClient.CreateSnapshot builds correct RouterOS command with `read-only=yes`
- sshClient.DeleteSnapshot is idempotent (not found = success)
- sshClient.RestoreSnapshot creates writable clone (no read-only flag)
- MockClient snapshot operations verified by unit tests
</verification>

<success_criteria>
1. All 5 sshClient snapshot stubs replaced with real implementations
2. RouterOS commands use `/disk/btrfs/subvolume` hierarchy (not `/disk`)
3. Snapshot parsers handle RouterOS output format
4. RestoreSnapshot creates writable clone + NVMe disk entry
5. Unit tests pass for parsing, mock operations, and ID validation
6. Full project compiles: `go build ./...` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/26-volume-snapshots/26-02-SUMMARY.md`
</output>
