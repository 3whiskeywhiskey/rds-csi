---
phase: 26-volume-snapshots
plan: 04
type: execute
wave: 4
depends_on: ["26-03"]
files_modified:
  - pkg/driver/controller.go
autonomous: true

must_haves:
  truths:
    - "ListSnapshots returns existing snapshots with correct pagination (starting_token, max_entries, next_token)"
    - "ListSnapshots filters by snapshot_id when provided (single snapshot lookup)"
    - "ListSnapshots filters by source_volume_id when provided"
    - "ListSnapshots returns empty response (not error) when no snapshots match"
    - "CreateVolume with VolumeContentSource.Snapshot restores a new volume from an existing snapshot"
    - "CreateVolume from snapshot validates snapshot exists before restore"
    - "CreateVolume from snapshot returns NOT_FOUND if snapshot does not exist"
  artifacts:
    - path: "pkg/driver/controller.go"
      provides: "ListSnapshots RPC with pagination and CreateVolume snapshot restore logic"
      contains: "ListSnapshotsResponse"
  key_links:
    - from: "pkg/driver/controller.go"
      to: "pkg/rds/client.go"
      via: "cs.driver.rdsClient.ListSnapshots/GetSnapshot/RestoreSnapshot"
      pattern: "rdsClient\\.(ListSnapshots|GetSnapshot|RestoreSnapshot)"
    - from: "pkg/driver/controller.go (CreateVolume)"
      to: "req.GetVolumeContentSource().GetSnapshot()"
      via: "VolumeContentSource check in CreateVolume"
      pattern: "VolumeContentSource"
---

<objective>
Implement ListSnapshots with pagination and extend CreateVolume to support volume restore from snapshots.

Purpose: ListSnapshots enables snapshot enumeration (required by external-snapshotter sidecar). CreateVolume from snapshot enables the restore workflow -- the core user value of snapshots.
Output: ListSnapshots RPC with CSI-compliant pagination, CreateVolume enhanced with VolumeContentSource handling.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-volume-snapshots/26-CONTEXT.md
@.planning/phases/26-volume-snapshots/26-RESEARCH.md
@.planning/phases/26-volume-snapshots/26-03-SUMMARY.md
@pkg/driver/controller.go
@pkg/rds/client.go
@pkg/rds/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ListSnapshots with pagination</name>
  <files>pkg/driver/controller.go</files>
  <action>
  Replace the existing stub ListSnapshots method with a full implementation following the CSI spec pagination pattern (integer-based token, matching the hostpath driver pattern from RESEARCH.md).

  ```go
  func (cs *ControllerServer) ListSnapshots(ctx context.Context, req *csi.ListSnapshotsRequest) (*csi.ListSnapshotsResponse, error) {
      klog.V(4).Infof("ListSnapshots CSI call (snapshot_id=%s, source_volume_id=%s, max_entries=%d, starting_token=%s)",
          req.GetSnapshotId(), req.GetSourceVolumeId(), req.GetMaxEntries(), req.GetStartingToken())

      // Safety check
      if cs.driver == nil || cs.driver.rdsClient == nil {
          return nil, status.Error(codes.Internal, "RDS client not initialized")
      }

      // Handle single snapshot lookup by ID
      if req.GetSnapshotId() != "" {
          snapshotID := req.GetSnapshotId()
          if err := utils.ValidateSnapshotID(snapshotID); err != nil {
              // Invalid ID format -- return empty (not error) per CSI spec
              return &csi.ListSnapshotsResponse{}, nil
          }

          snap, err := cs.driver.rdsClient.GetSnapshot(snapshotID)
          if err != nil {
              // Not found -> return empty response (not error)
              return &csi.ListSnapshotsResponse{}, nil
          }

          return &csi.ListSnapshotsResponse{
              Entries: []*csi.ListSnapshotsResponse_Entry{
                  {
                      Snapshot: &csi.Snapshot{
                          SnapshotId:     snap.Name,
                          SourceVolumeId: snap.SourceVolume,
                          CreationTime:   timestamppb.New(snap.CreatedAt),
                          SizeBytes:      snap.FileSizeBytes,
                          ReadyToUse:     true,
                      },
                  },
              },
          }, nil
      }

      // Fetch all snapshots from RDS
      allSnapshots, err := cs.driver.rdsClient.ListSnapshots()
      if err != nil {
          if stderrors.Is(err, utils.ErrConnectionFailed) || stderrors.Is(err, utils.ErrOperationTimeout) {
              return nil, status.Errorf(codes.Unavailable, "RDS unavailable: %v", err)
          }
          return nil, status.Errorf(codes.Internal, "failed to list snapshots: %v", err)
      }

      // Filter by source volume if specified
      if req.GetSourceVolumeId() != "" {
          filtered := make([]rds.SnapshotInfo, 0)
          for _, s := range allSnapshots {
              if s.SourceVolume == req.GetSourceVolumeId() {
                  filtered = append(filtered, s)
              }
          }
          allSnapshots = filtered
      }

      // Sort by name for deterministic pagination
      sort.Slice(allSnapshots, func(i, j int) bool {
          return allSnapshots[i].Name < allSnapshots[j].Name
      })

      // Handle pagination
      startIndex := 0
      if req.GetStartingToken() != "" {
          idx, err := strconv.Atoi(req.GetStartingToken())
          if err != nil {
              return nil, status.Errorf(codes.Aborted, "invalid starting_token: %s", req.GetStartingToken())
          }
          if idx < 0 || idx > len(allSnapshots) {
              return nil, status.Errorf(codes.Aborted, "starting_token out of range: %d (total: %d)", idx, len(allSnapshots))
          }
          startIndex = idx
      }

      // Build response entries
      maxEntries := len(allSnapshots) - startIndex
      if req.GetMaxEntries() > 0 && int(req.GetMaxEntries()) < maxEntries {
          maxEntries = int(req.GetMaxEntries())
      }

      entries := make([]*csi.ListSnapshotsResponse_Entry, 0, maxEntries)
      for i := startIndex; i < startIndex+maxEntries && i < len(allSnapshots); i++ {
          s := allSnapshots[i]
          entries = append(entries, &csi.ListSnapshotsResponse_Entry{
              Snapshot: &csi.Snapshot{
                  SnapshotId:     s.Name,
                  SourceVolumeId: s.SourceVolume,
                  CreationTime:   timestamppb.New(s.CreatedAt),
                  SizeBytes:      s.FileSizeBytes,
                  ReadyToUse:     true,
              },
          })
      }

      // Set next token if more entries exist
      var nextToken string
      if startIndex+maxEntries < len(allSnapshots) {
          nextToken = strconv.Itoa(startIndex + maxEntries)
      }

      return &csi.ListSnapshotsResponse{
          Entries:   entries,
          NextToken: nextToken,
      }, nil
  }
  ```

  Ensure `"sort"` and `"strconv"` are in the imports (strconv is likely already there; sort may need to be added).
  </action>
  <verify>
  Run `go build ./pkg/driver/...` to verify compilation. Run `go vet ./pkg/driver/...`.
  </verify>
  <done>ListSnapshots implements full CSI pagination with integer-based tokens, single snapshot lookup by ID, source volume filtering, and deterministic sorting.</done>
</task>

<task type="auto">
  <name>Task 2: Extend CreateVolume for snapshot restore (VolumeContentSource)</name>
  <files>pkg/driver/controller.go</files>
  <action>
  Modify the existing CreateVolume method to handle `VolumeContentSource` with a snapshot source. Insert the snapshot handling AFTER the existing idempotency check (after the `if err == nil` block that returns existing volume) and BEFORE the volume creation code.

  Add this block after the idempotency check section (around line 144-146 where "// Volume doesn't exist, create it" comment is):

  ```go
  // Check for volume content source (snapshot restore)
  if contentSource := req.GetVolumeContentSource(); contentSource != nil {
      if snapshotSource := contentSource.GetSnapshot(); snapshotSource != nil {
          return cs.createVolumeFromSnapshot(ctx, req, volumeID, snapshotSource.GetSnapshotId(), requiredBytes)
      }
      // Volume clone (not yet supported)
      if contentSource.GetVolume() != nil {
          return nil, status.Error(codes.InvalidArgument, "volume cloning is not supported, use snapshot restore instead")
      }
  }
  ```

  Then add the `createVolumeFromSnapshot` helper method:

  ```go
  // createVolumeFromSnapshot handles CreateVolume with a snapshot source (restore workflow)
  func (cs *ControllerServer) createVolumeFromSnapshot(
      ctx context.Context,
      req *csi.CreateVolumeRequest,
      volumeID string,
      snapshotID string,
      requiredBytes int64,
  ) (*csi.CreateVolumeResponse, error) {
      klog.V(4).Infof("Creating volume %s from snapshot %s", volumeID, snapshotID)

      // Validate snapshot ID
      if err := utils.ValidateSnapshotID(snapshotID); err != nil {
          return nil, status.Errorf(codes.InvalidArgument, "invalid snapshot ID: %v", err)
      }

      // Verify snapshot exists
      snapshotInfo, err := cs.driver.rdsClient.GetSnapshot(snapshotID)
      if err != nil {
          if _, ok := err.(*rds.SnapshotNotFoundError); ok {
              return nil, status.Errorf(codes.NotFound, "snapshot %s not found", snapshotID)
          }
          return nil, status.Errorf(codes.Internal, "failed to get snapshot: %v", err)
      }

      // CSI spec: volume size must not be less than snapshot size
      if requiredBytes < snapshotInfo.FileSizeBytes {
          requiredBytes = snapshotInfo.FileSizeBytes
      }

      // Get parameters
      params := req.GetParameters()
      volumeBasePath := defaultVolumeBasePath
      if path, ok := params[paramVolumePath]; ok {
          volumeBasePath = path
      }

      nvmePort := defaultNVMETCPPort
      if portStr, ok := params[paramNVMEPort]; ok {
          var port int
          if _, err := fmt.Sscanf(portStr, "%d", &port); err == nil {
              nvmePort = port
          }
      }

      // Parse NVMe connection parameters
      nvmeParams, err := ParseNVMEConnectionParams(params)
      if err != nil {
          return nil, status.Errorf(codes.InvalidArgument, "invalid NVMe connection parameters: %v", err)
      }
      migrationTimeout := ParseMigrationTimeout(params)

      // Generate NQN and file path for new volume
      nqn, err := utils.VolumeIDToNQN(volumeID)
      if err != nil {
          return nil, status.Errorf(codes.Internal, "failed to generate NQN: %v", err)
      }
      filePath, err := utils.VolumeIDToFilePath(volumeID, volumeBasePath)
      if err != nil {
          return nil, status.Errorf(codes.Internal, "failed to generate file path: %v", err)
      }

      // Restore: create new volume from snapshot via RDS
      restoreOpts := rds.CreateVolumeOptions{
          Slot:          volumeID,
          FilePath:      filePath,
          FileSizeBytes: requiredBytes,
          NVMETCPPort:   nvmePort,
          NVMETCPNQN:    nqn,
      }

      if err := cs.driver.rdsClient.RestoreSnapshot(snapshotID, restoreOpts); err != nil {
          if stderrors.Is(err, utils.ErrConnectionFailed) || stderrors.Is(err, utils.ErrOperationTimeout) {
              return nil, status.Errorf(codes.Unavailable, "RDS unavailable: %v", err)
          }
          return nil, status.Errorf(codes.Internal, "failed to restore snapshot: %v", err)
      }

      klog.V(2).Infof("Restored volume %s from snapshot %s", volumeID, snapshotID)

      return &csi.CreateVolumeResponse{
          Volume: &csi.Volume{
              VolumeId:      volumeID,
              CapacityBytes: requiredBytes,
              VolumeContext: map[string]string{
                  "rdsAddress":              cs.getRDSAddress(params),
                  "nvmeAddress":             cs.getNVMEAddress(params),
                  "nvmePort":                fmt.Sprintf("%d", nvmePort),
                  "nqn":                     nqn,
                  "volumePath":              filePath,
                  "ctrlLossTmo":             fmt.Sprintf("%d", nvmeParams.CtrlLossTmo),
                  "reconnectDelay":          fmt.Sprintf("%d", nvmeParams.ReconnectDelay),
                  "keepAliveTmo":            fmt.Sprintf("%d", nvmeParams.KeepAliveTmo),
                  "migrationTimeoutSeconds": fmt.Sprintf("%.0f", migrationTimeout.Seconds()),
              },
              ContentSource: &csi.VolumeContentSource{
                  Type: &csi.VolumeContentSource_Snapshot{
                      Snapshot: &csi.VolumeContentSource_SnapshotSource{
                          SnapshotId: snapshotID,
                      },
                  },
              },
          },
      }, nil
  }
  ```

  IMPORTANT: The response includes `ContentSource` to indicate this volume was created from a snapshot. This is required by the CSI spec for proper tracking.
  </action>
  <verify>
  Run `go build ./pkg/driver/...` to verify compilation. Run `go vet ./pkg/driver/...`. Run `go test ./pkg/driver/... -count=1` to verify existing tests still pass.
  </verify>
  <done>ListSnapshots with pagination and CreateVolume from snapshot restore both implemented. CreateVolume properly handles VolumeContentSource.Snapshot. Volume response includes ContentSource reference.</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles without errors
- `go test ./pkg/driver/... -count=1` passes
- ListSnapshots returns empty response for non-existent snapshot (not error)
- ListSnapshots pagination: starting_token validated, next_token set when more entries exist
- ListSnapshots filters by source_volume_id correctly
- ListSnapshots returns ABORTED for invalid starting_token
- CreateVolume with VolumeContentSource.Snapshot calls RestoreSnapshot
- CreateVolume from snapshot returns NOT_FOUND for missing snapshot
- CreateVolume from snapshot enforces minimum size >= snapshot size
- Response includes ContentSource field
</verification>

<success_criteria>
1. ListSnapshots implements full CSI-compliant pagination with integer tokens
2. ListSnapshots handles single snapshot lookup, source volume filtering, and empty results
3. CreateVolume detects VolumeContentSource and routes to snapshot restore
4. Snapshot restore validates snapshot exists, generates NQN/path, calls RestoreSnapshot
5. Response includes ContentSource for proper Kubernetes tracking
6. Full project compiles and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/26-volume-snapshots/26-04-SUMMARY.md`
</output>
