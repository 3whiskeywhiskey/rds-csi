---
phase: 26-volume-snapshots
plan: 03
type: execute
wave: 3
depends_on: ["26-01", "26-02"]
files_modified:
  - pkg/driver/driver.go
  - pkg/driver/controller.go
autonomous: true

must_haves:
  truths:
    - "ControllerGetCapabilities advertises CREATE_DELETE_SNAPSHOT and LIST_SNAPSHOTS capabilities"
    - "CreateSnapshot creates Btrfs snapshot via RDS client and returns snapshot ID, source volume ID, creation time, size, and ready_to_use=true"
    - "CreateSnapshot is idempotent: same name + same source returns existing snapshot"
    - "CreateSnapshot returns AlreadyExists when name matches but source volume differs"
    - "DeleteSnapshot removes snapshot via RDS client and returns success"
    - "DeleteSnapshot returns success (not error) for non-existent snapshots"
  artifacts:
    - path: "pkg/driver/driver.go"
      provides: "CREATE_DELETE_SNAPSHOT and LIST_SNAPSHOTS capability registration"
      contains: "CREATE_DELETE_SNAPSHOT"
    - path: "pkg/driver/controller.go"
      provides: "CreateSnapshot and DeleteSnapshot RPC implementations"
      contains: "CreateSnapshotResponse"
  key_links:
    - from: "pkg/driver/controller.go"
      to: "pkg/rds/client.go"
      via: "cs.driver.rdsClient.CreateSnapshot/DeleteSnapshot/GetSnapshot"
      pattern: "rdsClient\\..*Snapshot"
    - from: "pkg/driver/controller.go"
      to: "pkg/utils/snapshotid.go"
      via: "SnapshotNameToID for idempotent ID generation"
      pattern: "SnapshotNameToID"
    - from: "pkg/driver/driver.go"
      to: "csi.ControllerServiceCapability_RPC_CREATE_DELETE_SNAPSHOT"
      via: "Capability registration in addControllerServiceCapabilities"
      pattern: "CREATE_DELETE_SNAPSHOT"
---

<objective>
Implement CreateSnapshot and DeleteSnapshot CSI controller RPCs and register snapshot capabilities.

Purpose: These are the core snapshot lifecycle operations. CreateSnapshot allows users to capture volume state; DeleteSnapshot allows cleanup. Capability advertisement tells Kubernetes this driver supports snapshots.
Output: Working CreateSnapshot/DeleteSnapshot RPCs in controller.go, snapshot capabilities registered in driver.go.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-volume-snapshots/26-CONTEXT.md
@.planning/phases/26-volume-snapshots/26-RESEARCH.md
@.planning/phases/26-volume-snapshots/26-01-SUMMARY.md
@.planning/phases/26-volume-snapshots/26-02-SUMMARY.md
@pkg/driver/driver.go
@pkg/driver/controller.go
@pkg/rds/client.go
@pkg/rds/types.go
@pkg/utils/snapshotid.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register snapshot capabilities in driver.go</name>
  <files>pkg/driver/driver.go</files>
  <action>
  In `pkg/driver/driver.go`, modify the `addControllerServiceCapabilities()` function to add two new capabilities after the existing PUBLISH_UNPUBLISH_VOLUME capability:

  ```go
  {
      Type: &csi.ControllerServiceCapability_Rpc{
          Rpc: &csi.ControllerServiceCapability_RPC{
              Type: csi.ControllerServiceCapability_RPC_CREATE_DELETE_SNAPSHOT,
          },
      },
  },
  {
      Type: &csi.ControllerServiceCapability_Rpc{
          Rpc: &csi.ControllerServiceCapability_RPC{
              Type: csi.ControllerServiceCapability_RPC_LIST_SNAPSHOTS,
          },
      },
  },
  ```

  This is a minimal change -- just two new entries in the capabilities slice. No other changes to driver.go.
  </action>
  <verify>
  Run `go build ./pkg/driver/...` to verify compilation.
  </verify>
  <done>CREATE_DELETE_SNAPSHOT and LIST_SNAPSHOTS capabilities registered in addControllerServiceCapabilities.</done>
</task>

<task type="auto">
  <name>Task 2: Implement CreateSnapshot and DeleteSnapshot RPCs</name>
  <files>pkg/driver/controller.go</files>
  <action>
  Replace the existing stub CreateSnapshot and DeleteSnapshot methods in controller.go with full implementations. Add required imports: `"google.golang.org/protobuf/types/known/timestamppb"` and ensure `"git.srvlab.io/whiskey/rds-csi-driver/pkg/utils"` is imported.

  **CreateSnapshot implementation:**

  ```go
  func (cs *ControllerServer) CreateSnapshot(ctx context.Context, req *csi.CreateSnapshotRequest) (*csi.CreateSnapshotResponse, error) {
      klog.V(4).Infof("CreateSnapshot CSI call for name=%s source=%s", req.GetName(), req.GetSourceVolumeId())

      // 1. Validate request
      if req.GetName() == "" {
          return nil, status.Error(codes.InvalidArgument, "snapshot name is required")
      }
      if req.GetSourceVolumeId() == "" {
          return nil, status.Error(codes.InvalidArgument, "source volume ID is required")
      }

      sourceVolumeID := req.GetSourceVolumeId()

      // Validate source volume ID format
      if err := utils.ValidateVolumeID(sourceVolumeID); err != nil {
          return nil, status.Errorf(codes.InvalidArgument, "invalid source volume ID: %v", err)
      }

      // Safety check: ensure RDS client is initialized
      if cs.driver == nil || cs.driver.rdsClient == nil {
          return nil, status.Error(codes.Internal, "RDS client not initialized")
      }

      // 2. Generate deterministic snapshot ID from name (for idempotency)
      snapshotID := utils.SnapshotNameToID(req.GetName())

      // 3. Check idempotency: does snapshot with this ID already exist?
      existingSnapshot, err := cs.driver.rdsClient.GetSnapshot(snapshotID)
      if err == nil {
          // Snapshot exists -- check if same source volume (idempotent) or different (conflict)
          if existingSnapshot.SourceVolume == sourceVolumeID {
              klog.V(2).Infof("Snapshot %s already exists for source %s (idempotent)", snapshotID, sourceVolumeID)
              return &csi.CreateSnapshotResponse{
                  Snapshot: &csi.Snapshot{
                      SnapshotId:     snapshotID,
                      SourceVolumeId: existingSnapshot.SourceVolume,
                      CreationTime:   timestamppb.New(existingSnapshot.CreatedAt),
                      SizeBytes:      existingSnapshot.FileSizeBytes,
                      ReadyToUse:     true,
                  },
              }, nil
          }
          return nil, status.Errorf(codes.AlreadyExists,
              "snapshot %s already exists with different source volume (existing: %s, requested: %s)",
              snapshotID, existingSnapshot.SourceVolume, sourceVolumeID)
      }

      // 4. Verify source volume exists on RDS
      sourceVolume, err := cs.driver.rdsClient.GetVolume(sourceVolumeID)
      if err != nil {
          if _, ok := err.(*rds.VolumeNotFoundError); ok {
              return nil, status.Errorf(codes.NotFound, "source volume %s not found", sourceVolumeID)
          }
          return nil, status.Errorf(codes.Internal, "failed to get source volume: %v", err)
      }

      // 5. Determine Btrfs filesystem label
      // Use the StorageClass parameter or derive from volume base path
      // The FSLabel needs to be discoverable -- for now use a configurable approach
      // Default: extract from volume path or use StorageClass parameter
      fsLabel := cs.getBtrfsFSLabel(req.GetParameters())

      // 6. Create snapshot via RDS
      createOpts := rds.CreateSnapshotOptions{
          Name:         snapshotID,
          SourceVolume: sourceVolumeID,
          FSLabel:      fsLabel,
      }

      snapshotInfo, err := cs.driver.rdsClient.CreateSnapshot(createOpts)
      if err != nil {
          // Map connection errors to Unavailable
          if stderrors.Is(err, utils.ErrConnectionFailed) || stderrors.Is(err, utils.ErrOperationTimeout) {
              return nil, status.Errorf(codes.Unavailable, "RDS unavailable: %v", err)
          }
          return nil, status.Errorf(codes.Internal, "failed to create snapshot: %v", err)
      }

      klog.V(2).Infof("Created snapshot %s from volume %s", snapshotID, sourceVolumeID)

      // 7. Return response
      // Btrfs snapshots are instant (CoW), so ready_to_use is always true
      return &csi.CreateSnapshotResponse{
          Snapshot: &csi.Snapshot{
              SnapshotId:     snapshotID,
              SourceVolumeId: sourceVolumeID,
              CreationTime:   timestamppb.New(snapshotInfo.CreatedAt),
              SizeBytes:      sourceVolume.FileSizeBytes,
              ReadyToUse:     true,
          },
      }, nil
  }
  ```

  Add helper method for Btrfs filesystem label discovery:
  ```go
  // getBtrfsFSLabel determines the Btrfs filesystem label for snapshot operations.
  // Checks snapshot parameters first, then falls back to extracting from volume base path.
  func (cs *ControllerServer) getBtrfsFSLabel(params map[string]string) string {
      // Check for explicit parameter
      if label, ok := params["btrfsFSLabel"]; ok && label != "" {
          return label
      }
      // Default: use "storage-pool" derived from the volume base path
      // The base path is typically /storage-pool/metal-csi, and the Btrfs FS label
      // corresponds to the mount point name
      return "storage-pool"
  }
  ```

  **DeleteSnapshot implementation:**

  ```go
  func (cs *ControllerServer) DeleteSnapshot(ctx context.Context, req *csi.DeleteSnapshotRequest) (*csi.DeleteSnapshotResponse, error) {
      snapshotID := req.GetSnapshotId()
      klog.V(4).Infof("DeleteSnapshot CSI call for %s", snapshotID)

      // 1. Validate request
      if snapshotID == "" {
          return nil, status.Error(codes.InvalidArgument, "snapshot ID is required")
      }

      // Validate snapshot ID format
      if err := utils.ValidateSnapshotID(snapshotID); err != nil {
          return nil, status.Errorf(codes.InvalidArgument, "invalid snapshot ID: %v", err)
      }

      // Safety check
      if cs.driver == nil || cs.driver.rdsClient == nil {
          return nil, status.Error(codes.Internal, "RDS client not initialized")
      }

      // 2. Delete snapshot via RDS (idempotent -- RDS client returns nil for not-found)
      if err := cs.driver.rdsClient.DeleteSnapshot(snapshotID); err != nil {
          // Map connection errors
          if stderrors.Is(err, utils.ErrConnectionFailed) || stderrors.Is(err, utils.ErrOperationTimeout) {
              return nil, status.Errorf(codes.Unavailable, "RDS unavailable: %v", err)
          }
          return nil, status.Errorf(codes.Internal, "failed to delete snapshot: %v", err)
      }

      klog.V(2).Infof("Deleted snapshot %s", snapshotID)
      return &csi.DeleteSnapshotResponse{}, nil
  }
  ```

  IMPORTANT: The `timestamppb` import is from `"google.golang.org/protobuf/types/known/timestamppb"` which is already in go.mod (used by CSI spec protobuf). Also make sure the `rds` package import is available for the VolumeNotFoundError type assertion.
  </action>
  <verify>
  Run `go build ./pkg/driver/...` to verify compilation. Run `go vet ./pkg/driver/...`. Run existing `go test ./pkg/driver/... -count=1` to verify nothing breaks.
  </verify>
  <done>CreateSnapshot and DeleteSnapshot RPCs implemented with full validation, idempotency, error mapping, and Btrfs FS label resolution. Capabilities registered. All compile cleanly.</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles without errors
- `go test ./pkg/driver/... -count=1` passes
- CreateSnapshot validates name, source volume ID, checks idempotency, calls RDS client, returns Snapshot proto
- CreateSnapshot returns AlreadyExists for name collision with different source
- DeleteSnapshot validates ID, calls RDS client, returns empty response
- DeleteSnapshot returns success (not error) for non-existent snapshots
- ControllerGetCapabilities includes CREATE_DELETE_SNAPSHOT and LIST_SNAPSHOTS
</verification>

<success_criteria>
1. CREATE_DELETE_SNAPSHOT and LIST_SNAPSHOTS capabilities advertised
2. CreateSnapshot creates snapshot via RDS and returns proper CSI response with timestamppb
3. CreateSnapshot idempotency works (same name + source = return existing)
4. DeleteSnapshot idempotent (not found = success)
5. Error mapping follows existing patterns (Unavailable for connection errors)
6. Full project compiles and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/26-volume-snapshots/26-03-SUMMARY.md`
</output>
