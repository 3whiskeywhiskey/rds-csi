---
phase: 20-test-coverage-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/rds/ssh_client_test.go
  - pkg/rds/client_test.go
autonomous: true

must_haves:
  truths:
    - "SSH client connection lifecycle is tested (connect, disconnect, reconnect)"
    - "SSH command execution with retry logic is tested"
    - "SSH error scenarios return appropriate sentinel errors"
    - "NewClient factory routes to correct protocol implementation"
  artifacts:
    - path: "pkg/rds/ssh_client_test.go"
      provides: "SSH client unit tests"
      min_lines: 200
    - path: "pkg/rds/client_test.go"
      provides: "Client factory tests"
      min_lines: 50
  key_links:
    - from: "pkg/rds/ssh_client_test.go"
      to: "pkg/rds/ssh_client.go"
      via: "unit tests cover newSSHClient, Connect, runCommand, runCommandWithRetry"
      pattern: "Test.*SSH|Test.*Retry|Test.*Connect"
---

<objective>
Test the RDS SSH client package which currently has 0% coverage on connection and command execution code paths.

Purpose: SSH client is the control plane for all volume operations - untested connection failures, retry logic, and error handling could cause data loss or orphaned volumes in production.

Output: Comprehensive test file pkg/rds/ssh_client_test.go covering connection lifecycle, command execution, retry logic, and error classification.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-test-coverage-expansion/20-RESEARCH.md

@pkg/rds/ssh_client.go
@pkg/rds/client.go
@pkg/rds/mock.go
@pkg/rds/commands_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSH client unit tests with mock patterns</name>
  <files>pkg/rds/ssh_client_test.go</files>
  <action>
Create comprehensive unit tests for pkg/rds/ssh_client.go covering:

1. **newSSHClient tests** (table-driven):
   - Valid config with all fields returns client
   - Missing address returns error
   - Missing user returns error
   - Default port (22) when not specified
   - Default timeout (10s) when not specified
   - Invalid HostKeyCallback type returns error
   - Custom HostKeyCallback is used when provided

2. **isRetryableError tests** (table-driven):
   - nil error returns false
   - Network timeout returns true
   - io.EOF returns true
   - "not enough space" returns false
   - "invalid parameter" returns false
   - "no such item" returns false
   - "authentication failed" returns false
   - Generic error returns true (retryable by default)

3. **parseHostKey tests** (table-driven):
   - Valid OpenSSH ed25519 public key parses successfully
   - Valid OpenSSH RSA public key parses successfully
   - Invalid key data returns error
   - Empty key data returns error

4. **containsString and indexString tests**:
   - Basic substring matching works
   - Case sensitivity is maintained
   - Edge cases (empty strings, full match)

Use existing test patterns from pkg/rds/commands_test.go:
- Table-driven tests with t.Run()
- testify assertions NOT required (use standard testing patterns from existing tests)
- Clear test names describing scenario

Note: Do NOT test Connect(), runCommand(), runCommandWithRetry() directly as they require a real SSH connection. Those will be covered in plan 04 via command execution tests with mocks.
  </action>
  <verify>
```bash
go test -v -run "TestNewSSHClient|TestIsRetryableError|TestParseHostKey|TestContainsString|TestIndexString" ./pkg/rds/...
```
All tests pass.
  </verify>
  <done>
- newSSHClient validates config correctly (6+ test cases)
- isRetryableError classifies errors correctly (8+ test cases)
- parseHostKey handles valid/invalid keys (4+ test cases)
- Helper functions tested (4+ test cases)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create client factory tests</name>
  <files>pkg/rds/client_test.go</files>
  <action>
Create unit tests for pkg/rds/client.go NewClient factory:

1. **NewClient protocol routing tests** (table-driven):
   - Empty protocol defaults to "ssh"
   - Explicit "ssh" protocol creates SSH client
   - "api" protocol returns "not yet implemented" error
   - Unknown protocol returns "unsupported protocol" error

2. **NewClient validation passthrough**:
   - Invalid SSH config (missing address) returns error from newSSHClient
   - Invalid SSH config (missing user) returns error from newSSHClient

Use minimal ClientConfig for each test - only set fields relevant to the test case.

Pattern from existing tests:
```go
func TestNewClient(t *testing.T) {
    tests := []struct {
        name      string
        config    ClientConfig
        expectErr bool
        errMsg    string
    }{
        // test cases
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            _, err := NewClient(tt.config)
            // assertions
        })
    }
}
```
  </action>
  <verify>
```bash
go test -v -run "TestNewClient" ./pkg/rds/...
```
All tests pass.
  </verify>
  <done>
- NewClient routes to SSH implementation by default
- NewClient returns appropriate errors for unsupported protocols
- NewClient passes validation errors from underlying implementations
  </done>
</task>

</tasks>

<verification>
Run full RDS package tests:
```bash
go test -v ./pkg/rds/...
```

Check coverage improvement:
```bash
go test -coverprofile=/tmp/rds-cov.out ./pkg/rds/... && go tool cover -func=/tmp/rds-cov.out | grep -E "(ssh_client|client\.go)"
```

Expected: ssh_client.go and client.go coverage > 0% (specific functions like newSSHClient, isRetryableError, parseHostKey should show >80%)
</verification>

<success_criteria>
1. All new tests pass
2. No test flakiness (run 3 times consistently)
3. Coverage on newSSHClient > 80%
4. Coverage on isRetryableError = 100%
5. Coverage on parseHostKey > 80%
6. Coverage on NewClient > 80%
</success_criteria>

<output>
After completion, create `.planning/phases/20-test-coverage-expansion/20-01-SUMMARY.md`
</output>
