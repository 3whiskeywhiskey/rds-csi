---
phase: 20-test-coverage-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/rds/ssh_client_test.go
  - pkg/rds/client_test.go
autonomous: true

must_haves:
  truths:
    - "SSH client connection lifecycle is tested (connect, disconnect, reconnect)"
    - "SSH command execution with retry logic is tested"
    - "SSH error scenarios return appropriate sentinel errors"
    - "NewClient factory routes to correct protocol implementation"
  artifacts:
    - path: "pkg/rds/ssh_client_test.go"
      provides: "SSH client unit tests"
      min_lines: 200
    - path: "pkg/rds/client_test.go"
      provides: "Client factory tests"
      min_lines: 50
  key_links:
    - from: "pkg/rds/ssh_client_test.go"
      to: "pkg/rds/ssh_client.go"
      via: "unit tests cover newSSHClient, Connect, runCommand, runCommandWithRetry via mock SSH server"
      pattern: "TestSSHClientConnect|TestSSHClientRunCommand|TestSSHClientRunCommandWithRetry"
    - from: "pkg/rds/ssh_client_test.go"
      to: "mock SSH server"
      via: "startMockSSHServer helper creates in-process SSH server for testing"
      pattern: "startMockSSHServer|mockSSHServer"
---

<objective>
Test the RDS SSH client package which currently has 0% coverage on connection and command execution code paths.

Purpose: SSH client is the control plane for all volume operations - untested connection failures, retry logic, and error handling could cause data loss or orphaned volumes in production.

Output: Comprehensive test file pkg/rds/ssh_client_test.go covering connection lifecycle, command execution, retry logic, and error classification.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-test-coverage-expansion/20-RESEARCH.md

@pkg/rds/ssh_client.go
@pkg/rds/client.go
@pkg/rds/mock.go
@pkg/rds/commands_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSH client unit tests with mock SSH server</name>
  <files>pkg/rds/ssh_client_test.go</files>
  <action>
Create comprehensive unit tests for pkg/rds/ssh_client.go covering:

**Part A: Pure function tests (no SSH connection needed)**

1. **newSSHClient tests** (table-driven):
   - Valid config with all fields returns client
   - Missing address returns error
   - Missing user returns error
   - Default port (22) when not specified
   - Default timeout (10s) when not specified
   - Invalid HostKeyCallback type returns error
   - Custom HostKeyCallback is used when provided

2. **isRetryableError tests** (table-driven):
   - nil error returns false
   - Network timeout returns true
   - io.EOF returns true
   - "not enough space" returns false
   - "invalid parameter" returns false
   - "no such item" returns false
   - "authentication failed" returns false
   - Generic error returns true (retryable by default)

3. **parseHostKey tests** (table-driven):
   - Valid OpenSSH ed25519 public key parses successfully
   - Valid OpenSSH RSA public key parses successfully
   - Invalid key data returns error
   - Empty key data returns error

4. **containsString and indexString tests**:
   - Basic substring matching works
   - Case sensitivity is maintained
   - Edge cases (empty strings, full match)

**Part B: SSH mock server tests for Connect/runCommand/runCommandWithRetry**

Use `gliderlabs/ssh` library (already a transitive dependency via golang.org/x/crypto/ssh) to create an in-process mock SSH server:

5. **TestSSHClientConnect** - Test connection lifecycle:
```go
func TestSSHClientConnect(t *testing.T) {
    // Start mock SSH server that accepts any connection
    srv := startMockSSHServer(t, func(s ssh.Session) {
        io.WriteString(s, "connected")
        s.Exit(0)
    })
    defer srv.Close()

    client, err := newSSHClient(ClientConfig{
        Address:            srv.Host,
        Port:               srv.Port,
        User:               "admin",
        InsecureSkipVerify: true,
    })
    require.NoError(t, err)

    err = client.Connect()
    require.NoError(t, err)
    assert.True(t, client.IsConnected())

    err = client.Close()
    require.NoError(t, err)
    assert.False(t, client.IsConnected())
}
```

6. **TestSSHClientRunCommand** - Test command execution:
```go
func TestSSHClientRunCommand(t *testing.T) {
    expectedOutput := "type=file slot=\"pvc-test\""
    srv := startMockSSHServer(t, func(s ssh.Session) {
        cmd := s.Command()
        if strings.Contains(cmd[0], "/disk print") {
            io.WriteString(s, expectedOutput)
            s.Exit(0)
        } else {
            io.WriteString(s.Stderr(), "unknown command")
            s.Exit(1)
        }
    })
    defer srv.Close()

    client := createConnectedTestClient(t, srv)
    output, err := client.runCommand("/disk print")
    require.NoError(t, err)
    assert.Contains(t, output, expectedOutput)
}
```

7. **TestSSHClientRunCommandWithRetry** - Test retry logic:
```go
func TestSSHClientRunCommandWithRetry(t *testing.T) {
    attemptCount := 0
    srv := startMockSSHServer(t, func(s ssh.Session) {
        attemptCount++
        if attemptCount < 2 {
            // Simulate transient error
            s.Exit(1)
            return
        }
        io.WriteString(s, "success")
        s.Exit(0)
    })
    defer srv.Close()

    client := createConnectedTestClient(t, srv)
    output, err := client.runCommandWithRetry("/disk print", 3)
    require.NoError(t, err)
    assert.Equal(t, 2, attemptCount)
    assert.Contains(t, output, "success")
}
```

Create helper functions:
- `startMockSSHServer(t *testing.T, handler func(ssh.Session)) *mockSSHServer`
- `createConnectedTestClient(t *testing.T, srv *mockSSHServer) *sshClient`

Use existing test patterns from pkg/rds/commands_test.go:
- Table-driven tests with t.Run()
- testify assertions for readability
- Clear test names describing scenario
  </action>
  <verify>
```bash
go test -v -run "TestNewSSHClient|TestIsRetryableError|TestParseHostKey|TestContainsString|TestIndexString|TestSSHClientConnect|TestSSHClientRunCommand|TestSSHClientRunCommandWithRetry" ./pkg/rds/...
```
All tests pass.
  </verify>
  <done>
- newSSHClient validates config correctly (6+ test cases)
- isRetryableError classifies errors correctly (8+ test cases)
- parseHostKey handles valid/invalid keys (4+ test cases)
- Helper functions tested (4+ test cases)
- Connect/Close/IsConnected lifecycle tested via mock SSH server
- runCommand tested via mock SSH server with RouterOS-style responses
- runCommandWithRetry tested with transient failure then success scenario
  </done>
</task>

<task type="auto">
  <name>Task 2: Create client factory tests</name>
  <files>pkg/rds/client_test.go</files>
  <action>
Create unit tests for pkg/rds/client.go NewClient factory:

1. **NewClient protocol routing tests** (table-driven):
   - Empty protocol defaults to "ssh"
   - Explicit "ssh" protocol creates SSH client
   - "api" protocol returns "not yet implemented" error
   - Unknown protocol returns "unsupported protocol" error

2. **NewClient validation passthrough**:
   - Invalid SSH config (missing address) returns error from newSSHClient
   - Invalid SSH config (missing user) returns error from newSSHClient

Use minimal ClientConfig for each test - only set fields relevant to the test case.

Pattern from existing tests:
```go
func TestNewClient(t *testing.T) {
    tests := []struct {
        name      string
        config    ClientConfig
        expectErr bool
        errMsg    string
    }{
        // test cases
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            _, err := NewClient(tt.config)
            // assertions
        })
    }
}
```
  </action>
  <verify>
```bash
go test -v -run "TestNewClient" ./pkg/rds/...
```
All tests pass.
  </verify>
  <done>
- NewClient routes to SSH implementation by default
- NewClient returns appropriate errors for unsupported protocols
- NewClient passes validation errors from underlying implementations
  </done>
</task>

</tasks>

<verification>
Run full RDS package tests:
```bash
go test -v ./pkg/rds/...
```

Check coverage improvement:
```bash
go test -coverprofile=/tmp/rds-cov.out ./pkg/rds/... && go tool cover -func=/tmp/rds-cov.out | grep -E "(ssh_client|client\.go)"
```

Expected: ssh_client.go coverage >50% (specific functions like newSSHClient, isRetryableError, parseHostKey, Connect, runCommand, runCommandWithRetry should show >60%). client.go coverage >80%.
</verification>

<success_criteria>
1. All new tests pass
2. No test flakiness (run 3 times consistently)
3. Coverage on newSSHClient > 80%
4. Coverage on isRetryableError = 100%
5. Coverage on parseHostKey > 80%
6. Coverage on NewClient > 80%
7. Coverage on Connect > 60% (via mock SSH server)
8. Coverage on runCommand > 60% (via mock SSH server)
9. Coverage on runCommandWithRetry > 60% (via mock SSH server)
</success_criteria>

<output>
After completion, create `.planning/phases/20-test-coverage-expansion/20-01-SUMMARY.md`
</output>
