---
phase: 20-test-coverage-expansion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/mount/mount_test.go
autonomous: true

must_haves:
  truths:
    - "ForceUnmount error paths are tested (mount in use, lazy unmount fallback)"
    - "ResizeFilesystem error paths are tested (resize2fs failures, xfs_growfs failures)"
    - "IsMountInUse correctly identifies processes using mount point"
    - "Mount error scenarios return informative errors"
  artifacts:
    - path: "pkg/mount/mount_test.go"
      provides: "Expanded mount package tests"
      contains: "TestForceUnmount|TestResizeFilesystem|TestIsMountInUse"
  key_links:
    - from: "pkg/mount/mount_test.go"
      to: "pkg/mount/mount.go"
      via: "unit tests cover ForceUnmount, ResizeFilesystem, IsMountInUse"
      pattern: "TestForceUnmount|TestResizeFilesystem|TestIsMountInUse"
---

<objective>
Expand mount package test coverage to cover error paths for ForceUnmount (0%), ResizeFilesystem (0%), and IsMountInUse (0%).

Purpose: Mount operations are critical data plane operations - untested error paths could leave volumes in inconsistent states, cause data corruption, or create mount storms.

Output: Expanded pkg/mount/mount_test.go with comprehensive error path coverage using existing mockExecCommand pattern.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-test-coverage-expansion/20-RESEARCH.md

@pkg/mount/mount.go
@pkg/mount/mount_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ForceUnmount and IsMountInUse tests</name>
  <files>pkg/mount/mount_test.go</files>
  <action>
Add tests to existing pkg/mount/mount_test.go for ForceUnmount and IsMountInUse:

1. **TestIsMountInUse** (table-driven):
   - Mount not in use (fuser returns exit 1, no PIDs)
   - Mount in use (fuser returns PIDs)
   - Fuser command not found (falls back gracefully)
   - Invalid path returns error

Use mockExecCommand pattern already in mount_test.go:
```go
func TestIsMountInUse(t *testing.T) {
    tests := []struct {
        name        string
        fuserOutput string
        fuserExit   int
        expected    bool
        expectError bool
    }{
        {
            name:        "mount not in use",
            fuserOutput: "",
            fuserExit:   1,  // fuser returns 1 when no processes found
            expected:    false,
            expectError: false,
        },
        {
            name:        "mount in use by single process",
            fuserOutput: "1234",
            fuserExit:   0,
            expected:    true,
            expectError: false,
        },
        {
            name:        "mount in use by multiple processes",
            fuserOutput: "1234 5678 9012",
            fuserExit:   0,
            expected:    true,
            expectError: false,
        },
    }
    // ... implementation
}
```

2. **TestForceUnmount** (table-driven):
   - Normal unmount succeeds (not in use)
   - Mount in use, refuses to force unmount (returns error with PIDs)
   - Lazy unmount fallback when normal unmount fails
   - Target not a mount point (returns success - idempotent)

Note: ForceUnmount has complex logic:
1. Check if mount is in use via IsMountInUse
2. If in use, return error listing PIDs (safety feature)
3. If not in use, try normal unmount
4. If normal fails, try lazy unmount (umount -l)

Create helper to mock multiple exec calls in sequence:
```go
// mockMultiExecCommand returns different results for sequential calls
func mockMultiExecCommand(results []struct{ stdout, stderr string; exitCode int }) func(string, ...string) *exec.Cmd {
    callCount := 0
    return func(command string, args ...string) *exec.Cmd {
        if callCount >= len(results) {
            callCount = len(results) - 1 // repeat last result
        }
        r := results[callCount]
        callCount++
        return mockExecCommand(r.stdout, r.stderr, r.exitCode)(command, args...)
    }
}
```
  </action>
  <verify>
```bash
go test -v -run "TestIsMountInUse|TestForceUnmount" ./pkg/mount/...
```
All tests pass.
  </verify>
  <done>
- IsMountInUse tests cover: not in use, in use, error scenarios (4+ cases)
- ForceUnmount tests cover: success, mount in use error, lazy fallback (4+ cases)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ResizeFilesystem tests</name>
  <files>pkg/mount/mount_test.go</files>
  <action>
Add tests for ResizeFilesystem to pkg/mount/mount_test.go:

1. **TestResizeFilesystem** (table-driven):
   - ext4 resize succeeds (resize2fs returns 0)
   - xfs resize succeeds (xfs_growfs returns 0)
   - ext4 resize fails (resize2fs returns error)
   - xfs resize fails (xfs_growfs returns error)
   - Unsupported filesystem type returns error
   - Device not found returns error

The ResizeFilesystem function:
1. Detects filesystem type via blkid
2. Calls resize2fs for ext4 or xfs_growfs for xfs
3. Returns error for unsupported types

Test pattern:
```go
func TestResizeFilesystem(t *testing.T) {
    tests := []struct {
        name        string
        device      string
        blkidOutput string  // filesystem type detection
        blkidExit   int
        resizeExit  int     // resize2fs or xfs_growfs exit code
        expectError bool
        errContains string
    }{
        {
            name:        "ext4 resize success",
            device:      "/dev/nvme0n1",
            blkidOutput: "ext4",
            blkidExit:   0,
            resizeExit:  0,
            expectError: false,
        },
        {
            name:        "xfs resize success",
            device:      "/dev/nvme0n1",
            blkidOutput: "xfs",
            blkidExit:   0,
            resizeExit:  0,
            expectError: false,
        },
        {
            name:        "ext4 resize fails",
            device:      "/dev/nvme0n1",
            blkidOutput: "ext4",
            blkidExit:   0,
            resizeExit:  1,
            expectError: true,
            errContains: "resize2fs",
        },
        {
            name:        "unsupported filesystem",
            device:      "/dev/nvme0n1",
            blkidOutput: "ntfs",
            blkidExit:   0,
            expectError: true,
            errContains: "unsupported",
        },
    }
    // ... implementation using mockMultiExecCommand for blkid then resize
}
```

Use the mockMultiExecCommand helper created in Task 1 to handle sequential blkid -> resize2fs/xfs_growfs calls.
  </action>
  <verify>
```bash
go test -v -run "TestResizeFilesystem" ./pkg/mount/...
```
All tests pass.
  </verify>
  <done>
- ResizeFilesystem tests cover ext4, xfs, failure cases, unsupported types (6+ cases)
- Tests verify correct resize command is called per filesystem type
  </done>
</task>

</tasks>

<verification>
Run full mount package tests:
```bash
go test -v ./pkg/mount/...
```

Check coverage improvement:
```bash
go test -coverprofile=/tmp/mount-cov.out ./pkg/mount/... && go tool cover -func=/tmp/mount-cov.out | grep -E "(ForceUnmount|ResizeFilesystem|IsMountInUse)"
```

Expected:
- ForceUnmount coverage > 70%
- ResizeFilesystem coverage > 70%
- IsMountInUse coverage > 70%
</verification>

<success_criteria>
1. All new tests pass
2. No test flakiness
3. ForceUnmount coverage increased from 0% to >70%
4. ResizeFilesystem coverage increased from 0% to >70%
5. IsMountInUse coverage increased from 0% to >70%
6. Mount package overall coverage increased from 55.9% to >70%
</success_criteria>

<output>
After completion, create `.planning/phases/20-test-coverage-expansion/20-02-SUMMARY.md`
</output>
