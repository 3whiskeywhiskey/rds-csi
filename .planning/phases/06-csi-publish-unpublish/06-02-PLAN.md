---
phase: 06-csi-publish-unpublish
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - pkg/driver/controller.go
autonomous: true

must_haves:
  truths:
    - "ControllerPublishVolume returns success with publish_context when volume already attached to same node"
    - "ControllerPublishVolume returns FAILED_PRECONDITION (code 9) when RWO volume attached to different node"
    - "ControllerPublishVolume auto-clears stale attachments when blocking node no longer exists"
    - "ControllerUnpublishVolume returns success even if volume not currently attached"
    - "publish_context includes nvme_address, nvme_port, nvme_nqn, fs_type"
  artifacts:
    - path: "pkg/driver/controller.go"
      provides: "ControllerPublishVolume and ControllerUnpublishVolume implementations"
      contains: "TrackAttachment"
  key_links:
    - from: "pkg/driver/controller.go"
      to: "pkg/attachment/manager.go"
      via: "cs.driver.GetAttachmentManager()"
      pattern: "GetAttachmentManager"
    - from: "pkg/driver/controller.go"
      to: "pkg/driver/events.go"
      via: "PostAttachmentConflict call"
      pattern: "PostAttachmentConflict"
---

<objective>
Implement ControllerPublishVolume and ControllerUnpublishVolume to enforce ReadWriteOnce semantics.

Purpose: This is the core fencing logic that prevents multi-node attachment conflicts by tracking which node has each volume and rejecting conflicting attachment requests.
Output: Full implementations replacing the Unimplemented stubs in controller.go
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.3-ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-csi-publish-unpublish/06-CONTEXT.md
@.planning/phases/06-csi-publish-unpublish/06-RESEARCH.md

# Implementation dependencies
@pkg/driver/controller.go
@pkg/attachment/manager.go
@pkg/driver/events.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ControllerPublishVolume</name>
  <files>pkg/driver/controller.go</files>
  <action>
Replace the existing stub ControllerPublishVolume (lines ~336-338) with full implementation.

Add imports at top of file:
```go
"k8s.io/apimachinery/pkg/api/errors"
metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
```

Add helper method for node validation:
```go
// validateBlockingNodeExists checks if a node still exists in Kubernetes.
// Returns (exists, error) - if node is deleted, exists=false, error=nil.
// Used for self-healing when blocking node is deleted without cleanup.
func (cs *ControllerServer) validateBlockingNodeExists(ctx context.Context, nodeID string) (bool, error) {
    if cs.driver.k8sClient == nil {
        // No k8s client = can't validate, assume node exists (fail-closed)
        return true, nil
    }
    _, err := cs.driver.k8sClient.CoreV1().Nodes().Get(ctx, nodeID, metav1.GetOptions{})
    if err != nil {
        if errors.IsNotFound(err) {
            return false, nil // Node deleted
        }
        return false, err // API error
    }
    return true, nil
}
```

Add helper method for building publish context:
```go
// buildPublishContext creates the publish_context map with NVMe connection parameters.
// Uses snake_case keys to match existing volumeContext conventions.
func (cs *ControllerServer) buildPublishContext(volume *rds.VolumeInfo, params map[string]string) map[string]string {
    fsType := "ext4"
    if fs, ok := params[paramFSType]; ok && fs != "" {
        fsType = fs
    }

    return map[string]string{
        "nvme_address": cs.getNVMEAddress(params),
        "nvme_port":    fmt.Sprintf("%d", volume.NVMETCPPort),
        "nvme_nqn":     volume.NVMETCPNQN,
        "fs_type":      fsType,
    }
}
```

Replace ControllerPublishVolume:
```go
// ControllerPublishVolume tracks volume attachment to a node and enforces RWO semantics.
// Returns publish_context with NVMe connection parameters for NodeStageVolume.
func (cs *ControllerServer) ControllerPublishVolume(ctx context.Context, req *csi.ControllerPublishVolumeRequest) (*csi.ControllerPublishVolumeResponse, error) {
    volumeID := req.GetVolumeId()
    nodeID := req.GetNodeId()

    klog.V(2).Infof("ControllerPublishVolume called for volume %s to node %s", volumeID, nodeID)

    // Validate request
    if volumeID == "" {
        return nil, status.Error(codes.InvalidArgument, "volume ID is required")
    }
    if nodeID == "" {
        return nil, status.Error(codes.InvalidArgument, "node ID is required")
    }

    // Validate volume ID format (security: prevent injection)
    if err := utils.ValidateVolumeID(volumeID); err != nil {
        return nil, status.Errorf(codes.InvalidArgument, "invalid volume ID: %v", err)
    }

    // Verify volume exists on RDS
    volume, err := cs.driver.rdsClient.GetVolume(volumeID)
    if err != nil {
        return nil, status.Errorf(codes.NotFound, "volume %s not found: %v", volumeID, err)
    }

    // Get attachment manager
    am := cs.driver.GetAttachmentManager()
    if am == nil {
        // No attachment manager = skip tracking (single-node scenario or disabled)
        klog.V(3).Infof("Attachment manager not available, skipping tracking for volume %s", volumeID)
        return &csi.ControllerPublishVolumeResponse{
            PublishContext: cs.buildPublishContext(volume, req.GetVolumeContext()),
        }, nil
    }

    // Check existing attachment
    existing, exists := am.GetAttachment(volumeID)
    if exists {
        if existing.NodeID == nodeID {
            // CSI-01: Idempotent - already attached to same node
            klog.V(2).Infof("Volume %s already attached to node %s (idempotent)", volumeID, nodeID)
            return &csi.ControllerPublishVolumeResponse{
                PublishContext: cs.buildPublishContext(volume, req.GetVolumeContext()),
            }, nil
        }

        // CSI-06: Before rejecting, verify blocking node still exists
        nodeExists, err := cs.validateBlockingNodeExists(ctx, existing.NodeID)
        if err != nil {
            // API error - fail closed to prevent data corruption
            klog.Errorf("Failed to verify node %s existence: %v", existing.NodeID, err)
            return nil, status.Errorf(codes.Internal, "failed to verify node %s: %v", existing.NodeID, err)
        }

        if !nodeExists {
            // Node deleted - auto-clear stale attachment (self-healing)
            klog.Warningf("Volume %s attached to deleted node %s, clearing stale attachment", volumeID, existing.NodeID)
            if err := am.UntrackAttachment(ctx, volumeID); err != nil {
                klog.Warningf("Failed to clear stale attachment for volume %s: %v", volumeID, err)
                // Continue anyway - in-memory state may be stale
            }
            // Fall through to allow new attachment
        } else {
            // CSI-02: Node exists - genuine RWO conflict
            klog.Warningf("Volume %s already attached to node %s, rejecting attachment to node %s",
                volumeID, existing.NodeID, nodeID)

            // Post event for operator visibility (best effort)
            cs.postAttachmentConflictEvent(ctx, req, existing.NodeID)

            return nil, status.Errorf(codes.FailedPrecondition,
                "volume %s already attached to node %s, cannot attach to %s",
                volumeID, existing.NodeID, nodeID)
        }
    }

    // Track new attachment (uses per-volume lock internally)
    if err := am.TrackAttachment(ctx, volumeID, nodeID); err != nil {
        // Check if this is a conflict (race condition - another request won)
        if existing, exists := am.GetAttachment(volumeID); exists && existing.NodeID != nodeID {
            return nil, status.Errorf(codes.FailedPrecondition,
                "volume %s already attached to node %s, cannot attach to %s",
                volumeID, existing.NodeID, nodeID)
        }
        return nil, status.Errorf(codes.Internal, "failed to track attachment: %v", err)
    }

    klog.V(2).Infof("Successfully published volume %s to node %s", volumeID, nodeID)

    return &csi.ControllerPublishVolumeResponse{
        PublishContext: cs.buildPublishContext(volume, req.GetVolumeContext()),
    }, nil
}
```

Add helper for posting conflict event (needs EventPoster):
```go
// postAttachmentConflictEvent posts a K8s event for an attachment conflict.
// Best effort - failures are logged but don't affect the main operation.
func (cs *ControllerServer) postAttachmentConflictEvent(ctx context.Context, req *csi.ControllerPublishVolumeRequest, attachedNode string) {
    // Extract PVC info from volume context if available
    volCtx := req.GetVolumeContext()
    pvcNamespace := volCtx["csi.storage.k8s.io/pvc/namespace"]
    pvcName := volCtx["csi.storage.k8s.io/pvc/name"]

    if pvcNamespace == "" || pvcName == "" {
        klog.V(3).Infof("Cannot post attachment conflict event: PVC info not in volume context")
        return
    }

    // Create temporary EventPoster if we have k8s client
    if cs.driver.k8sClient == nil {
        return
    }

    poster := NewEventPoster(cs.driver.k8sClient)
    if err := poster.PostAttachmentConflict(ctx, pvcNamespace, pvcName, req.GetVolumeId(), req.GetNodeId(), attachedNode); err != nil {
        klog.Warningf("Failed to post attachment conflict event: %v", err)
    }
}
```

Key design decisions from CONTEXT.md:
- FAILED_PRECONDITION (code 9) for RWO conflicts
- Verify blocking node exists before rejecting (self-healing)
- Fail-closed on k8s API errors (safety over availability)
- snake_case for publish_context keys
- Post events for operator visibility
  </action>
  <verify>
Run `go build ./...` to verify syntax. Grep for "TrackAttachment" in controller.go.
  </verify>
  <done>
ControllerPublishVolume satisfies CSI-01 (idempotent same node), CSI-02 (FAILED_PRECONDITION), CSI-05 (publish_context), CSI-06 (node validation). Volume attachments are tracked and conflicts are rejected with informative errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ControllerUnpublishVolume</name>
  <files>pkg/driver/controller.go</files>
  <action>
Replace the existing stub ControllerUnpublishVolume (lines ~341-343) with full implementation.

```go
// ControllerUnpublishVolume removes volume attachment tracking for a node.
// This method is idempotent - returns success even if volume not currently attached.
func (cs *ControllerServer) ControllerUnpublishVolume(ctx context.Context, req *csi.ControllerUnpublishVolumeRequest) (*csi.ControllerUnpublishVolumeResponse, error) {
    volumeID := req.GetVolumeId()
    nodeID := req.GetNodeId()

    klog.V(2).Infof("ControllerUnpublishVolume called for volume %s from node %s", volumeID, nodeID)

    // Validate request
    if volumeID == "" {
        return nil, status.Error(codes.InvalidArgument, "volume ID is required")
    }
    // Note: nodeID can be empty for force-detach scenarios per CSI spec

    // Validate volume ID format (security: prevent injection)
    if err := utils.ValidateVolumeID(volumeID); err != nil {
        return nil, status.Errorf(codes.InvalidArgument, "invalid volume ID: %v", err)
    }

    // Get attachment manager
    am := cs.driver.GetAttachmentManager()
    if am == nil {
        // No attachment manager = nothing to untrack
        klog.V(3).Infof("Attachment manager not available, skipping untrack for volume %s", volumeID)
        return &csi.ControllerUnpublishVolumeResponse{}, nil
    }

    // CSI-03: Untrack attachment (idempotent - succeeds even if not tracked)
    if err := am.UntrackAttachment(ctx, volumeID); err != nil {
        // Log but don't fail - unpublish must be idempotent (CONTEXT.md decision)
        klog.Warningf("Error untracking attachment for volume %s: %v (returning success)", volumeID, err)
    }

    klog.V(2).Infof("Successfully unpublished volume %s", volumeID)

    return &csi.ControllerUnpublishVolumeResponse{}, nil
}
```

Key design decisions from CONTEXT.md:
- Always return success (idempotent per CSI spec)
- Log warnings for errors but don't fail
- nodeID can be empty for force-detach per CSI spec
- Validate volumeID for security
  </action>
  <verify>
Run `go build ./...` to verify syntax. Grep for "UntrackAttachment" in controller.go.
  </verify>
  <done>
ControllerUnpublishVolume satisfies CSI-03 (idempotent unpublish). Volume attachments are untracked and the method always succeeds.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` passes without errors
2. `grep -n "ControllerPublishVolume" pkg/driver/controller.go` shows implementation (not Unimplemented)
3. `grep -n "ControllerUnpublishVolume" pkg/driver/controller.go` shows implementation (not Unimplemented)
4. `grep -n "TrackAttachment" pkg/driver/controller.go` shows integration with AttachmentManager
5. `grep -n "codes.FailedPrecondition" pkg/driver/controller.go` shows RWO conflict handling
6. `grep -n "publish_context\|nvme_address\|nvme_port\|nvme_nqn" pkg/driver/controller.go` shows publish context
</verification>

<success_criteria>
- CSI-01: ControllerPublishVolume returns success when volume already attached to same node
- CSI-02: ControllerPublishVolume returns FAILED_PRECONDITION (code 9) for RWO conflicts
- CSI-03: ControllerUnpublishVolume always returns success (idempotent)
- CSI-05: publish_context includes nvme_address, nvme_port, nvme_nqn, fs_type
- CSI-06: Node existence validated before rejecting, stale attachments auto-cleared
</success_criteria>

<output>
After completion, create `.planning/phases/06-csi-publish-unpublish/06-02-SUMMARY.md`
</output>
