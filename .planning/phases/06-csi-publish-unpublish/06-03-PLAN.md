---
phase: 06-csi-publish-unpublish
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - pkg/driver/controller_test.go
autonomous: true

must_haves:
  truths:
    - "Unit tests verify idempotent publish (same node returns success)"
    - "Unit tests verify RWO conflict returns FAILED_PRECONDITION"
    - "Unit tests verify idempotent unpublish (not attached returns success)"
    - "Unit tests verify publish_context contains required fields"
    - "Unit tests verify stale attachment self-healing when node deleted"
  artifacts:
    - path: "pkg/driver/controller_test.go"
      provides: "ControllerPublishVolume and ControllerUnpublishVolume unit tests"
      contains: "TestControllerPublishVolume"
  key_links:
    - from: "pkg/driver/controller_test.go"
      to: "pkg/driver/controller.go"
      via: "ControllerServer method calls"
      pattern: "ControllerPublishVolume"
---

<objective>
Add comprehensive unit tests for ControllerPublishVolume and ControllerUnpublishVolume.

Purpose: Verify all CSI requirements (CSI-01 through CSI-06) are correctly implemented and protected from regression.
Output: Test functions in controller_test.go covering all success and error paths
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.3-ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-csi-publish-unpublish/06-CONTEXT.md
@.planning/phases/06-csi-publish-unpublish/06-RESEARCH.md

# Implementation to test
@pkg/driver/controller.go
@pkg/attachment/manager.go
@pkg/attachment/manager_test.go  # For testing patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ControllerPublishVolume and ControllerUnpublishVolume tests</name>
  <files>pkg/driver/controller_test.go</files>
  <action>
Add comprehensive unit tests for ControllerPublishVolume and ControllerUnpublishVolume. If controller_test.go doesn't exist, create it. If it exists, add to it.

Required imports:
```go
import (
    "context"
    "testing"

    "github.com/container-storage-interface/spec/lib/go/csi"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/client-go/kubernetes/fake"

    "git.srvlab.io/whiskey/rds-csi-driver/pkg/attachment"
    "git.srvlab.io/whiskey/rds-csi-driver/pkg/rds"
)
```

Add test helper to create test ControllerServer with mock dependencies:
```go
// testControllerServer creates a ControllerServer with mock RDS client and fake k8s client
func testControllerServer(t *testing.T, nodes ...*corev1.Node) (*ControllerServer, *rds.MockClient) {
    t.Helper()

    // Create fake k8s client with provided nodes
    var objects []runtime.Object
    for _, n := range nodes {
        objects = append(objects, n)
    }
    k8sClient := fake.NewSimpleClientset(objects...)

    // Create mock RDS client
    mockRDS := rds.NewMockClient()

    // Create driver with attachment manager
    driver := &Driver{
        name:              DriverName,
        version:           "test",
        rdsClient:         mockRDS,
        k8sClient:         k8sClient,
        attachmentManager: attachment.NewAttachmentManager(k8sClient),
    }
    driver.addVolumeCapabilities()

    return NewControllerServer(driver), mockRDS
}

// testNode creates a test Node object
func testNode(name string) *corev1.Node {
    return &corev1.Node{
        ObjectMeta: metav1.ObjectMeta{
            Name: name,
        },
    }
}
```

Add ControllerPublishVolume tests:

```go
func TestControllerPublishVolume_Success(t *testing.T) {
    ctx := context.Background()
    node1 := testNode("node-1")
    cs, mockRDS := testControllerServer(t, node1)

    // Add test volume to mock
    mockRDS.AddVolume(&rds.VolumeInfo{
        Slot:         "pvc-test-volume",
        FilePath:     "/storage-pool/metal-csi/pvc-test-volume.img",
        FileSizeBytes: 1073741824,
        NVMETCPPort:  4420,
        NVMETCPNQN:   "nqn.2000-02.com.mikrotik:pvc-test-volume",
    })

    req := &csi.ControllerPublishVolumeRequest{
        VolumeId: "pvc-test-volume",
        NodeId:   "node-1",
        VolumeContext: map[string]string{
            "nvmeAddress": "10.0.0.1",
        },
    }

    resp, err := cs.ControllerPublishVolume(ctx, req)
    if err != nil {
        t.Fatalf("ControllerPublishVolume failed: %v", err)
    }

    // CSI-05: Verify publish_context
    if resp.PublishContext == nil {
        t.Fatal("PublishContext is nil")
    }
    if resp.PublishContext["nvme_address"] == "" {
        t.Error("nvme_address missing from PublishContext")
    }
    if resp.PublishContext["nvme_port"] != "4420" {
        t.Errorf("nvme_port = %s, want 4420", resp.PublishContext["nvme_port"])
    }
    if resp.PublishContext["nvme_nqn"] != "nqn.2000-02.com.mikrotik:pvc-test-volume" {
        t.Errorf("nvme_nqn = %s, want nqn.2000-02.com.mikrotik:pvc-test-volume", resp.PublishContext["nvme_nqn"])
    }
    if resp.PublishContext["fs_type"] == "" {
        t.Error("fs_type missing from PublishContext")
    }
}

func TestControllerPublishVolume_Idempotent(t *testing.T) {
    // CSI-01: Same volume, same node = success
    ctx := context.Background()
    node1 := testNode("node-1")
    cs, mockRDS := testControllerServer(t, node1)

    mockRDS.AddVolume(&rds.VolumeInfo{
        Slot:         "pvc-test-volume",
        NVMETCPPort:  4420,
        NVMETCPNQN:   "nqn.2000-02.com.mikrotik:pvc-test-volume",
    })

    req := &csi.ControllerPublishVolumeRequest{
        VolumeId: "pvc-test-volume",
        NodeId:   "node-1",
    }

    // First publish
    _, err := cs.ControllerPublishVolume(ctx, req)
    if err != nil {
        t.Fatalf("First publish failed: %v", err)
    }

    // Second publish (same node) - should succeed
    resp, err := cs.ControllerPublishVolume(ctx, req)
    if err != nil {
        t.Fatalf("Second publish (idempotent) failed: %v", err)
    }
    if resp.PublishContext == nil {
        t.Error("Idempotent publish should return PublishContext")
    }
}

func TestControllerPublishVolume_RWOConflict(t *testing.T) {
    // CSI-02: Same volume, different node = FAILED_PRECONDITION
    ctx := context.Background()
    node1 := testNode("node-1")
    node2 := testNode("node-2")
    cs, mockRDS := testControllerServer(t, node1, node2)

    mockRDS.AddVolume(&rds.VolumeInfo{
        Slot:         "pvc-test-volume",
        NVMETCPPort:  4420,
        NVMETCPNQN:   "nqn.2000-02.com.mikrotik:pvc-test-volume",
    })

    // Attach to node-1
    req1 := &csi.ControllerPublishVolumeRequest{
        VolumeId: "pvc-test-volume",
        NodeId:   "node-1",
    }
    _, err := cs.ControllerPublishVolume(ctx, req1)
    if err != nil {
        t.Fatalf("First publish failed: %v", err)
    }

    // Try to attach to node-2 - should fail
    req2 := &csi.ControllerPublishVolumeRequest{
        VolumeId: "pvc-test-volume",
        NodeId:   "node-2",
    }
    _, err = cs.ControllerPublishVolume(ctx, req2)
    if err == nil {
        t.Fatal("Expected FAILED_PRECONDITION error for RWO conflict")
    }

    st, ok := status.FromError(err)
    if !ok {
        t.Fatalf("Expected gRPC status error, got: %v", err)
    }
    if st.Code() != codes.FailedPrecondition {
        t.Errorf("Expected code FailedPrecondition (9), got %v", st.Code())
    }
    if !contains(st.Message(), "node-1") {
        t.Errorf("Error message should mention blocking node, got: %s", st.Message())
    }
}

func TestControllerPublishVolume_StaleAttachmentSelfHealing(t *testing.T) {
    // CSI-06: Volume attached to deleted node = auto-clear and allow new attach
    ctx := context.Background()
    node1 := testNode("node-1")
    // node-2 does NOT exist in k8s (simulates deleted node)
    cs, mockRDS := testControllerServer(t, node1)

    mockRDS.AddVolume(&rds.VolumeInfo{
        Slot:         "pvc-test-volume",
        NVMETCPPort:  4420,
        NVMETCPNQN:   "nqn.2000-02.com.mikrotik:pvc-test-volume",
    })

    // Manually track attachment to non-existent node (simulates stale state after node deletion)
    am := cs.driver.GetAttachmentManager()
    am.TrackAttachment(ctx, "pvc-test-volume", "deleted-node")

    // Try to attach to node-1 - should succeed (self-healing)
    req := &csi.ControllerPublishVolumeRequest{
        VolumeId: "pvc-test-volume",
        NodeId:   "node-1",
    }
    resp, err := cs.ControllerPublishVolume(ctx, req)
    if err != nil {
        t.Fatalf("Expected self-healing success, got error: %v", err)
    }
    if resp.PublishContext == nil {
        t.Error("Expected PublishContext after self-healing")
    }

    // Verify attachment is now to node-1
    state, exists := am.GetAttachment("pvc-test-volume")
    if !exists {
        t.Fatal("Attachment should exist after self-healing")
    }
    if state.NodeID != "node-1" {
        t.Errorf("Attachment should be to node-1, got %s", state.NodeID)
    }
}

func TestControllerPublishVolume_VolumeNotFound(t *testing.T) {
    ctx := context.Background()
    node1 := testNode("node-1")
    cs, _ := testControllerServer(t, node1)

    // Don't add volume to mock - it won't exist

    req := &csi.ControllerPublishVolumeRequest{
        VolumeId: "pvc-nonexistent",
        NodeId:   "node-1",
    }

    _, err := cs.ControllerPublishVolume(ctx, req)
    if err == nil {
        t.Fatal("Expected NOT_FOUND error")
    }

    st, ok := status.FromError(err)
    if !ok {
        t.Fatalf("Expected gRPC status error, got: %v", err)
    }
    if st.Code() != codes.NotFound {
        t.Errorf("Expected code NotFound (5), got %v", st.Code())
    }
}

func TestControllerPublishVolume_InvalidVolumeID(t *testing.T) {
    ctx := context.Background()
    cs, _ := testControllerServer(t)

    req := &csi.ControllerPublishVolumeRequest{
        VolumeId: "", // Invalid
        NodeId:   "node-1",
    }

    _, err := cs.ControllerPublishVolume(ctx, req)
    if err == nil {
        t.Fatal("Expected INVALID_ARGUMENT error")
    }

    st, _ := status.FromError(err)
    if st.Code() != codes.InvalidArgument {
        t.Errorf("Expected code InvalidArgument (3), got %v", st.Code())
    }
}
```

Add ControllerUnpublishVolume tests:

```go
func TestControllerUnpublishVolume_Success(t *testing.T) {
    ctx := context.Background()
    node1 := testNode("node-1")
    cs, mockRDS := testControllerServer(t, node1)

    mockRDS.AddVolume(&rds.VolumeInfo{
        Slot: "pvc-test-volume",
    })

    // First publish
    am := cs.driver.GetAttachmentManager()
    am.TrackAttachment(ctx, "pvc-test-volume", "node-1")

    // Unpublish
    req := &csi.ControllerUnpublishVolumeRequest{
        VolumeId: "pvc-test-volume",
        NodeId:   "node-1",
    }

    _, err := cs.ControllerUnpublishVolume(ctx, req)
    if err != nil {
        t.Fatalf("ControllerUnpublishVolume failed: %v", err)
    }

    // Verify attachment removed
    _, exists := am.GetAttachment("pvc-test-volume")
    if exists {
        t.Error("Attachment should be removed after unpublish")
    }
}

func TestControllerUnpublishVolume_Idempotent(t *testing.T) {
    // CSI-03: Unpublish on non-attached volume = success
    ctx := context.Background()
    cs, _ := testControllerServer(t)

    // Don't attach first - just try to unpublish
    req := &csi.ControllerUnpublishVolumeRequest{
        VolumeId: "pvc-never-attached",
        NodeId:   "node-1",
    }

    // Should succeed (idempotent)
    _, err := cs.ControllerUnpublishVolume(ctx, req)
    if err != nil {
        t.Fatalf("Idempotent unpublish should succeed, got: %v", err)
    }
}

func TestControllerUnpublishVolume_InvalidVolumeID(t *testing.T) {
    ctx := context.Background()
    cs, _ := testControllerServer(t)

    req := &csi.ControllerUnpublishVolumeRequest{
        VolumeId: "", // Invalid
    }

    _, err := cs.ControllerUnpublishVolume(ctx, req)
    if err == nil {
        t.Fatal("Expected INVALID_ARGUMENT error")
    }

    st, _ := status.FromError(err)
    if st.Code() != codes.InvalidArgument {
        t.Errorf("Expected code InvalidArgument (3), got %v", st.Code())
    }
}
```

Add helper function if not already present:
```go
// contains checks if s contains substr
func contains(s, substr string) bool {
    return len(s) >= len(substr) && (s == substr || len(s) > len(substr) && indexOf(s, substr) >= 0)
}

func indexOf(s, substr string) int {
    for i := 0; i <= len(s)-len(substr); i++ {
        if s[i:i+len(substr)] == substr {
            return i
        }
    }
    return -1
}
```

Note: You may need to check if MockClient exists in pkg/rds/. If not, add a simple mock:
```go
// In pkg/rds/mock.go or directly in test file
type MockClient struct {
    volumes map[string]*VolumeInfo
}

func NewMockClient() *MockClient {
    return &MockClient{volumes: make(map[string]*VolumeInfo)}
}

func (m *MockClient) AddVolume(v *VolumeInfo) {
    m.volumes[v.Slot] = v
}

func (m *MockClient) GetVolume(volumeID string) (*VolumeInfo, error) {
    if v, ok := m.volumes[volumeID]; ok {
        return v, nil
    }
    return nil, fmt.Errorf("volume %s not found", volumeID)
}

// Implement other RDSClient interface methods as no-ops
func (m *MockClient) Connect() error                               { return nil }
func (m *MockClient) Close() error                                 { return nil }
func (m *MockClient) GetAddress() string                           { return "mock" }
func (m *MockClient) CreateVolume(opts CreateVolumeOptions) error  { return nil }
func (m *MockClient) DeleteVolume(volumeID string) error           { return nil }
func (m *MockClient) ListVolumes() ([]*VolumeInfo, error)          { return nil, nil }
func (m *MockClient) ResizeVolume(id string, size int64) error     { return nil }
func (m *MockClient) GetCapacity(path string) (*CapacityInfo, error) { return nil, nil }
```

You will need to add `"k8s.io/apimachinery/pkg/runtime"` to imports for runtime.Object.
  </action>
  <verify>
Run tests:
```bash
go test ./pkg/driver/... -v -run "TestControllerPublish\|TestControllerUnpublish" -race
```
All tests should pass. Run with -race to verify no race conditions.
  </verify>
  <done>
Unit tests verify all CSI requirements:
- CSI-01: TestControllerPublishVolume_Idempotent
- CSI-02: TestControllerPublishVolume_RWOConflict
- CSI-03: TestControllerUnpublishVolume_Idempotent
- CSI-05: TestControllerPublishVolume_Success (publish_context)
- CSI-06: TestControllerPublishVolume_StaleAttachmentSelfHealing
All tests pass with -race flag.
  </done>
</task>

</tasks>

<verification>
1. `go test ./pkg/driver/... -v -run "TestControllerPublish\|TestControllerUnpublish" -race` passes
2. All 8+ test functions execute successfully
3. No race conditions detected
4. Tests cover all CSI requirements (CSI-01 through CSI-06)
</verification>

<success_criteria>
- Test coverage for ControllerPublishVolume and ControllerUnpublishVolume
- All CSI requirements verified by tests
- Tests pass with -race flag
- Error codes verified (FAILED_PRECONDITION, NOT_FOUND, INVALID_ARGUMENT)
- Idempotency verified for both methods
</success_criteria>

<output>
After completion, create `.planning/phases/06-csi-publish-unpublish/06-03-SUMMARY.md`
</output>
