---
phase: 10-observability
plan: 03
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - pkg/attachment/manager.go
  - pkg/driver/controller.go
autonomous: true

must_haves:
  truths:
    - "Migration start triggers RecordMigrationStarted metric and PostMigrationStarted event"
    - "Source node detach triggers RecordMigrationResult(success) and PostMigrationCompleted event"
    - "Migration timeout triggers RecordMigrationResult(timeout) and PostMigrationFailed event"
  artifacts:
    - path: "pkg/attachment/manager.go"
      provides: "Metrics integration points for migration tracking"
      contains: "RecordMigrationStarted"
    - path: "pkg/driver/controller.go"
      provides: "Event posting for migration lifecycle"
      contains: "PostMigrationStarted"
  key_links:
    - from: "pkg/attachment/manager.go"
      to: "pkg/observability.Metrics"
      via: "RecordMigrationStarted call"
      pattern: "metrics\\.RecordMigrationStarted"
    - from: "pkg/driver/controller.go"
      to: "EventPoster"
      via: "PostMigrationStarted call"
      pattern: "eventPoster\\.PostMigrationStarted"
---

<objective>
Wire migration metrics and events into the attachment manager and controller.

Purpose: The metrics and events defined in plans 01 and 02 must be called at the right points in the migration lifecycle: when dual-attach starts, when migration completes successfully, and when migration times out.

Output: Metrics and events are recorded at key state transitions in pkg/attachment/manager.go and pkg/driver/controller.go.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-observability/10-RESEARCH.md

# Files to modify
@pkg/attachment/manager.go
@pkg/driver/controller.go

# Dependencies from this phase
@.planning/phases/10-observability/10-01-PLAN.md
@.planning/phases/10-observability/10-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Metrics field to AttachmentManager</name>
  <files>pkg/attachment/manager.go</files>
  <action>
Add metrics support to AttachmentManager:

1. Add field to struct:
```go
// metrics for recording migration operations (optional, can be nil)
metrics *observability.Metrics
```

2. Add import for observability package:
```go
"git.srvlab.io/whiskey/rds-csi-driver/pkg/observability"
```

3. Add SetMetrics method:
```go
// SetMetrics sets the Prometheus metrics for recording migration operations.
func (am *AttachmentManager) SetMetrics(m *observability.Metrics) {
    am.metrics = m
}
```

This follows the same pattern as EventPoster.SetMetrics().
  </action>
  <verify>
Run `go build ./pkg/attachment/...` to verify compilation.
  </verify>
  <done>AttachmentManager has metrics field and SetMetrics method.</done>
</task>

<task type="auto">
  <name>Task 2: Record metrics in AddSecondaryAttachment and RemoveNodeAttachment</name>
  <files>pkg/attachment/manager.go</files>
  <action>
Add metric recording to migration state transitions:

1. In AddSecondaryAttachment(), after setting MigrationStartedAt and MigrationTimeout:
```go
// Record metric: migration started
if am.metrics != nil {
    am.metrics.RecordMigrationStarted()
}
```

2. In RemoveNodeAttachment(), when migration completes (after clearing migration state, around line 328-331):
```go
// If this was a migration completion (was migrating, now down to 1 node)
if found && len(newNodes) == 1 && wasMigrating {
    duration := time.Since(migrationStartedAt) // Capture before clearing state
    if am.metrics != nil {
        am.metrics.RecordMigrationResult("success", duration)
    }
}
```

IMPORTANT: You need to capture MigrationStartedAt BEFORE clearing the migration state, so:
- Before the `if found && len(newNodes) == 1` block, capture:
  - wasMigrating := existing.MigrationStartedAt != nil
  - migrationStartedAt := existing.MigrationStartedAt (copy the pointer value if non-nil)
- Then use these values after clearing migration state

This ensures we have the duration even after clearing the timestamp.
  </action>
  <verify>
Run `go build ./pkg/attachment/...` to verify compilation.
  </verify>
  <done>AddSecondaryAttachment calls RecordMigrationStarted, RemoveNodeAttachment calls RecordMigrationResult on success.</done>
</task>

<task type="auto">
  <name>Task 3: Wire events and timeout metrics in ControllerPublishVolume</name>
  <files>pkg/driver/controller.go</files>
  <action>
Find the ControllerPublishVolume method and add event posting at migration lifecycle points.

This requires finding where the driver handles:
1. Secondary attachment for RWX (migration start)
2. Migration timeout detection

For migration start (after AddSecondaryAttachment succeeds):
- Call eventPoster.PostMigrationStarted(ctx, pvcNamespace, pvcName, volumeID, sourceNode, targetNode, migrationTimeout)
- Get PVC namespace/name from VolumeContext: req.GetVolumeContext()["csi.storage.k8s.io/pvc/namespace"] and req.GetVolumeContext()["csi.storage.k8s.io/pvc/name"]
- sourceNode is existing.Nodes[0].NodeID (captured before AddSecondaryAttachment)
- targetNode is nodeID from the request

For migration timeout detection (when IsMigrationTimedOut() returns true):
- Call cs.driver.metrics.RecordMigrationResult("timeout", duration)
- Call eventPoster.PostMigrationFailed(ctx, pvcNamespace, pvcName, volumeID, sourceNode, targetNode, "timeout", duration)
- Calculate duration: time.Since(*existing.MigrationStartedAt)

IMPORTANT: Only access eventPoster if it exists (check for nil). The controller may or may not have an event poster configured.

Look for existing timeout handling logic in the file - the research says it's already detecting timeout via IsMigrationTimedOut().
  </action>
  <verify>
Run `go build ./pkg/driver/...` to verify compilation.
  </verify>
  <done>ControllerPublishVolume posts MigrationStarted event and records timeout metric/event.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go test ./pkg/attachment/... ./pkg/driver/...` passes
3. Manually trace the code path:
   - AddSecondaryAttachment -> RecordMigrationStarted
   - ControllerPublishVolume (secondary attach) -> PostMigrationStarted
   - RemoveNodeAttachment (migration complete) -> RecordMigrationResult("success")
   - ControllerPublishVolume (timeout) -> RecordMigrationResult("timeout") + PostMigrationFailed
</verification>

<success_criteria>
- AttachmentManager has metrics field and SetMetrics method
- AddSecondaryAttachment records migration start metric
- RemoveNodeAttachment records migration success metric with duration
- ControllerPublishVolume posts MigrationStarted event after secondary attach
- ControllerPublishVolume records timeout metric and posts MigrationFailed event on timeout
- All nil checks in place for optional metrics/eventPoster fields
</success_criteria>

<output>
After completion, create `.planning/phases/10-observability/10-03-SUMMARY.md`
</output>
