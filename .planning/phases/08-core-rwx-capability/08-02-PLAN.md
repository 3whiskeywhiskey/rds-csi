---
phase: 08-core-rwx-capability
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - pkg/attachment/types.go
  - pkg/attachment/manager.go
  - pkg/driver/controller.go
autonomous: true

must_haves:
  truths:
    - "AttachmentState can track up to 2 nodes per volume"
    - "ControllerPublishVolume allows second attachment for RWX block volumes"
    - "ControllerPublishVolume rejects third attachment with migration-aware error"
    - "RWO volumes still reject second attachment with hint about RWX"
    - "Attachment order is tracked (primary vs secondary node)"
  artifacts:
    - path: "pkg/attachment/types.go"
      provides: "NodeAttachment struct and multi-node AttachmentState"
      contains: "NodeAttachment"
    - path: "pkg/attachment/manager.go"
      provides: "AddSecondaryAttachment and GetNodeCount methods"
      contains: "AddSecondaryAttachment"
    - path: "pkg/driver/controller.go"
      provides: "RWX dual-attach logic in ControllerPublishVolume"
      contains: "migration limit"
  key_links:
    - from: "pkg/driver/controller.go"
      to: "pkg/attachment/manager.go"
      via: "AddSecondaryAttachment call for RWX"
      pattern: "AddSecondaryAttachment"
    - from: "pkg/attachment/manager.go"
      to: "pkg/attachment/types.go"
      via: "NodeAttachment struct usage"
      pattern: "NodeAttachment"
---

<objective>
Modify AttachmentManager to support 2-node attachment for RWX block volumes during KubeVirt live migration.

Purpose: Enable dual-node attachment required for live migration (source + destination node) while enforcing strict 2-node limit. This satisfies RWX-03.

Output: AttachmentState tracks multiple nodes, ControllerPublishVolume allows RWX dual-attach with 2-node limit.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-core-rwx-capability/08-RESEARCH.md
@.planning/phases/08-core-rwx-capability/08-CONTEXT.md
@.planning/phases/08-core-rwx-capability/08-01-SUMMARY.md
@pkg/attachment/types.go
@pkg/attachment/manager.go
@pkg/driver/controller.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AttachmentState for multi-node tracking</name>
  <files>pkg/attachment/types.go</files>
  <action>
Update types.go to support ordered multi-node attachments:

```go
package attachment

import "time"

// NodeAttachment represents a single node's attachment to a volume.
// Used within AttachmentState.Nodes to track attachment order.
type NodeAttachment struct {
    // NodeID is the Kubernetes node identifier
    NodeID string

    // AttachedAt is when this specific node attached
    AttachedAt time.Time
}

// AttachmentState represents a tracked volume-to-node binding.
// For RWO volumes, Nodes will have at most 1 entry.
// For RWX volumes during migration, Nodes can have up to 2 entries.
type AttachmentState struct {
    // VolumeID is the CSI volume identifier (e.g., "pvc-uuid")
    VolumeID string

    // NodeID is the primary node (first attached) - kept for backward compatibility
    // Deprecated: Use Nodes[0].NodeID instead
    NodeID string

    // Nodes tracks all attached nodes in attachment order.
    // Index 0 = primary (first attached), Index 1 = secondary (migration target)
    // For RWO: len(Nodes) <= 1
    // For RWX during migration: len(Nodes) <= 2
    Nodes []NodeAttachment

    // AttachedAt is the timestamp when the volume was first attached
    AttachedAt time.Time

    // DetachedAt is the timestamp when the volume was detached.
    // nil if volume is currently attached. Used for grace period calculation.
    DetachedAt *time.Time

    // AccessMode tracks whether this is RWO or RWX attachment
    // Needed to determine if dual-attach is allowed
    AccessMode string // "RWO" or "RWX"
}

// GetNodeIDs returns a slice of all attached node IDs.
func (as *AttachmentState) GetNodeIDs() []string {
    ids := make([]string, len(as.Nodes))
    for i, na := range as.Nodes {
        ids[i] = na.NodeID
    }
    return ids
}

// IsAttachedToNode checks if volume is attached to a specific node.
func (as *AttachmentState) IsAttachedToNode(nodeID string) bool {
    for _, na := range as.Nodes {
        if na.NodeID == nodeID {
            return true
        }
    }
    return false
}

// NodeCount returns the number of attached nodes.
func (as *AttachmentState) NodeCount() int {
    return len(as.Nodes)
}
```

Note: Keep the deprecated NodeID field for backward compatibility with existing attachments loaded from PV annotations.
  </action>
  <verify>
Run `go build ./pkg/attachment/...` to verify no syntax errors.
  </verify>
  <done>
- NodeAttachment struct defined with NodeID and AttachedAt
- AttachmentState has Nodes slice for multi-node tracking
- AttachmentState has AccessMode field to distinguish RWO/RWX
- Helper methods GetNodeIDs(), IsAttachedToNode(), NodeCount() added
  </done>
</task>

<task type="auto">
  <name>Task 2: Update AttachmentManager for dual-attach support</name>
  <files>pkg/attachment/manager.go</files>
  <action>
Modify manager.go to support RWX dual-attachment:

1. Update TrackAttachment to initialize Nodes slice and accept access mode:

```go
// TrackAttachment records that a volume is attached to a node.
// accessMode should be "RWO" or "RWX" to determine if dual-attach is allowed.
func (am *AttachmentManager) TrackAttachment(ctx context.Context, volumeID, nodeID, accessMode string) error {
    am.volumeLocks.Lock(volumeID)
    defer am.volumeLocks.Unlock(volumeID)

    am.mu.RLock()
    existing, exists := am.attachments[volumeID]
    am.mu.RUnlock()

    if exists {
        // Check if already attached to this node (idempotent)
        if existing.IsAttachedToNode(nodeID) {
            klog.V(2).Infof("Volume %s already attached to node %s (idempotent)", volumeID, nodeID)
            return nil
        }

        // Different node - caller must handle via AddSecondaryAttachment for RWX
        return fmt.Errorf("volume %s already attached to node %s", volumeID, existing.NodeID)
    }

    // Create new attachment state with first node
    now := time.Now()
    state := &AttachmentState{
        VolumeID:   volumeID,
        NodeID:     nodeID, // Keep for backward compat
        Nodes: []NodeAttachment{
            {NodeID: nodeID, AttachedAt: now},
        },
        AttachedAt: now,
        AccessMode: accessMode,
    }

    am.mu.Lock()
    am.attachments[volumeID] = state
    am.mu.Unlock()

    klog.V(2).Infof("Tracked attachment: volume=%s, node=%s, accessMode=%s (primary)", volumeID, nodeID, accessMode)

    // Persist to PV annotations
    if err := am.persistAttachment(ctx, volumeID, nodeID); err != nil {
        am.mu.Lock()
        delete(am.attachments, volumeID)
        am.mu.Unlock()
        return fmt.Errorf("failed to persist attachment: %w", err)
    }

    return nil
}
```

2. Add AddSecondaryAttachment for RWX migration:

```go
// AddSecondaryAttachment adds a second node attachment for RWX volumes during migration.
// Returns error if volume not attached, not RWX, or already has 2 nodes.
func (am *AttachmentManager) AddSecondaryAttachment(ctx context.Context, volumeID, nodeID string) error {
    am.volumeLocks.Lock(volumeID)
    defer am.volumeLocks.Unlock(volumeID)

    am.mu.Lock()
    defer am.mu.Unlock()

    existing, exists := am.attachments[volumeID]
    if !exists {
        return fmt.Errorf("volume %s not attached", volumeID)
    }

    // Check if already attached to this node (idempotent)
    if existing.IsAttachedToNode(nodeID) {
        klog.V(2).Infof("Volume %s already attached to node %s (idempotent)", volumeID, nodeID)
        return nil
    }

    // ROADMAP-5: Enforce 2-node limit
    if len(existing.Nodes) >= 2 {
        return fmt.Errorf("volume %s already attached to 2 nodes (migration limit)", volumeID)
    }

    // Add secondary attachment
    existing.Nodes = append(existing.Nodes, NodeAttachment{
        NodeID:     nodeID,
        AttachedAt: time.Now(),
    })

    klog.V(2).Infof("Tracked secondary attachment: volume=%s, node=%s (migration target)", volumeID, nodeID)
    return nil
}
```

3. Add helper to check node count:

```go
// GetNodeCount returns the number of nodes a volume is attached to.
func (am *AttachmentManager) GetNodeCount(volumeID string) int {
    am.mu.RLock()
    defer am.mu.RUnlock()

    if state, exists := am.attachments[volumeID]; exists {
        return state.NodeCount()
    }
    return 0
}

// IsAttachedToNode checks if volume is attached to a specific node.
func (am *AttachmentManager) IsAttachedToNode(volumeID, nodeID string) bool {
    am.mu.RLock()
    defer am.mu.RUnlock()

    if state, exists := am.attachments[volumeID]; exists {
        return state.IsAttachedToNode(nodeID)
    }
    return false
}
```

4. Update UntrackAttachment to handle multi-node detach (remove specific node, not all):

```go
// RemoveNodeAttachment removes a specific node's attachment from a volume.
// For RWX during migration, this removes one node while keeping the other.
// Returns true if this was the last node (volume now fully detached).
func (am *AttachmentManager) RemoveNodeAttachment(ctx context.Context, volumeID, nodeID string) (bool, error) {
    am.volumeLocks.Lock(volumeID)
    defer am.volumeLocks.Unlock(volumeID)

    am.mu.Lock()
    defer am.mu.Unlock()

    existing, exists := am.attachments[volumeID]
    if !exists {
        klog.V(2).Infof("Volume %s not tracked, nothing to remove (idempotent)", volumeID)
        return false, nil
    }

    // Find and remove the node
    newNodes := make([]NodeAttachment, 0, len(existing.Nodes))
    found := false
    for _, na := range existing.Nodes {
        if na.NodeID == nodeID {
            found = true
            continue // Skip this node
        }
        newNodes = append(newNodes, na)
    }

    if !found {
        klog.V(2).Infof("Volume %s not attached to node %s (idempotent)", volumeID, nodeID)
        return false, nil
    }

    if len(newNodes) == 0 {
        // Last node removed - fully detach
        am.detachTimestamps[volumeID] = time.Now()
        delete(am.attachments, volumeID)
        klog.V(2).Infof("Removed last node attachment for volume %s, volume now detached", volumeID)
        return true, nil
    }

    // Update with remaining nodes
    existing.Nodes = newNodes
    existing.NodeID = newNodes[0].NodeID // Update primary for backward compat
    klog.V(2).Infof("Removed node %s from volume %s, %d node(s) remaining", nodeID, volumeID, len(newNodes))
    return false, nil
}
```

Note: Keep the existing UntrackAttachment for backward compatibility but it now fully removes all attachments.
  </action>
  <verify>
Run `go build ./pkg/attachment/...` to verify no syntax errors.
Run `make test` to ensure existing tests pass.
  </verify>
  <done>
- TrackAttachment initializes Nodes slice with first node
- AddSecondaryAttachment allows second node for RWX with 2-node limit
- RemoveNodeAttachment removes specific node, tracks if last node
- GetNodeCount and IsAttachedToNode helpers added
  </done>
</task>

<task type="auto">
  <name>Task 3: Update ControllerPublishVolume for RWX dual-attach</name>
  <files>pkg/driver/controller.go</files>
  <action>
Modify ControllerPublishVolume to handle RWX dual-attachment:

1. Add helper to extract access mode from capabilities:

```go
// getAccessMode extracts the access mode from volume capabilities.
// Returns "RWX" for MULTI_NODE_MULTI_WRITER, "RWO" otherwise.
func (cs *ControllerServer) getAccessMode(caps []*csi.VolumeCapability) string {
    for _, cap := range caps {
        if cap.GetAccessMode().GetMode() == csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER {
            return "RWX"
        }
    }
    return "RWO"
}
```

2. Update ControllerPublishVolume to handle RWX differently:

```go
func (cs *ControllerServer) ControllerPublishVolume(ctx context.Context, req *csi.ControllerPublishVolumeRequest) (*csi.ControllerPublishVolumeResponse, error) {
    startTime := time.Now()
    volumeID := req.GetVolumeId()
    nodeID := req.GetNodeId()

    klog.V(2).Infof("ControllerPublishVolume called for volume %s to node %s", volumeID, nodeID)

    // ... existing validation ...

    // Determine access mode from capabilities
    accessMode := cs.getAccessMode(req.GetVolumeCapability())
    isRWX := accessMode == "RWX"

    // Get attachment manager
    am := cs.driver.GetAttachmentManager()
    if am == nil {
        klog.V(3).Infof("Attachment manager not available, skipping tracking for volume %s", volumeID)
        return &csi.ControllerPublishVolumeResponse{
            PublishContext: cs.buildPublishContext(volume, req.GetVolumeContext()),
        }, nil
    }

    // Check existing attachment
    existing, exists := am.GetAttachment(volumeID)
    if exists {
        // Check if already attached to requesting node (idempotent)
        if am.IsAttachedToNode(volumeID, nodeID) {
            klog.V(2).Infof("Volume %s already attached to node %s (idempotent)", volumeID, nodeID)
            return &csi.ControllerPublishVolumeResponse{
                PublishContext: cs.buildPublishContext(volume, req.GetVolumeContext()),
            }, nil
        }

        // Different node - behavior depends on access mode
        if isRWX {
            // RWX: Allow second attachment if within limit
            nodeCount := am.GetNodeCount(volumeID)
            if nodeCount >= 2 {
                // ROADMAP-5: 2-node migration limit reached
                klog.Warningf("RWX volume %s already attached to 2 nodes, rejecting 3rd attachment to %s",
                    volumeID, nodeID)
                return nil, status.Errorf(codes.FailedPrecondition,
                    "Volume %s already attached to 2 nodes (migration limit). Wait for migration to complete. Attached nodes: %v",
                    volumeID, existing.GetNodeIDs())
            }

            // Allow second attachment for migration
            klog.V(2).Infof("Allowing second attachment of RWX volume %s to node %s (migration target)", volumeID, nodeID)
            if err := am.AddSecondaryAttachment(ctx, volumeID, nodeID); err != nil {
                return nil, status.Errorf(codes.Internal, "failed to track secondary attachment: %v", err)
            }

            // Record RWX dual-attach (distinct from RWO conflict)
            if cs.driver.metrics != nil {
                cs.driver.metrics.RecordAttachmentOp("attach_secondary", nil, time.Since(startTime))
            }

            return &csi.ControllerPublishVolumeResponse{
                PublishContext: cs.buildPublishContext(volume, req.GetVolumeContext()),
            }, nil
        }

        // RWO: Check grace period first (existing behavior)
        gracePeriod := cs.driver.GetAttachmentGracePeriod()
        if gracePeriod > 0 && am.IsWithinGracePeriod(volumeID, gracePeriod) {
            // ... existing grace period handling ...
        }

        // RWO conflict - hint about RWX
        klog.Warningf("RWO volume %s already attached to node %s, rejecting attachment to node %s",
            volumeID, existing.NodeID, nodeID)

        cs.postAttachmentConflictEvent(ctx, req, existing.NodeID)

        if cs.driver.metrics != nil {
            cs.driver.metrics.RecordAttachmentConflict()
        }

        return nil, status.Errorf(codes.FailedPrecondition,
            "Volume %s already attached to node %s. For multi-node access, use RWX with block volumes.",
            volumeID, existing.NodeID)
    }

    // No existing attachment - track new primary attachment
    if err := am.TrackAttachment(ctx, volumeID, nodeID, accessMode); err != nil {
        // ... existing error handling ...
    }

    // ... rest of existing code ...
}
```

3. Update ControllerUnpublishVolume to use RemoveNodeAttachment:

```go
func (cs *ControllerServer) ControllerUnpublishVolume(ctx context.Context, req *csi.ControllerUnpublishVolumeRequest) (*csi.ControllerUnpublishVolumeResponse, error) {
    // ... existing validation ...

    am := cs.driver.GetAttachmentManager()
    if am == nil {
        return &csi.ControllerUnpublishVolumeResponse{}, nil
    }

    // Remove this node's attachment (handles both RWO and RWX)
    fullyDetached, err := am.RemoveNodeAttachment(ctx, volumeID, nodeID)
    if err != nil {
        klog.Warningf("Error removing node attachment for volume %s: %v (returning success)", volumeID, err)
    }

    if fullyDetached {
        // Record detachment metric
        if cs.driver.metrics != nil {
            cs.driver.metrics.RecordAttachmentOp("detach", nil, time.Since(startTime))
        }
        cs.postVolumeDetachedEvent(ctx, req)
    } else {
        // Partial detach (RWX migration - one node still attached)
        klog.V(2).Infof("Volume %s partially detached from node %s, other node(s) still attached", volumeID, nodeID)
        if cs.driver.metrics != nil {
            cs.driver.metrics.RecordAttachmentOp("detach_partial", nil, time.Since(startTime))
        }
    }

    klog.V(2).Infof("Successfully unpublished volume %s from node %s", volumeID, nodeID)
    return &csi.ControllerUnpublishVolumeResponse{}, nil
}
```

4. Also update the getAccessMode call to use GetVolumeCapability() properly - the CSI spec uses singular VolumeCapability for publish:

```go
// For ControllerPublishVolume, use the single VolumeCapability from the request
accessMode := "RWO"
if req.GetVolumeCapability() != nil {
    if req.GetVolumeCapability().GetAccessMode().GetMode() == csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER {
        accessMode = "RWX"
    }
}
```
  </action>
  <verify>
Run `go build ./...` to verify no syntax errors.
Run `make test` to ensure existing tests pass.
  </verify>
  <done>
- ControllerPublishVolume detects RWX access mode
- RWX volumes allow second attachment via AddSecondaryAttachment
- RWX 3rd attachment rejected with migration-aware error
- RWO conflict error hints about RWX
- ControllerUnpublishVolume uses RemoveNodeAttachment
- Distinct log entries for RWX dual-attach vs RWO conflict
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `make test` passes
3. Grep confirms AddSecondaryAttachment in manager.go
4. Grep confirms "migration limit" error message in controller.go
5. Grep confirms "For multi-node access, use RWX" hint in RWO error
</verification>

<success_criteria>
- AttachmentState tracks ordered Nodes slice (primary/secondary)
- AddSecondaryAttachment enforces 2-node limit
- ControllerPublishVolume allows RWX second attach
- ControllerPublishVolume rejects RWX 3rd attach with migration-aware message
- RWO conflict message hints about RWX alternative
- Code compiles and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-core-rwx-capability/08-02-SUMMARY.md`
</output>
