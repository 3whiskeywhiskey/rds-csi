---
phase: 08-core-rwx-capability
plan: 03
type: execute
wave: 3
depends_on: ["08-01", "08-02"]
files_modified:
  - pkg/driver/controller_test.go
  - pkg/attachment/manager_test.go
autonomous: true

must_haves:
  truths:
    - "Unit tests verify RWX+block is accepted"
    - "Unit tests verify RWX+filesystem is rejected with correct error"
    - "Unit tests verify 2-node limit enforcement"
    - "Unit tests verify RWO conflict hints about RWX"
    - "All tests pass"
  artifacts:
    - path: "pkg/driver/controller_test.go"
      provides: "RWX validation tests"
      contains: "TestRWX"
    - path: "pkg/attachment/manager_test.go"
      provides: "Dual-attach tracking tests"
      contains: "TestAddSecondaryAttachment"
  key_links:
    - from: "pkg/driver/controller_test.go"
      to: "validateVolumeCapabilities"
      via: "test function calls"
      pattern: "MULTI_NODE_MULTI_WRITER"
    - from: "pkg/attachment/manager_test.go"
      to: "AddSecondaryAttachment"
      via: "test function calls"
      pattern: "AddSecondaryAttachment"
---

<objective>
Add comprehensive unit tests for RWX capability declaration, validation, and dual-attach logic.

Purpose: Ensure RWX-01, RWX-02, and RWX-03 requirements are verified with automated tests that prevent regressions.

Output: Test files with complete coverage of RWX behavior.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-core-rwx-capability/08-01-SUMMARY.md
@.planning/phases/08-core-rwx-capability/08-02-SUMMARY.md
@pkg/driver/controller.go
@pkg/driver/controller_test.go
@pkg/attachment/manager.go
@pkg/attachment/manager_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RWX validation tests to controller_test.go</name>
  <files>pkg/driver/controller_test.go</files>
  <action>
Add test cases for RWX validation in CreateVolume and ValidateVolumeCapabilities:

```go
func TestValidateVolumeCapabilities_RWX(t *testing.T) {
    tests := []struct {
        name        string
        caps        []*csi.VolumeCapability
        expectError bool
        errorContains string
    }{
        {
            name: "RWX block - should succeed",
            caps: []*csi.VolumeCapability{
                {
                    AccessMode: &csi.VolumeCapability_AccessMode{
                        Mode: csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER,
                    },
                    AccessType: &csi.VolumeCapability_Block{
                        Block: &csi.VolumeCapability_BlockVolume{},
                    },
                },
            },
            expectError: false,
        },
        {
            name: "RWX filesystem - should fail with actionable error",
            caps: []*csi.VolumeCapability{
                {
                    AccessMode: &csi.VolumeCapability_AccessMode{
                        Mode: csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER,
                    },
                    AccessType: &csi.VolumeCapability_Mount{
                        Mount: &csi.VolumeCapability_MountVolume{FsType: "ext4"},
                    },
                },
            },
            expectError: true,
            errorContains: "volumeMode: Block",
        },
        {
            name: "RWO block - should succeed",
            caps: []*csi.VolumeCapability{
                {
                    AccessMode: &csi.VolumeCapability_AccessMode{
                        Mode: csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER,
                    },
                    AccessType: &csi.VolumeCapability_Block{
                        Block: &csi.VolumeCapability_BlockVolume{},
                    },
                },
            },
            expectError: false,
        },
        {
            name: "RWO filesystem - should succeed",
            caps: []*csi.VolumeCapability{
                {
                    AccessMode: &csi.VolumeCapability_AccessMode{
                        Mode: csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER,
                    },
                    AccessType: &csi.VolumeCapability_Mount{
                        Mount: &csi.VolumeCapability_MountVolume{FsType: "ext4"},
                    },
                },
            },
            expectError: false,
        },
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            // Create controller with driver that has RWX capability
            driver := createTestDriver(t)
            cs := NewControllerServer(driver)

            err := cs.validateVolumeCapabilities(tc.caps)

            if tc.expectError {
                if err == nil {
                    t.Errorf("expected error but got nil")
                } else if tc.errorContains != "" && !strings.Contains(err.Error(), tc.errorContains) {
                    t.Errorf("expected error containing %q, got %q", tc.errorContains, err.Error())
                }
            } else {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
            }
        })
    }
}

func TestCreateVolume_RWXFilesystemRejected(t *testing.T) {
    driver := createTestDriver(t)
    cs := NewControllerServer(driver)

    req := &csi.CreateVolumeRequest{
        Name: "test-vol",
        VolumeCapabilities: []*csi.VolumeCapability{
            {
                AccessMode: &csi.VolumeCapability_AccessMode{
                    Mode: csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER,
                },
                AccessType: &csi.VolumeCapability_Mount{
                    Mount: &csi.VolumeCapability_MountVolume{FsType: "ext4"},
                },
            },
        },
        CapacityRange: &csi.CapacityRange{
            RequiredBytes: 1 * 1024 * 1024 * 1024,
        },
    }

    _, err := cs.CreateVolume(context.Background(), req)

    if err == nil {
        t.Fatal("expected error for RWX filesystem, got nil")
    }

    // Check it's an InvalidArgument error
    st, ok := status.FromError(err)
    if !ok {
        t.Fatalf("expected gRPC status error, got %v", err)
    }
    if st.Code() != codes.InvalidArgument {
        t.Errorf("expected InvalidArgument, got %v", st.Code())
    }
    if !strings.Contains(st.Message(), "volumeMode: Block") {
        t.Errorf("expected error to mention volumeMode: Block, got %q", st.Message())
    }
}
```

Also add a test to verify MULTI_NODE_MULTI_WRITER is in vcaps:

```go
func TestDriverVolumeCapabilities_IncludesRWX(t *testing.T) {
    driver := createTestDriver(t)
    driver.addVolumeCapabilities()

    found := false
    for _, vcap := range driver.vcaps {
        if vcap.GetMode() == csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER {
            found = true
            break
        }
    }

    if !found {
        t.Error("expected MULTI_NODE_MULTI_WRITER in vcaps, not found")
    }
}
```
  </action>
  <verify>
Run `go test -v ./pkg/driver/... -run TestRWX` to verify RWX tests pass.
Run `go test -v ./pkg/driver/... -run TestDriverVolumeCapabilities` to verify capability test.
  </verify>
  <done>
- TestValidateVolumeCapabilities_RWX covers all access mode + volume mode combinations
- TestCreateVolume_RWXFilesystemRejected verifies rejection with correct error code and message
- TestDriverVolumeCapabilities_IncludesRWX verifies MULTI_NODE_MULTI_WRITER in vcaps
  </done>
</task>

<task type="auto">
  <name>Task 2: Add dual-attach tests to manager_test.go</name>
  <files>pkg/attachment/manager_test.go</files>
  <action>
Add test cases for AttachmentManager dual-attach support:

```go
func TestAttachmentManager_AddSecondaryAttachment(t *testing.T) {
    tests := []struct {
        name          string
        setup         func(am *AttachmentManager)
        volumeID      string
        nodeID        string
        expectError   bool
        errorContains string
    }{
        {
            name: "add secondary to existing RWX volume",
            setup: func(am *AttachmentManager) {
                _ = am.TrackAttachment(context.Background(), "vol-1", "node-1", "RWX")
            },
            volumeID:    "vol-1",
            nodeID:      "node-2",
            expectError: false,
        },
        {
            name: "idempotent - same node already attached",
            setup: func(am *AttachmentManager) {
                _ = am.TrackAttachment(context.Background(), "vol-1", "node-1", "RWX")
                _ = am.AddSecondaryAttachment(context.Background(), "vol-1", "node-2")
            },
            volumeID:    "vol-1",
            nodeID:      "node-2",
            expectError: false,
        },
        {
            name: "reject 3rd attachment - migration limit",
            setup: func(am *AttachmentManager) {
                _ = am.TrackAttachment(context.Background(), "vol-1", "node-1", "RWX")
                _ = am.AddSecondaryAttachment(context.Background(), "vol-1", "node-2")
            },
            volumeID:      "vol-1",
            nodeID:        "node-3",
            expectError:   true,
            errorContains: "migration limit",
        },
        {
            name:          "fail if volume not attached",
            setup:         func(am *AttachmentManager) {},
            volumeID:      "vol-not-exist",
            nodeID:        "node-1",
            expectError:   true,
            errorContains: "not attached",
        },
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            am := NewAttachmentManager(nil)
            tc.setup(am)

            err := am.AddSecondaryAttachment(context.Background(), tc.volumeID, tc.nodeID)

            if tc.expectError {
                if err == nil {
                    t.Error("expected error but got nil")
                } else if tc.errorContains != "" && !strings.Contains(err.Error(), tc.errorContains) {
                    t.Errorf("expected error containing %q, got %q", tc.errorContains, err.Error())
                }
            } else {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
            }
        })
    }
}

func TestAttachmentManager_RemoveNodeAttachment(t *testing.T) {
    tests := []struct {
        name           string
        setup          func(am *AttachmentManager)
        volumeID       string
        nodeID         string
        expectDetached bool
        expectRemaining int
    }{
        {
            name: "remove only node - fully detached",
            setup: func(am *AttachmentManager) {
                _ = am.TrackAttachment(context.Background(), "vol-1", "node-1", "RWO")
            },
            volumeID:        "vol-1",
            nodeID:          "node-1",
            expectDetached:  true,
            expectRemaining: 0,
        },
        {
            name: "remove secondary node - one remaining",
            setup: func(am *AttachmentManager) {
                _ = am.TrackAttachment(context.Background(), "vol-1", "node-1", "RWX")
                _ = am.AddSecondaryAttachment(context.Background(), "vol-1", "node-2")
            },
            volumeID:        "vol-1",
            nodeID:          "node-2",
            expectDetached:  false,
            expectRemaining: 1,
        },
        {
            name: "remove primary node - secondary promoted",
            setup: func(am *AttachmentManager) {
                _ = am.TrackAttachment(context.Background(), "vol-1", "node-1", "RWX")
                _ = am.AddSecondaryAttachment(context.Background(), "vol-1", "node-2")
            },
            volumeID:        "vol-1",
            nodeID:          "node-1",
            expectDetached:  false,
            expectRemaining: 1,
        },
        {
            name:            "idempotent - volume not tracked",
            setup:           func(am *AttachmentManager) {},
            volumeID:        "vol-not-exist",
            nodeID:          "node-1",
            expectDetached:  false,
            expectRemaining: 0,
        },
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            am := NewAttachmentManager(nil)
            tc.setup(am)

            fullyDetached, err := am.RemoveNodeAttachment(context.Background(), tc.volumeID, tc.nodeID)

            if err != nil {
                t.Errorf("unexpected error: %v", err)
            }

            if fullyDetached != tc.expectDetached {
                t.Errorf("expected fullyDetached=%v, got %v", tc.expectDetached, fullyDetached)
            }

            nodeCount := am.GetNodeCount(tc.volumeID)
            if nodeCount != tc.expectRemaining {
                t.Errorf("expected %d remaining nodes, got %d", tc.expectRemaining, nodeCount)
            }
        })
    }
}

func TestAttachmentState_GetNodeIDs(t *testing.T) {
    state := &AttachmentState{
        VolumeID: "vol-1",
        Nodes: []NodeAttachment{
            {NodeID: "node-1"},
            {NodeID: "node-2"},
        },
    }

    ids := state.GetNodeIDs()
    if len(ids) != 2 {
        t.Errorf("expected 2 node IDs, got %d", len(ids))
    }
    if ids[0] != "node-1" || ids[1] != "node-2" {
        t.Errorf("unexpected node IDs: %v", ids)
    }
}

func TestAttachmentState_IsAttachedToNode(t *testing.T) {
    state := &AttachmentState{
        VolumeID: "vol-1",
        Nodes: []NodeAttachment{
            {NodeID: "node-1"},
        },
    }

    if !state.IsAttachedToNode("node-1") {
        t.Error("expected IsAttachedToNode(node-1) = true")
    }
    if state.IsAttachedToNode("node-2") {
        t.Error("expected IsAttachedToNode(node-2) = false")
    }
}
```
  </action>
  <verify>
Run `go test -v ./pkg/attachment/... -run TestAttachmentManager` to verify attachment tests pass.
Run `go test -v ./pkg/attachment/... -run TestAttachmentState` to verify state tests pass.
  </verify>
  <done>
- TestAttachmentManager_AddSecondaryAttachment tests 2-node limit enforcement
- TestAttachmentManager_RemoveNodeAttachment tests partial and full detach
- TestAttachmentState_GetNodeIDs and TestAttachmentState_IsAttachedToNode test helper methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Add ControllerPublishVolume RWX tests</name>
  <files>pkg/driver/controller_test.go</files>
  <action>
Add integration-style tests for ControllerPublishVolume RWX behavior:

```go
func TestControllerPublishVolume_RWXDualAttach(t *testing.T) {
    driver := createTestDriverWithAttachmentManager(t)
    cs := NewControllerServer(driver)

    volumeID := "pvc-test-rwx"
    node1 := "node-1"
    node2 := "node-2"
    node3 := "node-3"

    // Setup: create volume in mock RDS client
    driver.rdsClient.(*mockRDSClient).volumes[volumeID] = &rds.VolumeInfo{
        Slot:         volumeID,
        NVMETCPNQN:   "nqn.2000-02.com.mikrotik:test",
        NVMETCPPort:  4420,
    }

    rwxCap := &csi.VolumeCapability{
        AccessMode: &csi.VolumeCapability_AccessMode{
            Mode: csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER,
        },
        AccessType: &csi.VolumeCapability_Block{
            Block: &csi.VolumeCapability_BlockVolume{},
        },
    }

    // First attach should succeed
    req1 := &csi.ControllerPublishVolumeRequest{
        VolumeId:         volumeID,
        NodeId:           node1,
        VolumeCapability: rwxCap,
    }
    _, err := cs.ControllerPublishVolume(context.Background(), req1)
    if err != nil {
        t.Fatalf("first attach failed: %v", err)
    }

    // Second attach (migration target) should succeed
    req2 := &csi.ControllerPublishVolumeRequest{
        VolumeId:         volumeID,
        NodeId:           node2,
        VolumeCapability: rwxCap,
    }
    _, err = cs.ControllerPublishVolume(context.Background(), req2)
    if err != nil {
        t.Fatalf("second attach failed: %v", err)
    }

    // Third attach should fail with migration limit
    req3 := &csi.ControllerPublishVolumeRequest{
        VolumeId:         volumeID,
        NodeId:           node3,
        VolumeCapability: rwxCap,
    }
    _, err = cs.ControllerPublishVolume(context.Background(), req3)
    if err == nil {
        t.Fatal("expected error for 3rd attach, got nil")
    }

    st, ok := status.FromError(err)
    if !ok {
        t.Fatalf("expected gRPC status error, got %v", err)
    }
    if st.Code() != codes.FailedPrecondition {
        t.Errorf("expected FailedPrecondition, got %v", st.Code())
    }
    if !strings.Contains(st.Message(), "migration limit") {
        t.Errorf("expected 'migration limit' in error, got %q", st.Message())
    }
}

func TestControllerPublishVolume_RWOConflictHintsRWX(t *testing.T) {
    driver := createTestDriverWithAttachmentManager(t)
    cs := NewControllerServer(driver)

    volumeID := "pvc-test-rwo"
    node1 := "node-1"
    node2 := "node-2"

    // Setup: create volume
    driver.rdsClient.(*mockRDSClient).volumes[volumeID] = &rds.VolumeInfo{
        Slot:         volumeID,
        NVMETCPNQN:   "nqn.2000-02.com.mikrotik:test",
        NVMETCPPort:  4420,
    }

    rwoCap := &csi.VolumeCapability{
        AccessMode: &csi.VolumeCapability_AccessMode{
            Mode: csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER,
        },
        AccessType: &csi.VolumeCapability_Block{
            Block: &csi.VolumeCapability_BlockVolume{},
        },
    }

    // First attach should succeed
    req1 := &csi.ControllerPublishVolumeRequest{
        VolumeId:         volumeID,
        NodeId:           node1,
        VolumeCapability: rwoCap,
    }
    _, err := cs.ControllerPublishVolume(context.Background(), req1)
    if err != nil {
        t.Fatalf("first attach failed: %v", err)
    }

    // Second attach should fail with RWX hint
    req2 := &csi.ControllerPublishVolumeRequest{
        VolumeId:         volumeID,
        NodeId:           node2,
        VolumeCapability: rwoCap,
    }
    _, err = cs.ControllerPublishVolume(context.Background(), req2)
    if err == nil {
        t.Fatal("expected error for RWO conflict, got nil")
    }

    st, ok := status.FromError(err)
    if !ok {
        t.Fatalf("expected gRPC status error, got %v", err)
    }
    if st.Code() != codes.FailedPrecondition {
        t.Errorf("expected FailedPrecondition, got %v", st.Code())
    }
    if !strings.Contains(st.Message(), "RWX") {
        t.Errorf("expected RWX hint in error message, got %q", st.Message())
    }
}

func TestControllerPublishVolume_Idempotent(t *testing.T) {
    driver := createTestDriverWithAttachmentManager(t)
    cs := NewControllerServer(driver)

    volumeID := "pvc-test-idempotent"
    node1 := "node-1"

    driver.rdsClient.(*mockRDSClient).volumes[volumeID] = &rds.VolumeInfo{
        Slot:         volumeID,
        NVMETCPNQN:   "nqn.2000-02.com.mikrotik:test",
        NVMETCPPort:  4420,
    }

    rwxCap := &csi.VolumeCapability{
        AccessMode: &csi.VolumeCapability_AccessMode{
            Mode: csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER,
        },
        AccessType: &csi.VolumeCapability_Block{
            Block: &csi.VolumeCapability_BlockVolume{},
        },
    }

    req := &csi.ControllerPublishVolumeRequest{
        VolumeId:         volumeID,
        NodeId:           node1,
        VolumeCapability: rwxCap,
    }

    // First call
    _, err := cs.ControllerPublishVolume(context.Background(), req)
    if err != nil {
        t.Fatalf("first attach failed: %v", err)
    }

    // Second call (idempotent) - should succeed
    _, err = cs.ControllerPublishVolume(context.Background(), req)
    if err != nil {
        t.Fatalf("idempotent attach failed: %v", err)
    }
}
```

Note: The tests may require helper functions like `createTestDriverWithAttachmentManager` - add them if they don't exist, following existing test patterns in the file.
  </action>
  <verify>
Run `go test -v ./pkg/driver/... -run TestControllerPublishVolume` to verify publish tests pass.
Run `make test` to ensure all tests pass.
  </verify>
  <done>
- TestControllerPublishVolume_RWXDualAttach tests 2-node migration attach pattern
- TestControllerPublishVolume_RWOConflictHintsRWX verifies RWO error hints about RWX
- TestControllerPublishVolume_Idempotent verifies same-node re-attach succeeds
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. `go test -v ./pkg/driver/...` all tests pass
2. `go test -v ./pkg/attachment/...` all tests pass
3. `make test` passes (full test suite)
4. Test coverage includes RWX validation, dual-attach, and RWO conflict scenarios
</verification>

<success_criteria>
- RWX validation tests verify block accepted, filesystem rejected
- Dual-attach tests verify 2-node limit enforcement
- RWO conflict test verifies hint about RWX alternative
- Idempotency tests verify same-node re-attach works
- All tests pass with `make test`
</success_criteria>

<output>
After completion, create `.planning/phases/08-core-rwx-capability/08-03-SUMMARY.md`
</output>
