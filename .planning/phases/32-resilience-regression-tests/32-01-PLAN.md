---
phase: 32-resilience-regression-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - test/mock/error_injection.go
  - test/e2e/resilience_test.go
  - test/e2e/helpers.go
  - pkg/attachment/reconciler_test.go
autonomous: true

must_haves:
  truths:
    - "After mock SSH error injection and clearance, controller volume operations (create, list, delete) succeed without manual intervention"
    - "After mock RDS simulated unavailability via error injection, controller operations resume when errors are cleared"
    - "When a node is deleted from Kubernetes, the attachment reconciler detects the stale attachment and clears it, allowing volume reattachment to a different node"
  artifacts:
    - path: "test/mock/error_injection.go"
      provides: "SetErrorMode() method for runtime error mode changes"
      contains: "SetErrorMode"
    - path: "test/e2e/resilience_test.go"
      provides: "Automated resilience regression tests for RESIL-01 and RESIL-02"
      min_lines: 100
    - path: "pkg/attachment/reconciler_test.go"
      provides: "RESIL-03 stale attachment cleanup + reattachment regression test"
      contains: "RESIL-03"
  key_links:
    - from: "test/e2e/resilience_test.go"
      to: "test/mock/error_injection.go"
      via: "runtime error mode switching"
      pattern: "mockRDS\\.SetErrorMode"
    - from: "test/e2e/resilience_test.go"
      to: "test/mock/rds_server.go"
      via: "mock RDS server error injection delegation"
      pattern: "mockRDS\\.SetErrorMode|mockRDS\\.ResetErrorInjector"
    - from: "pkg/attachment/reconciler_test.go"
      to: "pkg/attachment/reconciler.go"
      via: "direct reconcile() call for stale attachment verification"
      pattern: "reconcile|TrackAttachment|GetAttachment"
---

<objective>
Create automated resilience regression tests that validate SSH error recovery (RESIL-01), RDS unavailability recovery (RESIL-02), and node failure stale attachment cleanup (RESIL-03).

Purpose: These tests run in CI without real hardware and provide regression coverage for the three resilience requirements. RESIL-01 and RESIL-02 use the mock RDS server's error injection (with a new SetErrorMode method) in the E2E framework. RESIL-03 uses a unit test in pkg/attachment/reconciler_test.go (the E2E framework has K8sClient: nil so the attachment reconciler is not available there).

Output: Enhanced error_injection.go with SetErrorMode(), E2E test file for RESIL-01/02, and unit test additions for RESIL-03.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@test/e2e/e2e_suite_test.go
@test/e2e/helpers.go
@test/e2e/fixtures.go
@test/e2e/state_recovery_test.go
@test/e2e/lifecycle_test.go
@test/mock/rds_server.go
@test/mock/error_injection.go
@pkg/rds/connection_manager.go
@pkg/attachment/reconciler.go
@pkg/attachment/reconciler_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SetErrorMode to ErrorInjector and expose via MockRDSServer</name>
  <files>test/mock/error_injection.go, test/mock/rds_server.go</files>
  <action>
Add a `SetErrorMode(mode ErrorMode)` method to `ErrorInjector` in `test/mock/error_injection.go`:

```go
// SetErrorMode changes the error mode at runtime.
// This allows tests to dynamically inject and clear errors without restarting the mock server.
// Thread-safe: can be called concurrently with ShouldFail* methods.
func (e *ErrorInjector) SetErrorMode(mode ErrorMode) {
    e.mu.Lock()
    defer e.mu.Unlock()
    e.mode = mode
    e.operationNum = 0 // Reset counter when mode changes
}
```

Then add a `SetErrorMode(mode ErrorMode)` convenience method to `MockRDSServer` in `test/mock/rds_server.go`:

```go
// SetErrorMode changes the error injection mode at runtime.
// Use ErrorModeNone to clear errors, ErrorModeCommandFail to simulate failures.
// This is the primary API for resilience tests to inject/clear errors dynamically.
func (s *MockRDSServer) SetErrorMode(mode ErrorMode) {
    s.errorInjector.SetErrorMode(mode)
}
```

This is the prerequisite for RESIL-01 and RESIL-02 tests. Without this, the error mode is frozen at construction time and tests cannot simulate error->recovery transitions.

Do NOT add any Stop()/Start() restart capability. The mock server's `shutdown` channel is closed permanently on Stop() and cannot be restarted. All "unavailability" simulation must use SetErrorMode.
  </action>
  <verify>
Run `go vet ./test/mock/...` and `go build ./test/mock/...` to verify the new methods compile. Run `make test` to ensure no regressions.
  </verify>
  <done>
ErrorInjector.SetErrorMode() exists and is thread-safe. MockRDSServer.SetErrorMode() delegates to it. Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RESIL-01 and RESIL-02 E2E tests using error injection</name>
  <files>test/e2e/resilience_test.go, test/e2e/helpers.go</files>
  <action>
Create `test/e2e/resilience_test.go` with a Ginkgo Describe("Resilience Regression") block containing TWO scenario groups (RESIL-01 and RESIL-02 only — RESIL-03 is a unit test, see Task 3). Follow the established patterns in state_recovery_test.go and lifecycle_test.go.

**RESIL-01: SSH error recovery**
- Create a volume via CreateVolume to establish a working state.
- Call `mockRDS.SetErrorMode(mock.ErrorModeCommandFail)` to simulate SSH command failures.
- Attempt a CreateVolume or ListVolumes call and verify it returns an error.
- Call `mockRDS.SetErrorMode(mock.ErrorModeNone)` to clear the error (simulating recovery).
- Call `mockRDS.ResetErrorInjector()` to reset the operation counter.
- Retry the volume operation and verify it succeeds immediately (the mock server is still running, just error mode changed).
- Delete the volume to confirm full lifecycle recovery.
- Use DeferCleanup to ensure error mode is reset to ErrorModeNone after the test.

**RESIL-02: RDS unavailability simulation (error injection approach)**
CRITICAL: Do NOT use mockRDS.Stop()/Start(). The mock server cannot be restarted (shutdown channel closes permanently). Use error injection exclusively.

- Create a volume via CreateVolume.
- Call `mockRDS.SetErrorMode(mock.ErrorModeCommandFail)` to simulate RDS being unavailable (all commands fail).
- Verify that CreateVolume for a new volume fails while "RDS is down".
- Verify that GetCapacity fails while "RDS is down".
- Call `mockRDS.SetErrorMode(mock.ErrorModeNone)` and `mockRDS.ResetErrorInjector()` to simulate RDS coming back.
- Verify GetCapacity succeeds after recovery.
- Verify CreateVolume works for a new volume after recovery.
- Delete all test volumes.

Add a helper function in `test/e2e/helpers.go` if useful (e.g., `injectMockError(mode mock.ErrorMode)` / `clearMockError()` that wraps SetErrorMode + ResetErrorInjector).

Important constraints:
- Use the same Ginkgo import style as existing tests (`. "github.com/onsi/ginkgo/v2"` and `. "github.com/onsi/gomega"`).
- Import `"git.srvlab.io/whiskey/rds-csi-driver/test/mock"` for ErrorMode constants.
- Use DeferCleanup for volume deletion and error mode reset.
- Use klog for test progress logging (matching existing pattern).
- Wrap assertions in By() blocks for clarity.
- The test must pass with `go test -v ./test/e2e/... -ginkgo.v -ginkgo.focus="Resilience"`.
  </action>
  <verify>
Run `go test -v ./test/e2e/... -ginkgo.v -ginkgo.focus="Resilience" -count=1` and verify both RESIL-01 and RESIL-02 scenarios pass. Run `go vet ./test/e2e/...` for compile checks.
  </verify>
  <done>
RESIL-01 (SSH error recovery) and RESIL-02 (RDS unavailability via error injection) E2E tests pass. No Stop()/Start() calls anywhere. Error mode is properly reset after each test.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add RESIL-03 stale attachment cleanup regression test to reconciler_test.go</name>
  <files>pkg/attachment/reconciler_test.go</files>
  <action>
Add a new test function to `pkg/attachment/reconciler_test.go` that exercises the full RESIL-03 scenario: stale attachment detection, cleanup, and reattachment to a different node.

WHY unit test instead of E2E: The E2E framework initializes the driver with `K8sClient: nil` (see test/e2e/e2e_suite_test.go line 76), which means no AttachmentManager is created and the reconciler is not available. The `drv` variable is local to BeforeSuite and not exported. The reconciler_test.go already has the exact patterns we need (fake k8s client, createTestListers, direct reconcile() calls).

Add this test function (following the existing test patterns exactly):

```go
func TestReconciler_RESIL03_StaleCleanupAndReattachment(t *testing.T) {
    // Scenario: Volume attached to node-A, node-A is deleted,
    // reconciler clears stale attachment, volume reattaches to node-B.

    // Setup: fake k8s with only node-B (node-A does not exist = "deleted")
    nodeB := &corev1.Node{
        ObjectMeta: metav1.ObjectMeta{Name: "node-b"},
    }
    k8sClient := fake.NewSimpleClientset(nodeB)
    nodeLister, pvLister := createTestListers(k8sClient, nodeB)

    am := NewAttachmentManager(nil)
    ctx := context.Background()
    volumeID := "pvc-resil-03"
    nodeA := "node-a" // This node does NOT exist in k8s

    // Step 1: Track attachment to node-A (simulates ControllerPublishVolume)
    err := am.TrackAttachment(ctx, volumeID, nodeA)
    if err != nil {
        t.Fatalf("TrackAttachment to node-a failed: %v", err)
    }

    // Verify attachment exists on node-A
    state, exists := am.GetAttachment(volumeID)
    if !exists || state.NodeID != nodeA {
        t.Fatalf("Expected attachment on node-a, got exists=%v state=%+v", exists, state)
    }

    // Step 2: Run reconciliation (should detect node-A is gone and clear attachment)
    r, err := NewAttachmentReconciler(ReconcilerConfig{
        Manager:     am,
        K8sClient:   k8sClient,
        NodeLister:  nodeLister,
        PVLister:    pvLister,
        Interval:    100 * time.Millisecond,
        GracePeriod: 1 * time.Nanosecond, // Immediately expired
    })
    if err != nil {
        t.Fatalf("Failed to create reconciler: %v", err)
    }

    r.reconcile(ctx)

    // Step 3: Verify stale attachment was cleared
    _, exists = am.GetAttachment(volumeID)
    if exists {
        t.Error("Expected stale attachment on node-a to be cleared after reconciliation")
    }

    // Step 4: Reattach to node-B (simulates volume moving to surviving node)
    err = am.TrackAttachment(ctx, volumeID, "node-b")
    if err != nil {
        t.Fatalf("TrackAttachment to node-b failed: %v", err)
    }

    // Step 5: Run reconciliation again — attachment on node-B should be preserved
    r.reconcile(ctx)

    state, exists = am.GetAttachment(volumeID)
    if !exists {
        t.Error("Expected attachment on node-b to be preserved (node exists)")
    }
    if exists && state.NodeID != "node-b" {
        t.Errorf("Expected attachment on node-b, got %s", state.NodeID)
    }
}
```

This test covers the full RESIL-03 lifecycle:
1. Volume attached to a node that gets deleted
2. Reconciler detects and clears the stale attachment
3. Volume successfully reattaches to a different surviving node
4. Reconciler preserves the valid attachment on the surviving node
  </action>
  <verify>
Run `go test -v ./pkg/attachment/... -run "RESIL03" -count=1` to verify the new test passes. Run `go test -v ./pkg/attachment/... -count=1` to verify no regressions in existing reconciler tests.
  </verify>
  <done>
RESIL-03 test passes: stale attachment on deleted node is cleared by reconciler, volume reattaches to surviving node, and reconciler preserves the valid reattachment.
  </done>
</task>

</tasks>

<verification>
- `go test -v ./test/e2e/... -ginkgo.v -count=1` passes all existing tests plus new RESIL-01/02 resilience tests
- `go test -v ./pkg/attachment/... -count=1` passes all existing tests plus new RESIL-03 test
- `make test` passes (no regressions)
- `go vet ./test/mock/... ./test/e2e/... ./pkg/attachment/...` clean
</verification>

<success_criteria>
- test/mock/error_injection.go has SetErrorMode() method for runtime error mode changes
- test/e2e/resilience_test.go exists with RESIL-01 and RESIL-02 test scenarios using error injection (NO Stop/Start)
- pkg/attachment/reconciler_test.go has RESIL-03 test covering stale cleanup + reattachment
- All tests pass in CI-compatible mode (mock RDS, no real hardware)
- Existing tests unaffected (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/32-resilience-regression-tests/32-01-SUMMARY.md`
</output>
