---
phase: 32-resilience-regression-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - test/e2e/resilience_test.go
  - test/e2e/helpers.go
autonomous: true

must_haves:
  truths:
    - "After mock SSH disconnect and reconnect, controller volume operations (create, list, delete) succeed without manual intervention"
    - "After mock RDS connection loss, connection manager enters backoff retry and reconnects automatically"
    - "When a node is deleted from Kubernetes, the attachment reconciler detects the stale attachment and clears it within the grace period"
    - "After stale attachment cleanup, the volume can be reattached to a different node"
  artifacts:
    - path: "test/e2e/resilience_test.go"
      provides: "Automated resilience regression test suite"
      min_lines: 150
    - path: "test/e2e/helpers.go"
      provides: "Helper functions for resilience tests (may need additions)"
  key_links:
    - from: "test/e2e/resilience_test.go"
      to: "test/mock/rds_server.go"
      via: "mock RDS error injection"
      pattern: "mockRDS\\.(SetError|InjectError|Stop|Start)"
    - from: "test/e2e/resilience_test.go"
      to: "pkg/attachment/reconciler.go"
      via: "stale attachment cleanup verification"
      pattern: "GetAttachment|ListAttachments|reconcile"
---

<objective>
Create automated E2E resilience regression tests that validate NVMe reconnect, RDS connection recovery, and node failure cleanup using mock infrastructure.

Purpose: These tests run in CI without real hardware and provide regression coverage for the three resilience requirements (RESIL-01, RESIL-02, RESIL-03). They use the existing mock RDS server's error injection capabilities and the in-process driver testing pattern established in test/e2e/.

Output: `test/e2e/resilience_test.go` with Ginkgo test suite covering all three scenarios.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@test/e2e/e2e_suite_test.go
@test/e2e/helpers.go
@test/e2e/fixtures.go
@test/e2e/state_recovery_test.go
@test/e2e/lifecycle_test.go
@test/mock/rds_server.go
@test/mock/error_injection.go
@pkg/rds/connection_manager.go
@pkg/rds/connection_manager_test.go
@pkg/attachment/reconciler.go
@pkg/attachment/reconciler_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resilience regression E2E test suite</name>
  <files>test/e2e/resilience_test.go, test/e2e/helpers.go</files>
  <action>
Create `test/e2e/resilience_test.go` with a Ginkgo Describe("Resilience Regression [RESIL-01/02/03]") block containing three scenario groups. Follow the established patterns in state_recovery_test.go and lifecycle_test.go.

**RESIL-01: NVMe reconnect simulation**
Since the E2E test framework uses an in-process driver with mock RDS (no actual NVMe/TCP), this test validates the *controller-side* reconnection path:
- Create a volume via CreateVolume to establish a working state.
- Use the mock RDS server's error injection to simulate SSH connection failure (set error mode to "ssh_timeout" or use SetPersistentError).
- Attempt a ListVolumes or GetCapacity call and verify it returns an error (connection lost).
- Clear the error injection on the mock RDS server (simulating network recovery).
- After a short delay (to allow connection manager reconnection), retry the volume operation and verify it succeeds.
- Delete the volume to confirm full lifecycle recovery.
- Use Eventually/Consistently Gomega matchers with reasonable timeouts (up to 15s for reconnection).

**RESIL-02: RDS restart simulation**
- Create a volume and write metadata (via CreateVolume with specific name/capacity).
- Stop the mock RDS server entirely (mockRDS.Stop()) to simulate RDS restart.
- Verify that controller operations fail while RDS is down (CreateVolume/ListVolumes return error).
- Restart mock RDS server (mockRDS.Start() again, possibly on a new port or reinitialize).
  - NOTE: The mock RDS is an in-memory SSH server. Stopping and restarting it will lose state. This is by design for this test — it validates the *connection* recovery path, not data persistence (that's a hardware test). The important assertion is that the connection manager reconnects and operations resume.
  - If stopping/restarting the mock loses the SSH host key or port binding, consider instead using the error injection approach: inject persistent errors then clear them. This simulates "RDS unavailable then available" without restarting the server process.
- After recovery, verify GetCapacity succeeds and CreateVolume works for a new volume.

**RESIL-03: Node failure and stale attachment cleanup**
This builds on the existing E2E-06 test but exercises the actual attachment reconciler path:
- Create a volume via CreateVolume.
- Simulate ControllerPublishVolume to track attachment to a specific node (if the driver tracks attachments on publish). Alternatively, directly use the attachment manager's TrackAttachment to set up the state.
  - Check how the E2E framework initializes — if we have access to the driver's attachment manager instance, use it directly.
  - If not directly accessible, verify via ControllerPublishVolume/ControllerUnpublishVolume RPCs.
- The test should verify: when the tracked node no longer exists in the Kubernetes API (the fake k8s client has no such node), the attachment should be clearable.
- Since the E2E framework may not run the full reconciler loop, call reconcile() directly or verify that after the node is removed, a subsequent ControllerUnpublishVolume or volume deletion succeeds (driver doesn't block on stale attachment).
- Verify the volume can be re-published to a different node after stale cleanup.
- Clean up test volume.

If `test/e2e/helpers.go` needs additional helper functions (e.g., for error injection or mock RDS restart), add them there. Keep helpers generic and reusable.

Important constraints:
- Use the same Ginkgo import style as existing tests (`. "github.com/onsi/ginkgo/v2"` and `. "github.com/onsi/gomega"`).
- Use DeferCleanup for volume deletion.
- Use klog for test progress logging (matching existing pattern).
- Wrap assertions in By() blocks for clarity.
- If mock RDS doesn't expose error injection methods directly to the E2E test, check `test/mock/error_injection.go` for available methods and use those.
- The test must pass with `make test-e2e` or `go test -v ./test/e2e/... -ginkgo.v`.
  </action>
  <verify>
Run `go test -v ./test/e2e/... -ginkgo.v -run "Resilience" -count=1` and verify all three scenario groups pass. Also run `go vet ./test/e2e/...` to check for compile errors.
  </verify>
  <done>
Three RESIL test scenarios pass: (1) controller operations recover after mock SSH error injection and clearance, (2) controller operations resume after simulated RDS unavailability, (3) stale attachment for deleted node is detected and cleared, allowing volume reuse.
  </done>
</task>

</tasks>

<verification>
- `go test -v ./test/e2e/... -ginkgo.v -count=1` passes all existing tests plus new resilience tests
- `make test` passes (no regressions in unit tests)
- `go vet ./test/e2e/...` clean
</verification>

<success_criteria>
- test/e2e/resilience_test.go exists with RESIL-01, RESIL-02, RESIL-03 test scenarios
- All three scenarios pass in CI-compatible mode (mock RDS, no real hardware)
- Existing E2E tests unaffected (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/32-resilience-regression-tests/32-01-SUMMARY.md`
</output>
