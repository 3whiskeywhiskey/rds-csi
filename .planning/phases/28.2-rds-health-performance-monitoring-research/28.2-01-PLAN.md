---
phase: 28.2-rds-health-performance-monitoring-research
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/rds/types.go
  - pkg/rds/client.go
  - pkg/rds/commands.go
  - pkg/rds/snmp.go
  - pkg/rds/commands_test.go
  - pkg/rds/snmp_test.go
  - pkg/rds/mock.go
  - go.mod
autonomous: true

must_haves:
  truths:
    - "GetDiskMetrics returns parsed IOPS, throughput, latency, queue depth, and active time from /disk monitor-traffic SSH output"
    - "GetHardwareHealth returns parsed temperature, fan speed, and PSU metrics from SNMP OIDs"
    - "parseDiskMetrics correctly handles all RouterOS SSH output fields including rate units (bps, kbps, Mbps, Gbps)"
    - "SNMP client queries RouterOS MIKROTIK-MIB and HOST-RESOURCES-MIB for hardware health data"
    - "MockClient returns configurable test data for both disk performance and hardware health metrics"
    - "RDSClient interface includes GetDiskMetrics and GetHardwareHealth methods"
  artifacts:
    - path: "pkg/rds/types.go"
      provides: "DiskMetrics and HardwareHealthMetrics structs"
      contains: "type DiskMetrics struct"
    - path: "pkg/rds/client.go"
      provides: "GetDiskMetrics and GetHardwareHealth in RDSClient interface"
      contains: "GetDiskMetrics"
    - path: "pkg/rds/commands.go"
      provides: "SSH command execution and output parsing for disk performance metrics"
      contains: "parseDiskMetrics"
    - path: "pkg/rds/snmp.go"
      provides: "SNMP client for querying RouterOS hardware health OIDs"
      contains: "querySNMP"
    - path: "pkg/rds/commands_test.go"
      provides: "Unit tests for SSH disk metrics parsing with real RouterOS output samples"
      contains: "TestParseDiskMetrics"
    - path: "pkg/rds/snmp_test.go"
      provides: "Unit tests for SNMP hardware health metric collection"
      contains: "TestParseHardwareHealth"
    - path: "pkg/rds/mock.go"
      provides: "MockClient with configurable DiskMetrics and HardwareHealthMetrics"
      contains: "GetDiskMetrics"
    - path: "go.mod"
      provides: "gosnmp dependency for SNMP client"
      contains: "gosnmp"
  key_links:
    - from: "pkg/rds/commands.go"
      to: "pkg/rds/types.go"
      via: "DiskMetrics struct used as return type"
      pattern: "DiskMetrics"
    - from: "pkg/rds/commands.go"
      to: "pkg/rds/client.go"
      via: "sshClient implements GetDiskMetrics from RDSClient interface"
      pattern: "func.*sshClient.*GetDiskMetrics"
---

<objective>
Add RDS monitoring capabilities via both SSH (disk performance) and SNMP (hardware health).

Purpose: Provide comprehensive monitoring data layer combining:
- SSH polling of `/disk monitor-traffic` for disk performance metrics (IOPS, throughput, latency, queue depth)
- SNMP polling of MIKROTIK-MIB for hardware health metrics (temperatures, fan speeds, PSU status, disk capacity)

This dual-approach leverages SSH for metrics unavailable via SNMP, while using lightweight SNMP
for hardware health monitoring. Enables Phase 28.2-02 to expose both metric types via Prometheus.

Output: DiskMetrics + HardwareHealthMetrics types, GetDiskMetrics + GetHardwareHealth on RDSClient
interface, SSH and SNMP client implementations, parsers with unit tests, MockClient support for both.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28.2-rds-health-performance-monitoring-research/28.2-RESEARCH.md

@pkg/rds/types.go
@pkg/rds/client.go
@pkg/rds/commands.go
@pkg/rds/commands_test.go
@pkg/rds/mock.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DiskMetrics and HardwareHealthMetrics types to RDSClient interface</name>
  <files>pkg/rds/types.go, pkg/rds/client.go</files>
  <action>
1. Add the `DiskMetrics` struct to `pkg/rds/types.go` after the existing `SnapshotNotFoundError`:

```go
// DiskMetrics represents real-time disk performance metrics from /disk monitor-traffic
type DiskMetrics struct {
    Slot              string  // Disk slot name (e.g., "storage-pool")
    ReadOpsPerSecond  float64 // Current read IOPS
    WriteOpsPerSecond float64 // Current write IOPS
    ReadBytesPerSec   float64 // Read throughput in bytes/sec (converted from bps)
    WriteBytesPerSec  float64 // Write throughput in bytes/sec (converted from bps)
    ReadTimeMs        float64 // Read latency in milliseconds
    WriteTimeMs       float64 // Write latency in milliseconds
    WaitTimeMs        float64 // Wait/queue latency in milliseconds
    InFlightOps       float64 // Current queue depth (in-flight operations)
    ActiveTimeMs      float64 // Disk active/busy time in milliseconds
}

// HardwareHealthMetrics represents hardware health status from SNMP
type HardwareHealthMetrics struct {
    CPUTemperature    float64 // CPU temperature in Celsius
    BoardTemperature  float64 // Board temperature in Celsius
    Fan1Speed         float64 // Fan 1 RPM
    Fan2Speed         float64 // Fan 2 RPM
    PSU1Power         float64 // PSU 1 power draw in watts
    PSU2Power         float64 // PSU 2 power draw in watts
    PSU1Temperature   float64 // PSU 1 temperature in Celsius
    PSU2Temperature   float64 // PSU 2 temperature in Celsius
    DiskPoolSizeBytes float64 // RAID6 pool total size in bytes
    DiskPoolUsedBytes float64 // RAID6 pool used space in bytes
}
```

2. Add monitoring methods to the `RDSClient` interface in `pkg/rds/client.go`, in a new
"Monitoring" comment section after the Snapshot operations section:

```go
    // Monitoring operations
    GetDiskMetrics(slot string) (*DiskMetrics, error)
    GetHardwareHealth(snmpHost string, snmpCommunity string) (*HardwareHealthMetrics, error)
```

This follows the existing interface pattern (return pointer + error).
  </action>
  <verify>Run `go build ./...` from repo root - must compile without errors (interface satisfaction check will fail until Tasks 2-3 implement the methods, but types should compile).</verify>
  <done>DiskMetrics struct exists in types.go with all 10 fields. HardwareHealthMetrics struct exists with 10 hardware health fields. GetDiskMetrics and GetHardwareHealth methods exist in RDSClient interface.</done>
</task>

<task type="auto">
  <name>Task 2: Implement GetDiskMetrics SSH command, parser, mock, and unit tests</name>
  <files>pkg/rds/commands.go, pkg/rds/commands_test.go, pkg/rds/mock.go</files>
  <action>
1. **Add GetDiskMetrics to sshClient** in `pkg/rds/commands.go` after the existing `RestoreSnapshot` function (before the parser functions section):

```go
// GetDiskMetrics retrieves real-time disk performance metrics via /disk monitor-traffic
// Uses "once" modifier to get a single snapshot instead of continuous stream output.
// The slot parameter is the disk slot name (e.g., "storage-pool") or disk number.
func (c *sshClient) GetDiskMetrics(slot string) (*DiskMetrics, error) {
    klog.V(4).Infof("Getting disk metrics for %s", slot)

    // Validate slot name to prevent command injection
    if err := validateSlotName(slot); err != nil {
        return nil, err
    }

    // Use "once" to get snapshot, not continuous stream
    // Continuous output uses terminal control sequences that break parsing
    cmd := fmt.Sprintf(`/disk monitor-traffic %s once`, slot)

    output, err := c.runCommand(cmd)
    if err != nil {
        return nil, fmt.Errorf("failed to get disk metrics: %w", err)
    }

    metrics, err := parseDiskMetrics(output)
    if err != nil {
        return nil, fmt.Errorf("failed to parse disk metrics: %w", err)
    }

    metrics.Slot = slot
    return metrics, nil
}
```

2. **Add parseDiskMetrics** after GetDiskMetrics:

```go
// parseDiskMetrics parses /disk monitor-traffic output into DiskMetrics
// Expected format (from RouterOS):
//     slot: storage-pool
//     read-ops-per-second:               0
//     write-ops-per-second:             76
//     read-rate:            0bps
//     write-rate:        12.8Mbps
//     read-time:             0ms
//     write-time:             0ms
//     in-flight-ops:               0
//     active-time:             0ms
//     wait-time:             0ms
func parseDiskMetrics(output string) (*DiskMetrics, error) {
    metrics := &DiskMetrics{}

    // Parse integer fields (IOPS, in-flight-ops)
    intFields := map[string]*float64{
        `read-ops-per-second:\s+(\d+)`:  &metrics.ReadOpsPerSecond,
        `write-ops-per-second:\s+(\d+)`: &metrics.WriteOpsPerSecond,
        `in-flight-ops:\s+(\d+)`:        &metrics.InFlightOps,
    }

    for pattern, field := range intFields {
        re := regexp.MustCompile(pattern)
        if matches := re.FindStringSubmatch(output); len(matches) > 1 {
            value, err := strconv.ParseFloat(matches[1], 64)
            if err == nil {
                *field = value
            }
        }
    }

    // Parse rate fields with units (e.g., "0bps", "12.8Mbps", "1.5Gbps")
    rateFields := map[string]*float64{
        `read-rate:\s+([\d.]+)\s*(\w+)`:  &metrics.ReadBytesPerSec,
        `write-rate:\s+([\d.]+)\s*(\w+)`: &metrics.WriteBytesPerSec,
    }

    for pattern, field := range rateFields {
        re := regexp.MustCompile(pattern)
        if matches := re.FindStringSubmatch(output); len(matches) > 2 {
            value, err := strconv.ParseFloat(matches[1], 64)
            if err == nil {
                *field = convertRateToBytesPerSec(value, matches[2])
            }
        }
    }

    // Parse time fields (ms suffix)
    timeFields := map[string]*float64{
        `read-time:\s+([\d.]+)\s*ms`:   &metrics.ReadTimeMs,
        `write-time:\s+([\d.]+)\s*ms`:  &metrics.WriteTimeMs,
        `wait-time:\s+([\d.]+)\s*ms`:   &metrics.WaitTimeMs,
        `active-time:\s+([\d.]+)\s*ms`: &metrics.ActiveTimeMs,
    }

    for pattern, field := range timeFields {
        re := regexp.MustCompile(pattern)
        if matches := re.FindStringSubmatch(output); len(matches) > 1 {
            value, err := strconv.ParseFloat(matches[1], 64)
            if err == nil {
                *field = value
            }
        }
    }

    return metrics, nil
}

// convertRateToBytesPerSec converts RouterOS rate units to bytes per second
// RouterOS reports rates in bits per second with unit suffixes: bps, kbps, Mbps, Gbps
func convertRateToBytesPerSec(value float64, unit string) float64 {
    switch unit {
    case "bps":
        return value / 8
    case "kbps", "Kbps":
        return (value * 1000) / 8
    case "Mbps":
        return (value * 1_000_000) / 8
    case "Gbps":
        return (value * 1_000_000_000) / 8
    default:
        return value
    }
}
```

3. **Add MockClient.GetDiskMetrics** to `pkg/rds/mock.go` after the existing `RestoreSnapshot` method. Add a `diskMetrics` field to MockClient and a setter:

Add to MockClient struct:
```go
diskMetrics *DiskMetrics // Configurable disk metrics response (test helper)
```

Add methods:
```go
// SetDiskMetrics sets the disk metrics response for testing
func (m *MockClient) SetDiskMetrics(metrics *DiskMetrics) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.diskMetrics = metrics
}

// GetDiskMetrics implements RDSClient
func (m *MockClient) GetDiskMetrics(slot string) (*DiskMetrics, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    // Check for pending error
    if m.persistentErr != nil {
        return nil, m.persistentErr
    }
    if m.nextError != nil {
        err := m.nextError
        m.nextError = nil
        return nil, err
    }

    if m.diskMetrics != nil {
        copy := *m.diskMetrics
        copy.Slot = slot
        return &copy, nil
    }

    // Return zero metrics by default (idle disk)
    return &DiskMetrics{Slot: slot}, nil
}
```

NOTE: The mock's GetDiskMetrics should NOT call checkError() because that method takes a write lock and we're using RLock. Instead inline the error checks with appropriate locking, or change to Lock(). Looking at existing mock code, most methods use Lock() -- use Lock() here too for consistency.

4. **Add unit tests** in `pkg/rds/commands_test.go`:

```go
func TestParseDiskMetrics(t *testing.T) {
    tests := []struct {
        name     string
        output   string
        expected *DiskMetrics
    }{
        {
            name: "full output with active writes",
            output: `                  slot:    storage-pool
              read-ops:         243 401
   read-ops-per-second:               0
            read-bytes:  33 131 503 616
             read-rate:            0bps
           read-merges:               0
             read-time:             0ms
             write-ops:      17 667 231
  write-ops-per-second:              76
           write-bytes: 515 659 673 600
            write-rate:        12.8Mbps
          write-merges:               0
            write-time:             0ms
         in-flight-ops:               0
           active-time:             0ms
             wait-time:             0ms
           discard-ops:               0
         discard-bytes:               0
        discard-merges:               0
          discard-time:             0ms
             flush-ops:               0
            flush-time:             0ms`,
            expected: &DiskMetrics{
                ReadOpsPerSecond:  0,
                WriteOpsPerSecond: 76,
                ReadBytesPerSec:   0,
                WriteBytesPerSec:  1_600_000, // 12.8Mbps = 12.8 * 1_000_000 / 8 = 1_600_000
                ReadTimeMs:        0,
                WriteTimeMs:       0,
                WaitTimeMs:        0,
                InFlightOps:       0,
                ActiveTimeMs:      0,
            },
        },
        {
            name: "active reads with Gbps throughput",
            output: `   read-ops-per-second:            1500
  write-ops-per-second:             200
             read-rate:         1.5Gbps
            write-rate:       100.0Mbps
             read-time:             2ms
            write-time:             5ms
         in-flight-ops:               8
           active-time:            10ms
             wait-time:             1ms`,
            expected: &DiskMetrics{
                ReadOpsPerSecond:  1500,
                WriteOpsPerSecond: 200,
                ReadBytesPerSec:   187_500_000, // 1.5Gbps = 1.5 * 1_000_000_000 / 8
                WriteBytesPerSec:  12_500_000,  // 100Mbps = 100 * 1_000_000 / 8
                ReadTimeMs:        2,
                WriteTimeMs:       5,
                WaitTimeMs:        1,
                InFlightOps:       8,
                ActiveTimeMs:      10,
            },
        },
        {
            name: "idle disk - all zeros",
            output: `   read-ops-per-second:               0
  write-ops-per-second:               0
             read-rate:            0bps
            write-rate:            0bps
             read-time:             0ms
            write-time:             0ms
         in-flight-ops:               0
           active-time:             0ms
             wait-time:             0ms`,
            expected: &DiskMetrics{},
        },
        {
            name: "kbps throughput",
            output: `   read-ops-per-second:              10
  write-ops-per-second:               5
             read-rate:          500kbps
            write-rate:          250kbps
             read-time:             0ms
            write-time:             0ms
         in-flight-ops:               1
           active-time:             0ms
             wait-time:             0ms`,
            expected: &DiskMetrics{
                ReadOpsPerSecond:  10,
                WriteOpsPerSecond: 5,
                ReadBytesPerSec:   62_500,  // 500kbps = 500 * 1000 / 8
                WriteBytesPerSec:  31_250,  // 250kbps = 250 * 1000 / 8
                InFlightOps:       1,
            },
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := parseDiskMetrics(tt.output)
            if err != nil {
                t.Fatalf("parseDiskMetrics failed: %v", err)
            }

            if result.ReadOpsPerSecond != tt.expected.ReadOpsPerSecond {
                t.Errorf("ReadOpsPerSecond: got %v, want %v", result.ReadOpsPerSecond, tt.expected.ReadOpsPerSecond)
            }
            if result.WriteOpsPerSecond != tt.expected.WriteOpsPerSecond {
                t.Errorf("WriteOpsPerSecond: got %v, want %v", result.WriteOpsPerSecond, tt.expected.WriteOpsPerSecond)
            }
            if result.ReadBytesPerSec != tt.expected.ReadBytesPerSec {
                t.Errorf("ReadBytesPerSec: got %v, want %v", result.ReadBytesPerSec, tt.expected.ReadBytesPerSec)
            }
            if result.WriteBytesPerSec != tt.expected.WriteBytesPerSec {
                t.Errorf("WriteBytesPerSec: got %v, want %v", result.WriteBytesPerSec, tt.expected.WriteBytesPerSec)
            }
            if result.ReadTimeMs != tt.expected.ReadTimeMs {
                t.Errorf("ReadTimeMs: got %v, want %v", result.ReadTimeMs, tt.expected.ReadTimeMs)
            }
            if result.WriteTimeMs != tt.expected.WriteTimeMs {
                t.Errorf("WriteTimeMs: got %v, want %v", result.WriteTimeMs, tt.expected.WriteTimeMs)
            }
            if result.WaitTimeMs != tt.expected.WaitTimeMs {
                t.Errorf("WaitTimeMs: got %v, want %v", result.WaitTimeMs, tt.expected.WaitTimeMs)
            }
            if result.InFlightOps != tt.expected.InFlightOps {
                t.Errorf("InFlightOps: got %v, want %v", result.InFlightOps, tt.expected.InFlightOps)
            }
            if result.ActiveTimeMs != tt.expected.ActiveTimeMs {
                t.Errorf("ActiveTimeMs: got %v, want %v", result.ActiveTimeMs, tt.expected.ActiveTimeMs)
            }
        })
    }
}

func TestConvertRateToBytesPerSec(t *testing.T) {
    tests := []struct {
        value    float64
        unit     string
        expected float64
    }{
        {0, "bps", 0},
        {8, "bps", 1},
        {500, "kbps", 62_500},
        {12.8, "Mbps", 1_600_000},
        {1.5, "Gbps", 187_500_000},
        {100, "unknown", 100}, // Unknown unit returns raw value
    }

    for _, tt := range tests {
        t.Run(fmt.Sprintf("%v_%s", tt.value, tt.unit), func(t *testing.T) {
            result := convertRateToBytesPerSec(tt.value, tt.unit)
            if result != tt.expected {
                t.Errorf("convertRateToBytesPerSec(%v, %q) = %v, want %v", tt.value, tt.unit, result, tt.expected)
            }
        })
    }
}
```

5. Run `make test` - all tests must pass including new parsing tests.
6. Run `go build ./...` - must compile (interface satisfaction verified).
  </action>
  <verify>
Run `make test` - all tests pass.
Run `go build ./...` - compiles without errors.
Grep for `GetDiskMetrics` appears in: types.go (NO - this is the struct), client.go (interface), commands.go (sshClient impl), commands_test.go (tests), mock.go (mock impl).
  </verify>
  <done>
DiskMetrics type defined with 10 fields. GetDiskMetrics in RDSClient interface. sshClient implements GetDiskMetrics via SSH `/disk monitor-traffic <slot> once`. parseDiskMetrics handles all RouterOS output fields. convertRateToBytesPerSec converts bps/kbps/Mbps/Gbps to bytes/sec. MockClient.GetDiskMetrics returns configurable test data. 4+ test cases cover: active writes with Mbps, active reads with Gbps, idle disk, kbps throughput. Rate conversion tested with all unit types.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement SNMP hardware health collection, parser, mock, and unit tests</name>
  <files>pkg/rds/snmp.go, pkg/rds/snmp_test.go, pkg/rds/mock.go, go.mod</files>
  <action>
1. **Add gosnmp dependency** to `go.mod`:

```bash
go get github.com/gosnmp/gosnmp@v1.37.0
```

2. **Create `pkg/rds/snmp.go`** with SNMP client implementation:

```go
package rds

import (
    "fmt"
    "time"

    "github.com/gosnmp/gosnmp"
)

// SNMP OIDs for MikroTik RouterOS hardware monitoring
const (
    // MIKROTIK-MIB::mtxrHealth (1.3.6.1.4.1.14988.1.1.3)
    oidCPUTemperature    = "1.3.6.1.4.1.14988.1.1.3.100.1.3.17"
    oidBoardTemperature  = "1.3.6.1.4.1.14988.1.1.3.100.1.3.7101"
    oidFan1Speed         = "1.3.6.1.4.1.14988.1.1.3.100.1.3.7001"
    oidFan2Speed         = "1.3.6.1.4.1.14988.1.1.3.100.1.3.7002"
    oidPSU1Power         = "1.3.6.1.4.1.14988.1.1.3.100.1.3.7501"
    oidPSU2Power         = "1.3.6.1.4.1.14988.1.1.3.100.1.3.7502"
    oidPSU1Temperature   = "1.3.6.1.4.1.14988.1.1.3.100.1.3.7601"
    oidPSU2Temperature   = "1.3.6.1.4.1.14988.1.1.3.100.1.3.7602"

    // HOST-RESOURCES-MIB::hrStorageTable (1.3.6.1.2.1.25.2.3)
    // Index 262170 = RAID6 pool (from snmpwalk discovery)
    oidRAID6PoolSize  = "1.3.6.1.2.1.25.2.3.1.5.262170" // hrStorageSize * hrStorageAllocationUnits
    oidRAID6PoolUsed  = "1.3.6.1.2.1.25.2.3.1.6.262170" // hrStorageUsed * hrStorageAllocationUnits
    oidRAID6PoolUnits = "1.3.6.1.2.1.25.2.3.1.4.262170" // hrStorageAllocationUnits
)

// GetHardwareHealth retrieves hardware health metrics via SNMP
func (c *sshClient) GetHardwareHealth(snmpHost string, snmpCommunity string) (*HardwareHealthMetrics, error) {
    metrics := &HardwareHealthMetrics{}

    // Configure SNMP client
    snmpClient := &gosnmp.GoSNMP{
        Target:    snmpHost,
        Port:      161,
        Community: snmpCommunity,
        Version:   gosnmp.Version2c,
        Timeout:   time.Duration(5) * time.Second,
        Retries:   2,
    }

    err := snmpClient.Connect()
    if err != nil {
        return nil, fmt.Errorf("SNMP connect failed: %w", err)
    }
    defer snmpClient.Conn.Close()

    // Query all OIDs in one request for efficiency
    oids := []string{
        oidCPUTemperature, oidBoardTemperature,
        oidFan1Speed, oidFan2Speed,
        oidPSU1Power, oidPSU2Power,
        oidPSU1Temperature, oidPSU2Temperature,
        oidRAID6PoolUnits, oidRAID6PoolSize, oidRAID6PoolUsed,
    }

    result, err := snmpClient.Get(oids)
    if err != nil {
        return nil, fmt.Errorf("SNMP get failed: %w", err)
    }

    // Parse results (convert from SNMP PDU variables to metrics)
    if len(result.Variables) >= 11 {
        metrics.CPUTemperature = parseFloat64(result.Variables[0])
        metrics.BoardTemperature = parseFloat64(result.Variables[1])
        metrics.Fan1Speed = parseFloat64(result.Variables[2])
        metrics.Fan2Speed = parseFloat64(result.Variables[3])
        metrics.PSU1Power = parseFloat64(result.Variables[4])
        metrics.PSU2Power = parseFloat64(result.Variables[5])
        metrics.PSU1Temperature = parseFloat64(result.Variables[6])
        metrics.PSU2Temperature = parseFloat64(result.Variables[7])

        // Disk capacity calculation: size/used * allocation_units
        units := parseFloat64(result.Variables[8])
        size := parseFloat64(result.Variables[9])
        used := parseFloat64(result.Variables[10])
        metrics.DiskPoolSizeBytes = size * units
        metrics.DiskPoolUsedBytes = used * units
    }

    return metrics, nil
}

// parseFloat64 converts gosnmp.SnmpPDU value to float64
func parseFloat64(pdu gosnmp.SnmpPDU) float64 {
    switch pdu.Type {
    case gosnmp.Integer:
        return float64(pdu.Value.(int))
    case gosnmp.Gauge32, gosnmp.Counter32, gosnmp.Counter64:
        switch v := pdu.Value.(type) {
        case int:
            return float64(v)
        case uint:
            return float64(v)
        case uint64:
            return float64(v)
        default:
            return 0
        }
    default:
        return 0
    }
}
```

3. **Add MockClient.GetHardwareHealth** to `pkg/rds/mock.go`:

Add to MockClient struct:
```go
hardwareHealth *HardwareHealthMetrics // Configurable hardware health response (test helper)
```

Add methods:
```go
// SetHardwareHealth sets the hardware health metrics response for testing
func (m *MockClient) SetHardwareHealth(metrics *HardwareHealthMetrics) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.hardwareHealth = metrics
}

// GetHardwareHealth implements RDSClient
func (m *MockClient) GetHardwareHealth(snmpHost string, snmpCommunity string) (*HardwareHealthMetrics, error) {
    m.mu.Lock()
    defer m.mu.Unlock()

    // Check for pending error
    if m.persistentErr != nil {
        return nil, m.persistentErr
    }
    if m.nextError != nil {
        err := m.nextError
        m.nextError = nil
        return nil, err
    }

    if m.hardwareHealth != nil {
        copy := *m.hardwareHealth
        return &copy, nil
    }

    // Return reasonable defaults (healthy system)
    return &HardwareHealthMetrics{
        CPUTemperature:    40,
        BoardTemperature:  35,
        Fan1Speed:         7500,
        Fan2Speed:         7600,
        PSU1Power:         700,
        PSU2Power:         680,
        PSU1Temperature:   25,
        PSU2Temperature:   25,
        DiskPoolSizeBytes: 8_000_000_000_000, // 8TB
        DiskPoolUsedBytes: 1_600_000_000_000, // 1.6TB (20% used)
    }, nil
}
```

4. **Create `pkg/rds/snmp_test.go`** with unit tests:

```go
package rds

import (
    "testing"
)

func TestParseFloat64(t *testing.T) {
    tests := []struct {
        name     string
        pduType  gosnmp.Asn1BER
        pduValue interface{}
        expected float64
    }{
        {"Integer", gosnmp.Integer, 42, 42.0},
        {"Gauge32", gosnmp.Gauge32, uint(7500), 7500.0},
        {"Counter32", gosnmp.Counter32, uint(1000), 1000.0},
        {"Unknown type", gosnmp.OctetString, "test", 0.0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            pdu := gosnmp.SnmpPDU{
                Type:  tt.pduType,
                Value: tt.pduValue,
            }
            result := parseFloat64(pdu)
            if result != tt.expected {
                t.Errorf("parseFloat64() = %v, want %v", result, tt.expected)
            }
        })
    }
}

func TestMockClient_GetHardwareHealth(t *testing.T) {
    client := NewMockClient()

    // Test default response
    health, err := client.GetHardwareHealth("10.42.67.1", "public")
    if err != nil {
        t.Fatalf("GetHardwareHealth() error = %v", err)
    }
    if health.CPUTemperature != 40 {
        t.Errorf("CPUTemperature = %v, want 40", health.CPUTemperature)
    }
    if health.DiskPoolSizeBytes != 8_000_000_000_000 {
        t.Errorf("DiskPoolSizeBytes = %v, want 8TB", health.DiskPoolSizeBytes)
    }

    // Test custom response
    custom := &HardwareHealthMetrics{
        CPUTemperature:    55,
        Fan1Speed:         8000,
        DiskPoolSizeBytes: 10_000_000_000_000,
        DiskPoolUsedBytes: 5_000_000_000_000,
    }
    client.SetHardwareHealth(custom)

    health, err = client.GetHardwareHealth("10.42.67.1", "public")
    if err != nil {
        t.Fatalf("GetHardwareHealth() error = %v", err)
    }
    if health.CPUTemperature != 55 {
        t.Errorf("CPUTemperature = %v, want 55", health.CPUTemperature)
    }
    if health.Fan1Speed != 8000 {
        t.Errorf("Fan1Speed = %v, want 8000", health.Fan1Speed)
    }

    // Test error injection
    client.SetNextError(fmt.Errorf("SNMP timeout"))
    _, err = client.GetHardwareHealth("10.42.67.1", "public")
    if err == nil || err.Error() != "SNMP timeout" {
        t.Errorf("Expected SNMP timeout error, got %v", err)
    }
}
```

5. Run `go mod tidy` to update dependencies.
6. Run `make test` - all tests must pass including new SNMP tests.
7. Run `go build ./...` - must compile (interface satisfaction verified).
  </action>
  <verify>
Run `make test` - all tests pass.
Run `go build ./...` - compiles without errors.
Grep for `GetHardwareHealth` appears in: client.go (interface), snmp.go (sshClient impl), snmp_test.go (tests), mock.go (mock impl).
Grep for `gosnmp` appears in: go.mod, snmp.go.
  </verify>
  <done>
HardwareHealthMetrics type defined with 10 hardware health fields. GetHardwareHealth in RDSClient interface. sshClient implements GetHardwareHealth via SNMP OID queries. parseFloat64 converts SNMP PDU types to float64. MockClient.GetHardwareHealth returns configurable test data with reasonable defaults. gosnmp v1.37.0 dependency added. SNMP OIDs documented for CPU temp, board temp, fans, PSUs, RAID6 pool capacity. Unit tests cover PDU parsing and mock behavior.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors (interface satisfaction verified across sshClient and MockClient)
2. `make test` passes (all existing tests + TestParseDiskMetrics + TestConvertRateToBytesPerSec + TestParseFloat64 + TestMockClient_GetHardwareHealth)
3. `grep -r "GetDiskMetrics" pkg/rds/` shows matches in client.go, commands.go, commands_test.go, mock.go
4. `grep -r "GetHardwareHealth" pkg/rds/` shows matches in client.go, snmp.go, snmp_test.go, mock.go
5. `grep -r "DiskMetrics\|HardwareHealthMetrics" pkg/rds/types.go` shows both struct definitions
6. `grep "gosnmp" go.mod` shows dependency added
</verification>

<success_criteria>
1. DiskMetrics struct captures all 10 fields from /disk monitor-traffic SSH output
2. HardwareHealthMetrics struct captures all 10 hardware health fields from SNMP OIDs
3. parseDiskMetrics correctly parses real RouterOS SSH output format
4. parseFloat64 correctly converts SNMP PDU types (Integer, Gauge32, Counter32) to float64
5. Rate conversion handles bps, kbps, Mbps, Gbps correctly for throughput metrics
6. SNMP client queries correct OIDs from MIKROTIK-MIB and HOST-RESOURCES-MIB
7. MockClient supports configurable responses via SetDiskMetrics and SetHardwareHealth
8. All unit tests pass with real-world output samples and SNMP PDU types
9. Interface compilation verified (sshClient and MockClient both implement GetDiskMetrics and GetHardwareHealth)
10. gosnmp dependency added to go.mod
</success_criteria>

<output>
After completion, create `.planning/phases/28.2-rds-health-performance-monitoring-research/28.2-01-SUMMARY.md`
</output>
