---
phase: 28.2-rds-health-performance-monitoring-research
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/rds/types.go
  - pkg/rds/client.go
  - pkg/rds/commands.go
  - pkg/rds/commands_test.go
  - pkg/rds/mock.go
autonomous: true

must_haves:
  truths:
    - "GetDiskMetrics returns parsed IOPS, throughput, latency, queue depth, and active time from /disk monitor-traffic output"
    - "parseDiskMetrics correctly handles all RouterOS output fields including rate units (bps, kbps, Mbps, Gbps)"
    - "MockClient.GetDiskMetrics returns configurable test data for downstream metric tests"
    - "RDSClient interface includes GetDiskMetrics method"
  artifacts:
    - path: "pkg/rds/types.go"
      provides: "DiskMetrics struct with all monitor-traffic fields"
      contains: "type DiskMetrics struct"
    - path: "pkg/rds/client.go"
      provides: "GetDiskMetrics in RDSClient interface"
      contains: "GetDiskMetrics"
    - path: "pkg/rds/commands.go"
      provides: "SSH command execution and output parsing for disk metrics"
      contains: "parseDiskMetrics"
    - path: "pkg/rds/commands_test.go"
      provides: "Unit tests for disk metrics parsing with real RouterOS output samples"
      contains: "TestParseDiskMetrics"
    - path: "pkg/rds/mock.go"
      provides: "MockClient.GetDiskMetrics with configurable DiskMetrics"
      contains: "GetDiskMetrics"
  key_links:
    - from: "pkg/rds/commands.go"
      to: "pkg/rds/types.go"
      via: "DiskMetrics struct used as return type"
      pattern: "DiskMetrics"
    - from: "pkg/rds/commands.go"
      to: "pkg/rds/client.go"
      via: "sshClient implements GetDiskMetrics from RDSClient interface"
      pattern: "func.*sshClient.*GetDiskMetrics"
---

<objective>
Add RDS disk traffic monitoring command support to the SSH client layer.

Purpose: Provide the foundational data layer for RDS storage health metrics by implementing
the `/disk monitor-traffic <slot> once` SSH command, output parsing, and type definitions.
This enables Phase 28.2-02 to wire these into Prometheus GaugeFunc collectors.

Output: DiskMetrics type, GetDiskMetrics on RDSClient interface, SSH command implementation,
parser with unit tests, MockClient implementation.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28.2-rds-health-performance-monitoring-research/28.2-RESEARCH.md

@pkg/rds/types.go
@pkg/rds/client.go
@pkg/rds/commands.go
@pkg/rds/commands_test.go
@pkg/rds/mock.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DiskMetrics type and GetDiskMetrics to RDSClient interface</name>
  <files>pkg/rds/types.go, pkg/rds/client.go</files>
  <action>
1. Add the `DiskMetrics` struct to `pkg/rds/types.go` after the existing `SnapshotNotFoundError`:

```go
// DiskMetrics represents real-time disk performance metrics from /disk monitor-traffic
type DiskMetrics struct {
    Slot              string  // Disk slot name (e.g., "storage-pool")
    ReadOpsPerSecond  float64 // Current read IOPS
    WriteOpsPerSecond float64 // Current write IOPS
    ReadBytesPerSec   float64 // Read throughput in bytes/sec (converted from bps)
    WriteBytesPerSec  float64 // Write throughput in bytes/sec (converted from bps)
    ReadTimeMs        float64 // Read latency in milliseconds
    WriteTimeMs       float64 // Write latency in milliseconds
    WaitTimeMs        float64 // Wait/queue latency in milliseconds
    InFlightOps       float64 // Current queue depth (in-flight operations)
    ActiveTimeMs      float64 // Disk active/busy time in milliseconds
}
```

2. Add `GetDiskMetrics` to the `RDSClient` interface in `pkg/rds/client.go`, in a new
"Monitoring" comment section after the Snapshot operations section:

```go
    // Monitoring operations
    GetDiskMetrics(slot string) (*DiskMetrics, error)
```

This follows the existing interface pattern (return pointer + error).
  </action>
  <verify>Run `go build ./...` from repo root - must compile without errors (interface satisfaction check will fail until Task 2 implements the methods, but types should compile).</verify>
  <done>DiskMetrics struct exists in types.go with all 10 fields. GetDiskMetrics method exists in RDSClient interface.</done>
</task>

<task type="auto">
  <name>Task 2: Implement GetDiskMetrics SSH command, parser, mock, and unit tests</name>
  <files>pkg/rds/commands.go, pkg/rds/commands_test.go, pkg/rds/mock.go</files>
  <action>
1. **Add GetDiskMetrics to sshClient** in `pkg/rds/commands.go` after the existing `RestoreSnapshot` function (before the parser functions section):

```go
// GetDiskMetrics retrieves real-time disk performance metrics via /disk monitor-traffic
// Uses "once" modifier to get a single snapshot instead of continuous stream output.
// The slot parameter is the disk slot name (e.g., "storage-pool") or disk number.
func (c *sshClient) GetDiskMetrics(slot string) (*DiskMetrics, error) {
    klog.V(4).Infof("Getting disk metrics for %s", slot)

    // Validate slot name to prevent command injection
    if err := validateSlotName(slot); err != nil {
        return nil, err
    }

    // Use "once" to get snapshot, not continuous stream
    // Continuous output uses terminal control sequences that break parsing
    cmd := fmt.Sprintf(`/disk monitor-traffic %s once`, slot)

    output, err := c.runCommand(cmd)
    if err != nil {
        return nil, fmt.Errorf("failed to get disk metrics: %w", err)
    }

    metrics, err := parseDiskMetrics(output)
    if err != nil {
        return nil, fmt.Errorf("failed to parse disk metrics: %w", err)
    }

    metrics.Slot = slot
    return metrics, nil
}
```

2. **Add parseDiskMetrics** after GetDiskMetrics:

```go
// parseDiskMetrics parses /disk monitor-traffic output into DiskMetrics
// Expected format (from RouterOS):
//     slot: storage-pool
//     read-ops-per-second:               0
//     write-ops-per-second:             76
//     read-rate:            0bps
//     write-rate:        12.8Mbps
//     read-time:             0ms
//     write-time:             0ms
//     in-flight-ops:               0
//     active-time:             0ms
//     wait-time:             0ms
func parseDiskMetrics(output string) (*DiskMetrics, error) {
    metrics := &DiskMetrics{}

    // Parse integer fields (IOPS, in-flight-ops)
    intFields := map[string]*float64{
        `read-ops-per-second:\s+(\d+)`:  &metrics.ReadOpsPerSecond,
        `write-ops-per-second:\s+(\d+)`: &metrics.WriteOpsPerSecond,
        `in-flight-ops:\s+(\d+)`:        &metrics.InFlightOps,
    }

    for pattern, field := range intFields {
        re := regexp.MustCompile(pattern)
        if matches := re.FindStringSubmatch(output); len(matches) > 1 {
            value, err := strconv.ParseFloat(matches[1], 64)
            if err == nil {
                *field = value
            }
        }
    }

    // Parse rate fields with units (e.g., "0bps", "12.8Mbps", "1.5Gbps")
    rateFields := map[string]*float64{
        `read-rate:\s+([\d.]+)\s*(\w+)`:  &metrics.ReadBytesPerSec,
        `write-rate:\s+([\d.]+)\s*(\w+)`: &metrics.WriteBytesPerSec,
    }

    for pattern, field := range rateFields {
        re := regexp.MustCompile(pattern)
        if matches := re.FindStringSubmatch(output); len(matches) > 2 {
            value, err := strconv.ParseFloat(matches[1], 64)
            if err == nil {
                *field = convertRateToBytesPerSec(value, matches[2])
            }
        }
    }

    // Parse time fields (ms suffix)
    timeFields := map[string]*float64{
        `read-time:\s+([\d.]+)\s*ms`:   &metrics.ReadTimeMs,
        `write-time:\s+([\d.]+)\s*ms`:  &metrics.WriteTimeMs,
        `wait-time:\s+([\d.]+)\s*ms`:   &metrics.WaitTimeMs,
        `active-time:\s+([\d.]+)\s*ms`: &metrics.ActiveTimeMs,
    }

    for pattern, field := range timeFields {
        re := regexp.MustCompile(pattern)
        if matches := re.FindStringSubmatch(output); len(matches) > 1 {
            value, err := strconv.ParseFloat(matches[1], 64)
            if err == nil {
                *field = value
            }
        }
    }

    return metrics, nil
}

// convertRateToBytesPerSec converts RouterOS rate units to bytes per second
// RouterOS reports rates in bits per second with unit suffixes: bps, kbps, Mbps, Gbps
func convertRateToBytesPerSec(value float64, unit string) float64 {
    switch unit {
    case "bps":
        return value / 8
    case "kbps", "Kbps":
        return (value * 1000) / 8
    case "Mbps":
        return (value * 1_000_000) / 8
    case "Gbps":
        return (value * 1_000_000_000) / 8
    default:
        return value
    }
}
```

3. **Add MockClient.GetDiskMetrics** to `pkg/rds/mock.go` after the existing `RestoreSnapshot` method. Add a `diskMetrics` field to MockClient and a setter:

Add to MockClient struct:
```go
diskMetrics *DiskMetrics // Configurable disk metrics response (test helper)
```

Add methods:
```go
// SetDiskMetrics sets the disk metrics response for testing
func (m *MockClient) SetDiskMetrics(metrics *DiskMetrics) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.diskMetrics = metrics
}

// GetDiskMetrics implements RDSClient
func (m *MockClient) GetDiskMetrics(slot string) (*DiskMetrics, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    // Check for pending error
    if m.persistentErr != nil {
        return nil, m.persistentErr
    }
    if m.nextError != nil {
        err := m.nextError
        m.nextError = nil
        return nil, err
    }

    if m.diskMetrics != nil {
        copy := *m.diskMetrics
        copy.Slot = slot
        return &copy, nil
    }

    // Return zero metrics by default (idle disk)
    return &DiskMetrics{Slot: slot}, nil
}
```

NOTE: The mock's GetDiskMetrics should NOT call checkError() because that method takes a write lock and we're using RLock. Instead inline the error checks with appropriate locking, or change to Lock(). Looking at existing mock code, most methods use Lock() -- use Lock() here too for consistency.

4. **Add unit tests** in `pkg/rds/commands_test.go`:

```go
func TestParseDiskMetrics(t *testing.T) {
    tests := []struct {
        name     string
        output   string
        expected *DiskMetrics
    }{
        {
            name: "full output with active writes",
            output: `                  slot:    storage-pool
              read-ops:         243 401
   read-ops-per-second:               0
            read-bytes:  33 131 503 616
             read-rate:            0bps
           read-merges:               0
             read-time:             0ms
             write-ops:      17 667 231
  write-ops-per-second:              76
           write-bytes: 515 659 673 600
            write-rate:        12.8Mbps
          write-merges:               0
            write-time:             0ms
         in-flight-ops:               0
           active-time:             0ms
             wait-time:             0ms
           discard-ops:               0
         discard-bytes:               0
        discard-merges:               0
          discard-time:             0ms
             flush-ops:               0
            flush-time:             0ms`,
            expected: &DiskMetrics{
                ReadOpsPerSecond:  0,
                WriteOpsPerSecond: 76,
                ReadBytesPerSec:   0,
                WriteBytesPerSec:  1_600_000, // 12.8Mbps = 12.8 * 1_000_000 / 8 = 1_600_000
                ReadTimeMs:        0,
                WriteTimeMs:       0,
                WaitTimeMs:        0,
                InFlightOps:       0,
                ActiveTimeMs:      0,
            },
        },
        {
            name: "active reads with Gbps throughput",
            output: `   read-ops-per-second:            1500
  write-ops-per-second:             200
             read-rate:         1.5Gbps
            write-rate:       100.0Mbps
             read-time:             2ms
            write-time:             5ms
         in-flight-ops:               8
           active-time:            10ms
             wait-time:             1ms`,
            expected: &DiskMetrics{
                ReadOpsPerSecond:  1500,
                WriteOpsPerSecond: 200,
                ReadBytesPerSec:   187_500_000, // 1.5Gbps = 1.5 * 1_000_000_000 / 8
                WriteBytesPerSec:  12_500_000,  // 100Mbps = 100 * 1_000_000 / 8
                ReadTimeMs:        2,
                WriteTimeMs:       5,
                WaitTimeMs:        1,
                InFlightOps:       8,
                ActiveTimeMs:      10,
            },
        },
        {
            name: "idle disk - all zeros",
            output: `   read-ops-per-second:               0
  write-ops-per-second:               0
             read-rate:            0bps
            write-rate:            0bps
             read-time:             0ms
            write-time:             0ms
         in-flight-ops:               0
           active-time:             0ms
             wait-time:             0ms`,
            expected: &DiskMetrics{},
        },
        {
            name: "kbps throughput",
            output: `   read-ops-per-second:              10
  write-ops-per-second:               5
             read-rate:          500kbps
            write-rate:          250kbps
             read-time:             0ms
            write-time:             0ms
         in-flight-ops:               1
           active-time:             0ms
             wait-time:             0ms`,
            expected: &DiskMetrics{
                ReadOpsPerSecond:  10,
                WriteOpsPerSecond: 5,
                ReadBytesPerSec:   62_500,  // 500kbps = 500 * 1000 / 8
                WriteBytesPerSec:  31_250,  // 250kbps = 250 * 1000 / 8
                InFlightOps:       1,
            },
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := parseDiskMetrics(tt.output)
            if err != nil {
                t.Fatalf("parseDiskMetrics failed: %v", err)
            }

            if result.ReadOpsPerSecond != tt.expected.ReadOpsPerSecond {
                t.Errorf("ReadOpsPerSecond: got %v, want %v", result.ReadOpsPerSecond, tt.expected.ReadOpsPerSecond)
            }
            if result.WriteOpsPerSecond != tt.expected.WriteOpsPerSecond {
                t.Errorf("WriteOpsPerSecond: got %v, want %v", result.WriteOpsPerSecond, tt.expected.WriteOpsPerSecond)
            }
            if result.ReadBytesPerSec != tt.expected.ReadBytesPerSec {
                t.Errorf("ReadBytesPerSec: got %v, want %v", result.ReadBytesPerSec, tt.expected.ReadBytesPerSec)
            }
            if result.WriteBytesPerSec != tt.expected.WriteBytesPerSec {
                t.Errorf("WriteBytesPerSec: got %v, want %v", result.WriteBytesPerSec, tt.expected.WriteBytesPerSec)
            }
            if result.ReadTimeMs != tt.expected.ReadTimeMs {
                t.Errorf("ReadTimeMs: got %v, want %v", result.ReadTimeMs, tt.expected.ReadTimeMs)
            }
            if result.WriteTimeMs != tt.expected.WriteTimeMs {
                t.Errorf("WriteTimeMs: got %v, want %v", result.WriteTimeMs, tt.expected.WriteTimeMs)
            }
            if result.WaitTimeMs != tt.expected.WaitTimeMs {
                t.Errorf("WaitTimeMs: got %v, want %v", result.WaitTimeMs, tt.expected.WaitTimeMs)
            }
            if result.InFlightOps != tt.expected.InFlightOps {
                t.Errorf("InFlightOps: got %v, want %v", result.InFlightOps, tt.expected.InFlightOps)
            }
            if result.ActiveTimeMs != tt.expected.ActiveTimeMs {
                t.Errorf("ActiveTimeMs: got %v, want %v", result.ActiveTimeMs, tt.expected.ActiveTimeMs)
            }
        })
    }
}

func TestConvertRateToBytesPerSec(t *testing.T) {
    tests := []struct {
        value    float64
        unit     string
        expected float64
    }{
        {0, "bps", 0},
        {8, "bps", 1},
        {500, "kbps", 62_500},
        {12.8, "Mbps", 1_600_000},
        {1.5, "Gbps", 187_500_000},
        {100, "unknown", 100}, // Unknown unit returns raw value
    }

    for _, tt := range tests {
        t.Run(fmt.Sprintf("%v_%s", tt.value, tt.unit), func(t *testing.T) {
            result := convertRateToBytesPerSec(tt.value, tt.unit)
            if result != tt.expected {
                t.Errorf("convertRateToBytesPerSec(%v, %q) = %v, want %v", tt.value, tt.unit, result, tt.expected)
            }
        })
    }
}
```

5. Run `make test` - all tests must pass including new parsing tests.
6. Run `go build ./...` - must compile (interface satisfaction verified).
  </action>
  <verify>
Run `make test` - all tests pass.
Run `go build ./...` - compiles without errors.
Grep for `GetDiskMetrics` appears in: types.go (NO - this is the struct), client.go (interface), commands.go (sshClient impl), commands_test.go (tests), mock.go (mock impl).
  </verify>
  <done>
DiskMetrics type defined with 10 fields. GetDiskMetrics in RDSClient interface. sshClient implements GetDiskMetrics via SSH `/disk monitor-traffic <slot> once`. parseDiskMetrics handles all RouterOS output fields. convertRateToBytesPerSec converts bps/kbps/Mbps/Gbps to bytes/sec. MockClient.GetDiskMetrics returns configurable test data. 4+ test cases cover: active writes with Mbps, active reads with Gbps, idle disk, kbps throughput. Rate conversion tested with all unit types.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors (interface satisfaction verified across sshClient and MockClient)
2. `make test` passes (all existing tests + new TestParseDiskMetrics + TestConvertRateToBytesPerSec)
3. `grep -r "GetDiskMetrics" pkg/rds/` shows matches in client.go, commands.go, commands_test.go, mock.go
4. `grep -r "DiskMetrics" pkg/rds/types.go` shows struct definition
</verification>

<success_criteria>
1. DiskMetrics struct captures all 10 fields from /disk monitor-traffic output
2. parseDiskMetrics correctly parses real RouterOS output format (from README.md sample)
3. Rate conversion handles bps, kbps, Mbps, Gbps correctly
4. MockClient supports configurable DiskMetrics response via SetDiskMetrics
5. All unit tests pass with real-world output samples
6. Interface compilation verified (sshClient and MockClient both implement GetDiskMetrics)
</success_criteria>

<output>
After completion, create `.planning/phases/28.2-rds-health-performance-monitoring-research/28.2-01-SUMMARY.md`
</output>
