---
phase: 24-automated-e2e-test-suite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - test/e2e/e2e_suite_test.go
  - test/e2e/helpers.go
  - test/e2e/fixtures.go
autonomous: true

must_haves:
  truths:
    - "E2E test suite starts mock RDS and driver in-process"
    - "Test run ID uniquely identifies each test execution"
    - "AfterSuite cleans up all volumes with test run prefix"
    - "Helper functions simplify common test patterns"
  artifacts:
    - path: "test/e2e/e2e_suite_test.go"
      provides: "Ginkgo suite with BeforeSuite/AfterSuite"
      contains: "BeforeSuite"
    - path: "test/e2e/helpers.go"
      provides: "Test helper functions"
      exports: ["testVolumeName", "GiB", "defaultTimeout"]
    - path: "test/e2e/fixtures.go"
      provides: "Common test fixtures and setup"
      contains: "VolumeCapability"
  key_links:
    - from: "test/e2e/e2e_suite_test.go"
      to: "test/mock/rds_server.go"
      via: "mock.NewMockRDSServer"
      pattern: "mock\\.NewMockRDSServer"
    - from: "test/e2e/e2e_suite_test.go"
      to: "pkg/driver"
      via: "driver.NewDriver"
      pattern: "driver\\.NewDriver"
---

<objective>
Create the E2E test suite infrastructure using Ginkgo v2 with in-process driver pattern

Purpose: Establish foundation for all E2E tests with proper setup/teardown, test isolation via unique IDs, and reusable helpers. This follows the proven pattern from sanity tests.

Output: test/e2e/ directory with suite setup, helpers, and fixtures
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-automated-e2e-test-suite/24-RESEARCH.md

# Existing patterns to follow
@test/sanity/sanity_test.go
@test/mock/rds_server.go
@test/integration/controller_integration_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create E2E suite infrastructure with Ginkgo v2</name>
  <files>test/e2e/e2e_suite_test.go</files>
  <action>
Create the main Ginkgo v2 test suite with:

1. Package declaration: `package e2e`

2. Imports:
   - Ginkgo v2: `github.com/onsi/ginkgo/v2`
   - Gomega: `github.com/onsi/gomega`
   - CSI spec: `github.com/container-storage-interface/spec/lib/go/csi`
   - gRPC: `google.golang.org/grpc`, `google.golang.org/grpc/credentials/insecure`
   - Project packages: `git.srvlab.io/whiskey/rds-csi-driver/pkg/driver`, `test/mock`
   - Standard: `context`, `fmt`, `net`, `os`, `strings`, `testing`, `time`
   - klog for logging: `k8s.io/klog/v2`

3. Test entry point:
   ```go
   func TestE2E(t *testing.T) {
       RegisterFailHandler(Fail)
       RunSpecs(t, "RDS CSI Driver E2E Suite")
   }
   ```

4. Suite-level variables:
   - `testRunID string` - unique prefix for this test run (e2e-{unix_timestamp})
   - `mockRDS *mock.MockRDSServer`
   - `driverEndpoint string` - Unix socket path
   - `grpcConn *grpc.ClientConn`
   - `identityClient csi.IdentityClient`
   - `controllerClient csi.ControllerClient`
   - `nodeClient csi.NodeClient`
   - `ctx context.Context`
   - `cancel context.CancelFunc`

5. BeforeSuite:
   - Generate unique test run ID: `fmt.Sprintf("e2e-%d", time.Now().Unix())`
   - Start mock RDS on port 0 (random port assignment for parallel safety)
   - Create driver with EnableController=true, EnableNode=true (for full path validation)
   - Start driver on Unix socket: `/tmp/csi-e2e-{testRunID}.sock`
   - Wait for socket ready using Eventually() pattern (not sleep)
   - Create gRPC connection and CSI clients
   - Create context with 2 minute timeout for long-running tests

6. AfterSuite with DeferCleanup pattern:
   - List all volumes and delete those with testRunID prefix
   - Close gRPC connection
   - Stop mock RDS server
   - Remove socket file
   - Log cleanup completion

Use the same SSH private key from sanity_test.go (testSSHPrivateKey constant).
Use InsecureSkipVerify=true for mock RDS.
Use grpc.WithTransportCredentials(insecure.NewCredentials()) for gRPC.
  </action>
  <verify>
`go build ./test/e2e/...` compiles without errors
  </verify>
  <done>
e2e_suite_test.go exists with BeforeSuite starting mock RDS and driver, AfterSuite cleaning up, and testRunID generation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test helper functions</name>
  <files>test/e2e/helpers.go</files>
  <action>
Create helper functions for common test patterns:

1. Package declaration: `package e2e`

2. Constants:
   ```go
   const (
       GiB = 1024 * 1024 * 1024
       MiB = 1024 * 1024
       defaultTimeout = 2 * time.Minute
       pollInterval = 200 * time.Millisecond
       testVolumeBasePath = "/storage-pool/metal-csi"
   )
   ```

3. Volume name helper:
   ```go
   // testVolumeName creates a unique volume name for the current test
   func testVolumeName(name string) string {
       return fmt.Sprintf("%s-%s", testRunID, name)
   }
   ```

4. Standard volume capability factory:
   ```go
   // mountVolumeCapability returns a mount volume capability with SINGLE_NODE_WRITER
   func mountVolumeCapability(fsType string) *csi.VolumeCapability {
       return &csi.VolumeCapability{
           AccessMode: &csi.VolumeCapability_AccessMode{
               Mode: csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER,
           },
           AccessType: &csi.VolumeCapability_Mount{
               Mount: &csi.VolumeCapability_MountVolume{
                   FsType: fsType,
               },
           },
       }
   }

   // blockVolumeCapability returns a block volume capability with SINGLE_NODE_WRITER
   func blockVolumeCapability() *csi.VolumeCapability {
       return &csi.VolumeCapability{
           AccessMode: &csi.VolumeCapability_AccessMode{
               Mode: csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER,
           },
           AccessType: &csi.VolumeCapability_Block{
               Block: &csi.VolumeCapability_BlockVolume{},
           },
       }
   }
   ```

5. Create volume helper with automatic cleanup:
   ```go
   // createVolumeWithCleanup creates a volume and registers cleanup
   func createVolumeWithCleanup(name string, sizeBytes int64, capability *csi.VolumeCapability) string {
       resp, err := controllerClient.CreateVolume(ctx, &csi.CreateVolumeRequest{
           Name:               name,
           CapacityRange:      &csi.CapacityRange{RequiredBytes: sizeBytes},
           VolumeCapabilities: []*csi.VolumeCapability{capability},
       })
       Expect(err).NotTo(HaveOccurred(), "CreateVolume should succeed")
       Expect(resp.Volume).NotTo(BeNil())

       volumeID := resp.Volume.VolumeId
       DeferCleanup(func() {
           _, _ = controllerClient.DeleteVolume(ctx, &csi.DeleteVolumeRequest{VolumeId: volumeID})
       })

       return volumeID
   }
   ```

6. Wait for volume on mock RDS:
   ```go
   // waitForVolumeOnMockRDS waits for volume to appear on mock RDS
   func waitForVolumeOnMockRDS(volumeID string) {
       Eventually(func() bool {
           vol, exists := mockRDS.GetVolume(volumeID)
           return exists && vol.Exported
       }, defaultTimeout, pollInterval).Should(BeTrue(),
           "Volume %s should exist and be exported on mock RDS", volumeID)
   }

   // waitForVolumeDeletedFromMockRDS waits for volume to be deleted from mock RDS
   func waitForVolumeDeletedFromMockRDS(volumeID string) {
       Eventually(func() bool {
           _, exists := mockRDS.GetVolume(volumeID)
           return !exists
       }, defaultTimeout, pollInterval).Should(BeTrue(),
           "Volume %s should be deleted from mock RDS", volumeID)
   }
   ```
  </action>
  <verify>
`go build ./test/e2e/...` compiles without errors
  </verify>
  <done>
helpers.go exists with GiB constant, testVolumeName helper, volume capability factories, and wait helpers
  </done>
</task>

<task type="auto">
  <name>Task 3: Create test fixtures and run initial suite</name>
  <files>test/e2e/fixtures.go</files>
  <action>
Create common test fixtures:

1. Package declaration: `package e2e`

2. SSH private key (copy from sanity_test.go):
   ```go
   // testSSHPrivateKey is a test RSA key for mock RDS authentication
   const testSSHPrivateKey = `-----BEGIN OPENSSH PRIVATE KEY-----
   [... copy exact key from test/sanity/sanity_test.go ...]
   -----END OPENSSH PRIVATE KEY-----`
   ```

3. Test volume sizes:
   ```go
   const (
       smallVolumeSize  = 1 * GiB  // 1 GiB for quick tests
       mediumVolumeSize = 5 * GiB  // 5 GiB for block volume tests
       largeVolumeSize  = 10 * GiB // 10 GiB for expansion tests
   )
   ```

4. Staging/publish path generators:
   ```go
   // stagingPath returns a unique staging path for a volume
   func stagingPath(volumeID string) string {
       return fmt.Sprintf("/tmp/csi-e2e-staging/%s", volumeID)
   }

   // publishPath returns a unique publish path for a volume
   func publishPath(volumeID string) string {
       return fmt.Sprintf("/tmp/csi-e2e-publish/%s", volumeID)
   }
   ```

5. Add a minimal placeholder test to verify suite runs:
   In e2e_suite_test.go, add after AfterSuite:
   ```go
   var _ = Describe("E2E Suite Sanity", func() {
       It("should have valid test infrastructure", func() {
           Expect(testRunID).NotTo(BeEmpty(), "testRunID should be set")
           Expect(mockRDS).NotTo(BeNil(), "mockRDS should be initialized")
           Expect(controllerClient).NotTo(BeNil(), "controllerClient should be initialized")
           klog.Infof("E2E suite infrastructure validated, testRunID=%s", testRunID)
       })
   })
   ```

After creating all files, run the suite to verify setup:
```bash
go test -v ./test/e2e/... -ginkgo.v -count=1
```

The test should pass, proving:
- Mock RDS starts successfully
- Driver starts and accepts gRPC connections
- CSI clients are functional
- Cleanup runs without errors
  </action>
  <verify>
`go test -v ./test/e2e/... -ginkgo.v -count=1` passes with "E2E suite infrastructure validated" in output
  </verify>
  <done>
fixtures.go exists with SSH key and path generators; suite runs successfully with placeholder test passing
  </done>
</task>

</tasks>

<verification>
1. All three files exist: test/e2e/e2e_suite_test.go, test/e2e/helpers.go, test/e2e/fixtures.go
2. `go build ./test/e2e/...` compiles without errors
3. `go test -v ./test/e2e/... -count=1` runs and passes
4. Test output shows mock RDS starting and stopping
5. Test output shows testRunID being generated
</verification>

<success_criteria>
- E2E test suite infrastructure is in place with Ginkgo v2
- In-process driver pattern working (mock RDS + driver + gRPC)
- Test isolation via unique testRunID prefix
- Helper functions available for common patterns
- Suite can be extended with actual E2E tests in subsequent plans
</success_criteria>

<output>
After completion, create `.planning/phases/24-automated-e2e-test-suite/24-01-SUMMARY.md`
</output>
