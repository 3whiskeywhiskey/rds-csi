---
phase: 24-automated-e2e-test-suite
plan: 03
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - test/e2e/concurrent_test.go
  - test/e2e/orphan_test.go
autonomous: true

must_haves:
  truths:
    - "Concurrent test creates and deletes 5+ volumes in parallel without conflicts"
    - "Orphan detection test validates orphaned files are detected on mock RDS"
    - "All concurrent operations complete without mutex/race errors"
    - "Test cleanup prevents resource pollution between tests"
  artifacts:
    - path: "test/e2e/concurrent_test.go"
      provides: "E2E-04 multi-volume concurrent operations test"
      contains: "goroutine"
    - path: "test/e2e/orphan_test.go"
      provides: "E2E-05 orphan detection test"
      contains: "CreateOrphanedFile"
  key_links:
    - from: "test/e2e/concurrent_test.go"
      to: "csi.ControllerClient"
      via: "goroutine CreateVolume"
      pattern: "go func"
    - from: "test/e2e/orphan_test.go"
      to: "test/mock/rds_server.go"
      via: "mockRDS.CreateOrphanedFile"
      pattern: "mockRDS\\.CreateOrphanedFile"
---

<objective>
Implement advanced E2E tests for concurrent operations and orphan detection

Purpose: Validate the driver handles concurrent volume operations without conflicts (E2E-04) and can detect orphaned resources on RDS (E2E-05). These tests stress-test the driver's thread safety and resource tracking.

Output: Two test files covering concurrent multi-volume operations and orphan detection scenarios
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-automated-e2e-test-suite/24-RESEARCH.md

# Suite infrastructure from Plan 01
@test/e2e/e2e_suite_test.go
@test/e2e/helpers.go

# Mock RDS with orphan support
@test/mock/rds_server.go

# Existing concurrent test patterns
@test/mock/stress_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement concurrent multi-volume E2E test (E2E-04)</name>
  <files>test/e2e/concurrent_test.go</files>
  <action>
Create concurrent operations test covering E2E-04 requirement:

1. Package and imports:
   ```go
   package e2e

   import (
       "fmt"
       "sync"

       . "github.com/onsi/ginkgo/v2"
       . "github.com/onsi/gomega"
       "github.com/container-storage-interface/spec/lib/go/csi"
       "k8s.io/klog/v2"
   )
   ```

2. Concurrent Operations Describe block:
   ```go
   var _ = Describe("Concurrent Operations [E2E-04]", func() {
       const numConcurrentVolumes = 5

       It("should handle concurrent CreateVolume operations without conflicts", func() {
           var wg sync.WaitGroup
           errChan := make(chan error, numConcurrentVolumes)
           volumeIDs := make([]string, numConcurrentVolumes)
           var volumeIDsMu sync.Mutex

           By(fmt.Sprintf("Creating %d volumes concurrently", numConcurrentVolumes))
           for i := 0; i < numConcurrentVolumes; i++ {
               wg.Add(1)
               go func(idx int) {
                   defer wg.Done()
                   defer GinkgoRecover()

                   volumeName := testVolumeName(fmt.Sprintf("concurrent-%d", idx))
                   resp, err := controllerClient.CreateVolume(ctx, &csi.CreateVolumeRequest{
                       Name:               volumeName,
                       CapacityRange:      &csi.CapacityRange{RequiredBytes: smallVolumeSize},
                       VolumeCapabilities: []*csi.VolumeCapability{mountVolumeCapability("ext4")},
                   })
                   if err != nil {
                       errChan <- fmt.Errorf("CreateVolume for volume %d failed: %w", idx, err)
                       return
                   }

                   volumeIDsMu.Lock()
                   volumeIDs[idx] = resp.Volume.VolumeId
                   volumeIDsMu.Unlock()

                   klog.V(2).Infof("Created concurrent volume %d: %s", idx, resp.Volume.VolumeId)
                   errChan <- nil
               }(i)
           }

           wg.Wait()
           close(errChan)

           // Collect errors
           var errors []error
           for err := range errChan {
               if err != nil {
                   errors = append(errors, err)
               }
           }
           Expect(errors).To(BeEmpty(), "All concurrent CreateVolume operations should succeed")

           // Register cleanup for all volumes
           DeferCleanup(func() {
               var cleanupWg sync.WaitGroup
               for _, volID := range volumeIDs {
                   if volID != "" {
                       cleanupWg.Add(1)
                       go func(id string) {
                           defer cleanupWg.Done()
                           _, _ = controllerClient.DeleteVolume(ctx, &csi.DeleteVolumeRequest{VolumeId: id})
                       }(volID)
                   }
               }
               cleanupWg.Wait()
           })

           By("Verifying all volumes exist on mock RDS")
           Eventually(func() int {
               count := 0
               volumeIDsMu.Lock()
               defer volumeIDsMu.Unlock()
               for _, volID := range volumeIDs {
                   if volID != "" {
                       if _, exists := mockRDS.GetVolume(volID); exists {
                           count++
                       }
                   }
               }
               return count
           }, defaultTimeout, pollInterval).Should(Equal(numConcurrentVolumes),
               "All %d volumes should exist on mock RDS", numConcurrentVolumes)

           klog.Infof("Concurrent create test passed: %d volumes created", numConcurrentVolumes)
       })

       It("should handle concurrent DeleteVolume operations without conflicts", func() {
           // First create volumes sequentially for reliability
           volumeIDs := make([]string, numConcurrentVolumes)

           By("Creating volumes for concurrent delete test")
           for i := 0; i < numConcurrentVolumes; i++ {
               volumeName := testVolumeName(fmt.Sprintf("concurrent-delete-%d", i))
               resp, err := controllerClient.CreateVolume(ctx, &csi.CreateVolumeRequest{
                   Name:               volumeName,
                   CapacityRange:      &csi.CapacityRange{RequiredBytes: smallVolumeSize},
                   VolumeCapabilities: []*csi.VolumeCapability{mountVolumeCapability("ext4")},
               })
               Expect(err).NotTo(HaveOccurred())
               volumeIDs[i] = resp.Volume.VolumeId
               waitForVolumeOnMockRDS(volumeIDs[i])
           }

           By(fmt.Sprintf("Deleting %d volumes concurrently", numConcurrentVolumes))
           var wg sync.WaitGroup
           errChan := make(chan error, numConcurrentVolumes)

           for i := 0; i < numConcurrentVolumes; i++ {
               wg.Add(1)
               go func(idx int) {
                   defer wg.Done()
                   defer GinkgoRecover()

                   _, err := controllerClient.DeleteVolume(ctx, &csi.DeleteVolumeRequest{
                       VolumeId: volumeIDs[idx],
                   })
                   if err != nil {
                       errChan <- fmt.Errorf("DeleteVolume for volume %d failed: %w", idx, err)
                       return
                   }
                   klog.V(2).Infof("Deleted concurrent volume %d: %s", idx, volumeIDs[idx])
                   errChan <- nil
               }(i)
           }

           wg.Wait()
           close(errChan)

           // Collect errors
           var errors []error
           for err := range errChan {
               if err != nil {
                   errors = append(errors, err)
               }
           }
           Expect(errors).To(BeEmpty(), "All concurrent DeleteVolume operations should succeed")

           By("Verifying all volumes deleted from mock RDS")
           Eventually(func() int {
               count := 0
               for _, volID := range volumeIDs {
                   if _, exists := mockRDS.GetVolume(volID); exists {
                       count++
                   }
               }
               return count
           }, defaultTimeout, pollInterval).Should(Equal(0), "All volumes should be deleted from mock RDS")

           klog.Infof("Concurrent delete test passed: %d volumes deleted", numConcurrentVolumes)
       })

       It("should handle mixed concurrent create and delete operations", func() {
           const numOperations = 10 // 5 creates + 5 deletes
           var wg sync.WaitGroup
           errChan := make(chan error, numOperations)

           // Pre-create volumes to delete
           deleteVolumes := make([]string, 5)
           for i := 0; i < 5; i++ {
               volumeName := testVolumeName(fmt.Sprintf("mixed-delete-%d", i))
               resp, err := controllerClient.CreateVolume(ctx, &csi.CreateVolumeRequest{
                   Name:               volumeName,
                   CapacityRange:      &csi.CapacityRange{RequiredBytes: smallVolumeSize},
                   VolumeCapabilities: []*csi.VolumeCapability{mountVolumeCapability("ext4")},
               })
               Expect(err).NotTo(HaveOccurred())
               deleteVolumes[i] = resp.Volume.VolumeId
               waitForVolumeOnMockRDS(deleteVolumes[i])
           }

           createVolumes := make([]string, 5)
           var createVolumesMu sync.Mutex

           By("Running mixed concurrent creates and deletes")
           // Start creates
           for i := 0; i < 5; i++ {
               wg.Add(1)
               go func(idx int) {
                   defer wg.Done()
                   defer GinkgoRecover()

                   volumeName := testVolumeName(fmt.Sprintf("mixed-create-%d", idx))
                   resp, err := controllerClient.CreateVolume(ctx, &csi.CreateVolumeRequest{
                       Name:               volumeName,
                       CapacityRange:      &csi.CapacityRange{RequiredBytes: smallVolumeSize},
                       VolumeCapabilities: []*csi.VolumeCapability{mountVolumeCapability("ext4")},
                   })
                   if err != nil {
                       errChan <- fmt.Errorf("mixed create %d failed: %w", idx, err)
                       return
                   }
                   createVolumesMu.Lock()
                   createVolumes[idx] = resp.Volume.VolumeId
                   createVolumesMu.Unlock()
                   errChan <- nil
               }(i)
           }

           // Start deletes
           for i := 0; i < 5; i++ {
               wg.Add(1)
               go func(idx int) {
                   defer wg.Done()
                   defer GinkgoRecover()

                   _, err := controllerClient.DeleteVolume(ctx, &csi.DeleteVolumeRequest{
                       VolumeId: deleteVolumes[idx],
                   })
                   if err != nil {
                       errChan <- fmt.Errorf("mixed delete %d failed: %w", idx, err)
                       return
                   }
                   errChan <- nil
               }(i)
           }

           wg.Wait()
           close(errChan)

           // Cleanup created volumes
           DeferCleanup(func() {
               for _, volID := range createVolumes {
                   if volID != "" {
                       _, _ = controllerClient.DeleteVolume(ctx, &csi.DeleteVolumeRequest{VolumeId: volID})
                   }
               }
           })

           // Collect errors
           var errors []error
           for err := range errChan {
               if err != nil {
                   errors = append(errors, err)
               }
           }
           Expect(errors).To(BeEmpty(), "All mixed operations should succeed")

           klog.Infof("Mixed concurrent operations test passed")
       })
   })
   ```
  </action>
  <verify>
`go test -v ./test/e2e/... -ginkgo.focus="Concurrent Operations" -count=1` passes
  </verify>
  <done>
concurrent_test.go exists with concurrent create, concurrent delete, and mixed operations tests
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement orphan detection E2E test (E2E-05)</name>
  <files>test/e2e/orphan_test.go</files>
  <action>
Create orphan detection test covering E2E-05 requirement:

1. Package and imports:
   ```go
   package e2e

   import (
       "fmt"

       . "github.com/onsi/ginkgo/v2"
       . "github.com/onsi/gomega"
       "github.com/container-storage-interface/spec/lib/go/csi"
       "k8s.io/klog/v2"
   )
   ```

2. Orphan Detection Describe block:
   ```go
   var _ = Describe("Orphan Detection [E2E-05]", func() {
       // Note: This tests the mock RDS's orphan simulation capabilities
       // and validates the driver's ListVolumes can identify mismatches.
       // Full orphan reconciliation requires Kubernetes API integration.

       It("should detect orphaned files (files without disk objects)", func() {
           orphanPath := fmt.Sprintf("/storage-pool/metal-csi/%s-orphan-file.img", testRunID)

           By("Creating orphaned file on mock RDS")
           mockRDS.CreateOrphanedFile(orphanPath, smallVolumeSize)
           DeferCleanup(func() {
               mockRDS.DeleteFile(orphanPath)
           })

           By("Verifying orphaned file exists")
           file, exists := mockRDS.GetFile(orphanPath)
           Expect(exists).To(BeTrue(), "Orphaned file should exist on mock RDS")
           Expect(file.SizeBytes).To(Equal(smallVolumeSize))

           By("Verifying no corresponding disk object exists")
           // The file exists but no volume references it
           volumes := mockRDS.ListVolumes()
           hasMatchingVolume := false
           for _, vol := range volumes {
               if vol.FilePath == orphanPath {
                   hasMatchingVolume = true
                   break
               }
           }
           Expect(hasMatchingVolume).To(BeFalse(),
               "No disk object should reference the orphaned file")

           klog.Infof("Orphaned file detection test passed: %s detected as orphan", orphanPath)
       })

       It("should detect orphaned volumes (disk objects without backing files)", func() {
           orphanSlot := testVolumeName("orphan-volume")
           orphanFilePath := fmt.Sprintf("/storage-pool/metal-csi/%s.img", orphanSlot)

           By("Creating orphaned volume (disk object without backing file)")
           mockRDS.CreateOrphanedVolume(orphanSlot, orphanFilePath, smallVolumeSize)
           DeferCleanup(func() {
               // Clean up via direct mock access (volume has no backing file)
               // The mock's DeleteVolume would fail if we tried CSI DeleteVolume
               // because the backing file doesn't exist
               // For this test, just let the mock cleanup handle it
           })

           By("Verifying orphaned volume exists")
           vol, exists := mockRDS.GetVolume(orphanSlot)
           Expect(exists).To(BeTrue(), "Orphaned volume should exist on mock RDS")
           Expect(vol.FilePath).To(Equal(orphanFilePath))

           By("Verifying no backing file exists")
           _, fileExists := mockRDS.GetFile(orphanFilePath)
           Expect(fileExists).To(BeFalse(),
               "No backing file should exist for orphaned volume")

           klog.Infof("Orphaned volume detection test passed: %s detected as orphan", orphanSlot)
       })

       It("should list volumes including those that may be orphaned", func() {
           // Create a normal volume
           normalVolumeName := testVolumeName("orphan-test-normal")
           normalResp, err := controllerClient.CreateVolume(ctx, &csi.CreateVolumeRequest{
               Name:               normalVolumeName,
               CapacityRange:      &csi.CapacityRange{RequiredBytes: smallVolumeSize},
               VolumeCapabilities: []*csi.VolumeCapability{mountVolumeCapability("ext4")},
           })
           Expect(err).NotTo(HaveOccurred())
           normalVolumeID := normalResp.Volume.VolumeId
           DeferCleanup(func() {
               _, _ = controllerClient.DeleteVolume(ctx, &csi.DeleteVolumeRequest{VolumeId: normalVolumeID})
           })

           waitForVolumeOnMockRDS(normalVolumeID)

           // Create an orphaned volume (disk object without CSI creation)
           orphanSlot := testVolumeName("orphan-detected")
           orphanFilePath := fmt.Sprintf("/storage-pool/metal-csi/%s.img", orphanSlot)
           mockRDS.CreateOrphanedVolume(orphanSlot, orphanFilePath, smallVolumeSize)
           // Also create its backing file so it's a "complete" volume but not created via CSI
           mockRDS.CreateOrphanedFile(orphanFilePath, smallVolumeSize)

           By("Listing volumes via CSI ListVolumes")
           listResp, err := controllerClient.ListVolumes(ctx, &csi.ListVolumesRequest{})
           Expect(err).NotTo(HaveOccurred())

           // Find our normal volume
           foundNormal := false
           for _, entry := range listResp.Entries {
               if entry.Volume.VolumeId == normalVolumeID {
                   foundNormal = true
                   break
               }
           }
           Expect(foundNormal).To(BeTrue(), "Normal volume should be in ListVolumes response")

           // Note: The orphaned volume created directly on mock RDS should also appear
           // in ListVolumes if the driver queries all volumes from RDS.
           // This is the foundation for orphan reconciliation.

           By("Verifying mock RDS shows both volumes")
           allVolumes := mockRDS.ListVolumes()
           Expect(len(allVolumes)).To(BeNumerically(">=", 2),
               "Mock RDS should have at least 2 volumes (normal + orphan)")

           klog.Infof("Orphan listing test passed: can enumerate volumes for reconciliation")
       })

       It("should track cleanup prevents orphans between test runs (E2E-08)", func() {
           // This test validates E2E-08: unique volume ID prefix per test run
           By("Verifying testRunID is set and unique")
           Expect(testRunID).NotTo(BeEmpty())
           Expect(testRunID).To(HavePrefix("e2e-"),
               "testRunID should have e2e- prefix")

           By("Creating test volume with prefixed name")
           volumeName := testVolumeName("cleanup-test")
           Expect(volumeName).To(HavePrefix(testRunID),
               "Volume name should include testRunID prefix")

           resp, err := controllerClient.CreateVolume(ctx, &csi.CreateVolumeRequest{
               Name:               volumeName,
               CapacityRange:      &csi.CapacityRange{RequiredBytes: smallVolumeSize},
               VolumeCapabilities: []*csi.VolumeCapability{mountVolumeCapability("ext4")},
           })
           Expect(err).NotTo(HaveOccurred())
           DeferCleanup(func() {
               _, _ = controllerClient.DeleteVolume(ctx, &csi.DeleteVolumeRequest{VolumeId: resp.Volume.VolumeId})
           })

           By("Verifying volume ID or name contains test run identifier")
           // The volume should be identifiable as belonging to this test run
           // This enables AfterSuite cleanup to find and delete all test volumes
           klog.Infof("Test isolation validated: volumes use prefix %s", testRunID)
       })
   })
   ```
  </action>
  <verify>
`go test -v ./test/e2e/... -ginkgo.focus="Orphan Detection" -count=1` passes
  </verify>
  <done>
orphan_test.go exists with orphaned file detection, orphaned volume detection, and cleanup prefix validation tests
  </done>
</task>

</tasks>

<verification>
1. All test files compile: `go build ./test/e2e/...`
2. `go test -v ./test/e2e/... -ginkgo.focus="Concurrent" -count=1` passes
3. `go test -v ./test/e2e/... -ginkgo.focus="Orphan" -count=1` passes
4. Concurrent tests complete without race conditions
5. Orphan tests validate mock RDS orphan simulation works correctly
</verification>

<success_criteria>
- E2E-04 (concurrent operations) test implemented with 5+ volume operations
- E2E-05 (orphan detection) test implemented validating file and volume orphans
- E2E-08 (cleanup prefix) validated through testRunID usage
- All concurrent operations complete without errors
- DeferCleanup used for guaranteed resource cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/24-automated-e2e-test-suite/24-03-SUMMARY.md`
</output>
