---
phase: 02-stale-mount-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/mount/procmounts.go
  - pkg/mount/mount.go
autonomous: true

must_haves:
  truths:
    - "Driver can get the source device for any mounted path"
    - "Driver can detect if a mount is in use by scanning /proc/*/fd"
    - "Driver can force unmount with lazy unmount when normal unmount fails"
  artifacts:
    - path: "pkg/mount/procmounts.go"
      provides: "GetMountDevice function for /proc/mounts parsing"
      exports: ["GetMountDevice", "GetMountInfo"]
    - path: "pkg/mount/mount.go"
      provides: "ForceUnmount and IsMountInUse methods"
      contains: "func.*ForceUnmount"
  key_links:
    - from: "pkg/mount/procmounts.go"
      to: "/proc/self/mountinfo"
      via: "file parsing"
      pattern: "mountinfo"
    - from: "pkg/mount/mount.go"
      to: "/proc/*/fd"
      via: "directory scanning"
      pattern: "/proc.*fd"
---

<objective>
Mount infrastructure for stale detection: /proc/mounts parsing, force unmount with in-use checking

Purpose: Provide the low-level mount utilities needed by StaleMountChecker and MountRecoverer. This is foundational infrastructure that must exist before detection/recovery can be built.

Output: procmounts.go with mount device lookup, enhanced mount.go with ForceUnmount and IsMountInUse
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-stale-mount-detection/02-RESEARCH.md
@pkg/mount/mount.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /proc/mountinfo parsing utilities</name>
  <files>pkg/mount/procmounts.go</files>
  <action>
Create pkg/mount/procmounts.go with functions to parse /proc/self/mountinfo and get mount device for a path.

Implementation:
1. Create MountInfo struct with fields: Source (device), Target (mount point), FSType, Options
2. Create GetMounts() function that parses /proc/self/mountinfo
   - Parse format: ID PARENT_ID MAJOR:MINOR ROOT MOUNT_POINT OPTIONS OPTIONAL_FIELDS - FSTYPE SOURCE SUPER_OPTIONS
   - Handle escaped characters in paths (spaces as \040, etc.)
   - Return []MountInfo
3. Create GetMountDevice(mountPath string) (string, error) function
   - Use GetMounts() and filter by Target == mountPath
   - Return Source field (the device)
   - Return error if mount not found
4. Create GetMountInfo(mountPath string) (*MountInfo, error) function
   - Returns full MountInfo struct for the mount point

Use moby/sys/mountinfo pattern from research but implement inline (avoid adding dependency for simple parsing).

Key edge cases to handle:
- Paths with spaces (escaped as \040)
- Paths with special characters
- Mount not found returns clear error

Logging: Use klog.V(5) for verbose parsing, klog.V(3) for GetMountDevice results
  </action>
  <verify>
go build ./pkg/mount/... compiles successfully
go vet ./pkg/mount/... passes
  </verify>
  <done>
GetMountDevice("/") returns a device path without error
GetMounts() returns non-empty slice on any Linux system with mounts
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ForceUnmount and IsMountInUse to Mounter</name>
  <files>pkg/mount/mount.go</files>
  <action>
Extend the Mounter interface and mounter implementation with force unmount and in-use detection.

Add to Mounter interface:
```go
// ForceUnmount attempts normal unmount, then escalates to lazy unmount if needed
// Returns error if mount is in use (refuses to force unmount in-use mounts)
ForceUnmount(target string, timeout time.Duration) error

// IsMountInUse checks if any processes have open file handles under the mount path
// Returns (inUse bool, pids []int, err error)
IsMountInUse(path string) (bool, []int, error)
```

Implementation for IsMountInUse:
1. Resolve mount path to canonical form with filepath.EvalSymlinks
2. Scan /proc directory for all numeric entries (PIDs)
3. For each PID, read /proc/PID/fd directory
4. For each fd, readlink to get target path
5. Check if target path has mount path as prefix (or equals mount path)
6. Skip processes where permission denied (normal for other users)
7. Return list of PIDs with open handles

Implementation for ForceUnmount:
1. Try normal Unmount first
2. If error, wait with timeout polling IsLikelyMountPoint every 500ms
3. If still mounted after timeout:
   a. Check IsMountInUse - if in use, return error (refuse to force)
   b. If not in use, execute "umount -l" (lazy unmount)
4. Log escalation to lazy unmount at Warning level

Per CONTEXT.md decisions:
- NormalUnmountWait: 10 seconds default
- Refuse force unmount if mount is in use (prevents data loss)

Logging:
- klog.V(2) for force unmount attempts
- klog.Warning for lazy unmount escalation
- klog.V(4) for in-use detection details
  </action>
  <verify>
go build ./pkg/mount/... compiles successfully
go vet ./pkg/mount/... passes
Mounter interface includes ForceUnmount and IsMountInUse methods
  </verify>
  <done>
ForceUnmount method exists on mounter with timeout parameter
IsMountInUse method exists on mounter and returns (bool, []int, error)
  </done>
</task>

</tasks>

<verification>
1. go build ./pkg/mount/... - all files compile
2. go vet ./pkg/mount/... - no issues
3. procmounts.go exports GetMountDevice and GetMountInfo
4. mount.go Mounter interface has ForceUnmount and IsMountInUse
</verification>

<success_criteria>
- procmounts.go can parse /proc/self/mountinfo and return device for mount path
- mount.go has ForceUnmount that tries normal unmount first, then lazy
- mount.go has IsMountInUse that scans /proc/*/fd for open handles
- Code compiles and passes vet
</success_criteria>

<output>
After completion, create `.planning/phases/02-stale-mount-detection/02-01-SUMMARY.md`
</output>
