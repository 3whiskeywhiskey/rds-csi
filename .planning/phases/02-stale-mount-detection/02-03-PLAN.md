---
phase: 02-stale-mount-detection
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - pkg/mount/stale.go
  - pkg/mount/recovery.go
autonomous: true

must_haves:
  truths:
    - "Driver detects stale mounts when mount device differs from NQN-resolved device"
    - "Driver detects stale mounts when mount device no longer exists"
    - "Driver attempts recovery with exponential backoff (1s, 2s, 4s)"
    - "Recovery unmounts stale path and remounts with correct device"
  artifacts:
    - path: "pkg/mount/stale.go"
      provides: "StaleMountChecker for detecting stale mounts"
      exports: ["StaleMountChecker", "NewStaleMountChecker", "IsMountStale"]
    - path: "pkg/mount/recovery.go"
      provides: "MountRecoverer for automatic mount recovery"
      exports: ["MountRecoverer", "NewMountRecoverer", "Recover"]
  key_links:
    - from: "pkg/mount/stale.go"
      to: "pkg/nvme/resolver.go"
      via: "DeviceResolver.ResolveDevicePath"
      pattern: "ResolveDevicePath"
    - from: "pkg/mount/stale.go"
      to: "pkg/mount/procmounts.go"
      via: "GetMountDevice"
      pattern: "GetMountDevice"
    - from: "pkg/mount/recovery.go"
      to: "pkg/mount/mount.go"
      via: "ForceUnmount and Mount"
      pattern: "ForceUnmount|Mount"
---

<objective>
Stale mount detection and automatic recovery with retry logic

Purpose: Core detection and recovery logic. StaleMountChecker compares mount device with NQN-resolved device. MountRecoverer handles unmount/remount with exponential backoff.

Output: stale.go with detection logic, recovery.go with retry-based recovery
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-stale-mount-detection/02-RESEARCH.md
@.planning/phases/02-stale-mount-detection/02-CONTEXT.md
@.planning/phases/02-stale-mount-detection/02-01-SUMMARY.md
@pkg/nvme/resolver.go
@pkg/mount/mount.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StaleMountChecker for stale mount detection</name>
  <files>pkg/mount/stale.go</files>
  <action>
Create pkg/mount/stale.go with StaleMountChecker that detects stale mounts.

Stale mount definition (from CONTEXT.md):
- Device path mismatch: mount points to /dev/nvme0n1 but NQN now resolves to /dev/nvme1n1
- Device disappeared: mount points to device that no longer exists in /dev

Implementation:

```go
package mount

import (
    "fmt"
    "os"
    "path/filepath"

    "git.srvlab.io/whiskey/rds-csi-driver/pkg/nvme"
    "k8s.io/klog/v2"
)

// StaleReason describes why a mount is considered stale
type StaleReason string

const (
    StaleReasonNotStale         StaleReason = ""
    StaleReasonMountNotFound    StaleReason = "mount_not_found"
    StaleReasonDeviceDisappeared StaleReason = "device_disappeared"
    StaleReasonDeviceMismatch   StaleReason = "device_path_mismatch"
)

// StaleMountChecker detects stale mounts by comparing mount device with NQN resolution
type StaleMountChecker struct {
    resolver    *nvme.DeviceResolver
    getMountDev func(path string) (string, error) // Injected for testing
}
```

Create NewStaleMountChecker:
- Accept *nvme.DeviceResolver
- Use GetMountDevice from procmounts.go as default getMountDev
- Allow injection of getMountDev for testing

Create IsMountStale method:
- Parameters: mountPath string, nqn string
- Returns: (stale bool, reason StaleReason, err error)

Algorithm:
1. Get current mount device via getMountDev(mountPath)
   - If error (mount not found): return (true, StaleReasonMountNotFound, nil)
2. Resolve mount device symlinks via filepath.EvalSymlinks
   - If error (device disappeared): return (true, StaleReasonDeviceDisappeared, nil)
3. Resolve NQN to current device path via resolver.ResolveDevicePath(nqn)
   - If error: return (false, "", fmt.Errorf("failed to resolve NQN: %w", err))
4. Resolve current device symlinks via filepath.EvalSymlinks
   - If error: return (false, "", fmt.Errorf("failed to resolve current device: %w", err))
5. Compare resolved paths
   - If different: return (true, StaleReasonDeviceMismatch, nil)
   - If same: return (false, StaleReasonNotStale, nil)

Logging:
- klog.V(4) for mount device lookup
- klog.V(3) for stale detection results
- klog.Warning when stale mount detected (with old and new device paths)

Create helper method GetStaleInfo for debugging:
- Returns struct with mountDevice, resolvedMount, currentDevice, resolvedCurrent
  </action>
  <verify>
go build ./pkg/mount/... compiles successfully
go vet ./pkg/mount/... passes
  </verify>
  <done>
StaleMountChecker struct exists with resolver and getMountDev fields
IsMountStale returns (bool, StaleReason, error)
Handles all three stale conditions: mount not found, device disappeared, device mismatch
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MountRecoverer with retry logic</name>
  <files>pkg/mount/recovery.go</files>
  <action>
Create pkg/mount/recovery.go with MountRecoverer that handles automatic recovery.

Per CONTEXT.md decisions:
- 3 recovery attempts before giving up
- Exponential backoff between attempts (1s, 2s, 4s)
- On success: no Kubernetes event, just proceed
- On failure: caller posts event with retry info

Implementation:

```go
package mount

import (
    "context"
    "fmt"
    "time"

    "git.srvlab.io/whiskey/rds-csi-driver/pkg/nvme"
    "k8s.io/klog/v2"
)

// RecoveryConfig holds recovery configuration
type RecoveryConfig struct {
    MaxAttempts       int           // Default: 3
    InitialBackoff    time.Duration // Default: 1s
    BackoffMultiplier float64       // Default: 2.0
    NormalUnmountWait time.Duration // Default: 10s (from CONTEXT.md)
}

// DefaultRecoveryConfig returns sensible defaults
func DefaultRecoveryConfig() RecoveryConfig {
    return RecoveryConfig{
        MaxAttempts:       3,
        InitialBackoff:    1 * time.Second,
        BackoffMultiplier: 2.0,
        NormalUnmountWait: 10 * time.Second,
    }
}

// RecoveryResult contains details about a recovery attempt
type RecoveryResult struct {
    Recovered    bool
    Attempts     int
    FinalError   error
    OldDevice    string
    NewDevice    string
}

// MountRecoverer handles automatic mount recovery
type MountRecoverer struct {
    config  RecoveryConfig
    mounter Mounter
    checker *StaleMountChecker
}
```

Create NewMountRecoverer:
- Accept RecoveryConfig, Mounter, *StaleMountChecker

Create Recover method:
- Parameters: ctx context.Context, mountPath string, nqn string, fsType string, mountOptions []string
- Returns: (*RecoveryResult, error)

Recovery algorithm:
1. Get current device from resolver for logging
2. Attempt loop (up to MaxAttempts):
   a. Try ForceUnmount(mountPath, NormalUnmountWait)
   b. If unmount fails and error contains "in use": return error (don't retry)
   c. If unmount succeeds, resolve new device path from NQN
   d. Mount new device to mountPath with fsType and options
   e. If mount succeeds: return success result
   f. If mount fails: log warning, sleep with backoff, continue
3. If all attempts fail: return result with FinalError

Backoff calculation:
```go
backoff := config.InitialBackoff
for attempt := 1; attempt <= config.MaxAttempts; attempt++ {
    // ... attempt recovery ...
    if attempt < config.MaxAttempts {
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        case <-time.After(backoff):
            backoff = time.Duration(float64(backoff) * config.BackoffMultiplier)
        }
    }
}
```

Logging:
- klog.V(2) for recovery start
- klog.Warning for each failed attempt
- klog.V(2) for successful recovery
- klog.Error for final failure (caller will post event)
  </action>
  <verify>
go build ./pkg/mount/... compiles successfully
go vet ./pkg/mount/... passes
  </verify>
  <done>
MountRecoverer struct exists with config, mounter, checker fields
Recover method attempts up to MaxAttempts with exponential backoff
RecoveryResult includes Recovered, Attempts, FinalError, device paths
  </done>
</task>

</tasks>

<verification>
1. go build ./pkg/mount/... - all files compile
2. go vet ./pkg/mount/... - no issues
3. stale.go exports StaleMountChecker with IsMountStale
4. recovery.go exports MountRecoverer with Recover
5. StaleReason enum covers all three stale conditions
</verification>

<success_criteria>
- StaleMountChecker detects all three stale conditions
- MountRecoverer retries with exponential backoff
- Recovery respects context cancellation
- Recovery refuses to proceed if mount is in use
- All code compiles and passes vet
</success_criteria>

<output>
After completion, create `.planning/phases/02-stale-mount-detection/02-03-SUMMARY.md`
</output>
