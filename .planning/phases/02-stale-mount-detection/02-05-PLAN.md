---
phase: 02-stale-mount-detection
plan: 05
type: execute
wave: 4
depends_on: ["02-01", "02-02", "02-03", "02-04"]
files_modified:
  - pkg/mount/procmounts_test.go
  - pkg/mount/stale_test.go
  - pkg/mount/recovery_test.go
  - pkg/driver/events_test.go
autonomous: true

must_haves:
  truths:
    - "Unit tests verify /proc/mountinfo parsing"
    - "Unit tests verify stale mount detection logic"
    - "Unit tests verify recovery retry behavior"
    - "Unit tests verify event posting"
  artifacts:
    - path: "pkg/mount/procmounts_test.go"
      provides: "Tests for /proc/mountinfo parsing"
      contains: "TestGetMountDevice"
    - path: "pkg/mount/stale_test.go"
      provides: "Tests for stale mount detection"
      contains: "TestIsMountStale"
    - path: "pkg/mount/recovery_test.go"
      provides: "Tests for mount recovery"
      contains: "TestRecover"
    - path: "pkg/driver/events_test.go"
      provides: "Tests for event posting"
      contains: "TestPostMountFailure"
  key_links:
    - from: "pkg/mount/stale_test.go"
      to: "pkg/mount/stale.go"
      via: "test coverage"
      pattern: "StaleMountChecker"
---

<objective>
Comprehensive unit tests for Phase 2 stale mount detection and recovery

Purpose: Verify all detection logic, recovery behavior, and edge cases work correctly. Use dependency injection patterns established in Phase 1 for testability.

Output: Test files covering procmounts, stale detection, recovery, and events
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-device-path-resolution/01-03-SUMMARY.md
@pkg/mount/procmounts.go
@pkg/mount/stale.go
@pkg/mount/recovery.go
@pkg/driver/events.go
@pkg/nvme/resolver_test.go
@pkg/nvme/sysfs_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tests for /proc/mountinfo parsing</name>
  <files>pkg/mount/procmounts_test.go</files>
  <action>
Create pkg/mount/procmounts_test.go with tests for mount parsing.

Follow Phase 1 test patterns from sysfs_test.go - use t.TempDir() for simulated filesystems.

Test cases for GetMounts:

1. TestGetMounts_ParsesBasicMountinfo
   - Create temp file with valid mountinfo content
   - Inject custom mountinfo path
   - Verify parsed fields: Source, Target, FSType, Options

2. TestGetMounts_HandlesEscapedPaths
   - Test paths with spaces (\040)
   - Test paths with special chars (\011 for tab)
   - Verify correct unescaping

3. TestGetMounts_HandlesOptionalFields
   - Some mountinfo lines have optional fields before "-"
   - Verify parsing works with varying numbers of optional fields

Test cases for GetMountDevice:

4. TestGetMountDevice_FindsExistingMount
   - Inject mock mountinfo with known mount
   - Verify correct device returned

5. TestGetMountDevice_MountNotFound
   - Request mount that doesn't exist
   - Verify appropriate error returned

6. TestGetMountDevice_RootMount
   - Test "/" mount specifically
   - Verify returns device (usually /dev/sda1 or similar)

Mock approach:
```go
// Inject custom mountinfo source for testing
type mockMountInfoReader struct {
    content string
}

func TestGetMountDevice_FindsExistingMount(t *testing.T) {
    // Use dependency injection or file-based mock
    // Option 1: Create temp file with mountinfo content
    // Option 2: Add reader interface to GetMounts
}
```

Test the real system (integration-style) for basic sanity:
```go
func TestGetMounts_RealSystem(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test in short mode")
    }

    mounts, err := GetMounts()
    if err != nil {
        t.Fatalf("GetMounts failed: %v", err)
    }

    // Should have at least root mount
    found := false
    for _, m := range mounts {
        if m.Target == "/" {
            found = true
            t.Logf("Root mount: %s (type: %s)", m.Source, m.FSType)
            break
        }
    }
    if !found {
        t.Error("Root mount not found")
    }
}
```
  </action>
  <verify>
go test ./pkg/mount/... -v -run TestGetMount
All tests pass
  </verify>
  <done>
procmounts_test.go tests parsing of basic and escaped paths
procmounts_test.go tests GetMountDevice for found and not-found cases
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tests for stale mount detection and recovery</name>
  <files>pkg/mount/stale_test.go, pkg/mount/recovery_test.go</files>
  <action>
Create tests for stale detection and recovery logic.

For stale_test.go - use dependency injection for getMountDev:

1. TestIsMountStale_NotStale
   - Mock getMountDev returns /dev/nvme0n1
   - Mock resolver returns /dev/nvme0n1
   - Verify returns (false, StaleReasonNotStale, nil)

2. TestIsMountStale_MountNotFound
   - Mock getMountDev returns error
   - Verify returns (true, StaleReasonMountNotFound, nil)

3. TestIsMountStale_DeviceDisappeared
   - Mock getMountDev returns /dev/nvme0n1
   - /dev/nvme0n1 doesn't exist (EvalSymlinks fails)
   - Verify returns (true, StaleReasonDeviceDisappeared, nil)

4. TestIsMountStale_DeviceMismatch
   - Mock getMountDev returns /dev/nvme0n1
   - Mock resolver returns /dev/nvme1n1
   - Verify returns (true, StaleReasonDeviceMismatch, nil)

5. TestIsMountStale_ResolverError
   - Mock resolver returns error
   - Verify returns (false, "", error)

For recovery_test.go - use mock Mounter:

1. TestRecover_SucceedsFirstAttempt
   - Mock ForceUnmount succeeds
   - Mock resolver returns new device
   - Mock Mount succeeds
   - Verify RecoveryResult.Recovered == true, Attempts == 1

2. TestRecover_SucceedsAfterRetry
   - First Mount fails, second succeeds
   - Verify backoff was applied (check timing or mock sleep)
   - Verify Attempts == 2

3. TestRecover_FailsAllAttempts
   - All Mount calls fail
   - Verify Attempts == MaxAttempts
   - Verify FinalError is set

4. TestRecover_RefusesMountInUse
   - ForceUnmount returns "in use" error
   - Verify returns immediately without retry
   - Verify error indicates mount in use

5. TestRecover_RespectsContext
   - Pass cancelled context
   - Verify returns ctx.Err()

Mock Mounter pattern:
```go
type mockMounter struct {
    forceUnmountErr  error
    mountErr         error
    mountCalls       int
    forceUnmountCalls int
}

func (m *mockMounter) ForceUnmount(target string, timeout time.Duration) error {
    m.forceUnmountCalls++
    return m.forceUnmountErr
}

func (m *mockMounter) Mount(source, target, fsType string, options []string) error {
    m.mountCalls++
    return m.mountErr
}
```
  </action>
  <verify>
go test ./pkg/mount/... -v -run "TestIsMountStale|TestRecover"
All tests pass
  </verify>
  <done>
stale_test.go covers all StaleReason cases
recovery_test.go tests retry behavior and edge cases
  </done>
</task>

<task type="auto">
  <name>Task 3: Create tests for event posting</name>
  <files>pkg/driver/events_test.go</files>
  <action>
Create tests for EventPoster using fake Kubernetes client.

Use k8s.io/client-go/kubernetes/fake for testing:

1. TestNewEventPoster_CreatesRecorder
   - Create with fake clientset
   - Verify EventPoster is created without error

2. TestPostMountFailure_PostsEvent
   - Create PVC in fake clientset
   - Call PostMountFailure
   - Verify event was created (check via fake client)

3. TestPostMountFailure_PVCNotFound
   - Don't create PVC
   - Call PostMountFailure
   - Verify returns nil (graceful handling)

4. TestPostRecoveryFailed_IncludesAttemptCount
   - Create PVC
   - Call PostRecoveryFailed with attempt count
   - Verify event message includes count

5. TestPostStaleMountDetected_PostsNormalEvent
   - Create PVC
   - Call PostStaleMountDetected
   - Verify event type is Normal (not Warning)

Pattern using fake client:
```go
import (
    "k8s.io/client-go/kubernetes/fake"
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func TestPostMountFailure_PostsEvent(t *testing.T) {
    // Create fake clientset with PVC
    pvc := &corev1.PersistentVolumeClaim{
        ObjectMeta: metav1.ObjectMeta{
            Name:      "test-pvc",
            Namespace: "default",
        },
    }
    fakeClient := fake.NewSimpleClientset(pvc)

    // Create EventPoster
    poster := NewEventPoster(fakeClient)

    // Post event
    err := poster.PostMountFailure(context.Background(), "default", "test-pvc", "pvc-123", "node-1", "test failure")
    if err != nil {
        t.Fatalf("PostMountFailure failed: %v", err)
    }

    // Note: Verifying actual event creation is tricky with EventRecorder
    // The fake client may not capture events the same way
    // Consider checking recorder calls or using a custom test recorder
}
```

Alternative approach - test the event message formatting:
```go
func TestEventMessage_Format(t *testing.T) {
    msg := formatMountFailureMessage("pvc-123", "node-1", "device not found")
    expected := "[pvc-123] on [node-1]: device not found"
    if msg != expected {
        t.Errorf("expected %q, got %q", expected, msg)
    }
}
```
  </action>
  <verify>
go test ./pkg/driver/... -v -run TestPost
All tests pass
  </verify>
  <done>
events_test.go tests EventPoster creation
events_test.go tests event posting with fake client
events_test.go tests graceful handling of missing PVC
  </done>
</task>

</tasks>

<verification>
1. go test ./pkg/mount/... -v - all mount tests pass
2. go test ./pkg/driver/... -v - all driver tests pass
3. go test ./... -cover - check coverage
4. All new code has corresponding tests
</verification>

<success_criteria>
- procmounts_test.go tests parsing and edge cases
- stale_test.go tests all StaleReason conditions
- recovery_test.go tests retry behavior and context cancellation
- events_test.go tests event posting with fake client
- go test ./... passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-stale-mount-detection/02-05-SUMMARY.md`
</output>
