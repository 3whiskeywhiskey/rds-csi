---
phase: 07-robustness-observability
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/attachment/reconciler.go
  - pkg/driver/driver.go
  - pkg/driver/controller.go
  - pkg/attachment/reconciler_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "PostVolumeAttached called after successful attachment tracking"
    - "PostVolumeDetached called after successful detachment tracking"
    - "PostStaleAttachmentCleared called when reconciler clears stale attachment"
  artifacts:
    - path: "pkg/attachment/reconciler.go"
      provides: "EventPoster integration in reconciler"
      contains: "eventPoster"
    - path: "pkg/driver/controller.go"
      provides: "Event posting in publish/unpublish"
      contains: "PostVolumeAttached"
    - path: "pkg/driver/driver.go"
      provides: "EventPoster passed to reconciler"
      contains: "EventPoster"
  key_links:
    - from: "pkg/driver/controller.go:ControllerPublishVolume"
      to: "pkg/driver/events.go:PostVolumeAttached"
      via: "direct call after TrackAttachment success"
      pattern: "PostVolumeAttached"
    - from: "pkg/driver/controller.go:ControllerUnpublishVolume"
      to: "pkg/driver/events.go:PostVolumeDetached"
      via: "direct call after UntrackAttachment success"
      pattern: "PostVolumeDetached"
    - from: "pkg/attachment/reconciler.go:reconcile"
      to: "EventPoster.PostStaleAttachmentCleared"
      via: "call after UntrackAttachment in stale cleanup"
      pattern: "PostStaleAttachmentCleared"
---

<objective>
Integrate attachment lifecycle event posting into controller and reconciler.

Purpose: Close gap identified in 07-VERIFICATION.md - event posting methods exist but are not called from publish/unpublish/reconcile paths.

Output: Kubernetes events posted to PVCs for VolumeAttached, VolumeDetached, and StaleAttachmentCleared lifecycle events.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/07-robustness-observability/07-VERIFICATION.md

# Key files to modify
@pkg/driver/events.go - Contains PostVolumeAttached, PostVolumeDetached, PostStaleAttachmentCleared methods
@pkg/driver/controller.go - Contains ControllerPublishVolume (line ~507) and ControllerUnpublishVolume (line ~552)
@pkg/attachment/reconciler.go - Contains reconcile() method that clears stale attachments (line ~186)
@pkg/driver/driver.go - Creates AttachmentReconciler, needs to pass EventPoster

# Reference for wiring patterns
@pkg/driver/controller.go:371-393 - Example: postAttachmentConflictEvent pattern shows how to create temporary EventPoster and call it
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EventPoster to AttachmentReconciler</name>
  <files>pkg/attachment/reconciler.go</files>
  <action>
    Add EventPoster support to the reconciler for posting StaleAttachmentCleared events.

    1. Add import for driver package (use interface to avoid circular dependency):
       - Add EventPosterInterface that defines PostStaleAttachmentCleared method signature
       - OR import the event posting as a function parameter (simpler)

    2. Add eventPoster field to ReconcilerConfig struct:
       ```go
       type ReconcilerConfig struct {
           // ... existing fields ...
           EventPoster EventPoster // Optional, may be nil
       }
       ```

       Where EventPoster is an interface:
       ```go
       // EventPoster posts Kubernetes events for attachment lifecycle
       type EventPoster interface {
           PostStaleAttachmentCleared(ctx context.Context, pvcNamespace, pvcName, volumeID, staleNodeID string) error
       }
       ```

    3. Add eventPoster field to AttachmentReconciler struct

    4. Set eventPoster in NewAttachmentReconciler (nil is allowed - optional)

    5. In reconcile() after successfully clearing stale attachment (~line 186 after metrics recording):
       - Check if eventPoster is not nil
       - Call PostStaleAttachmentCleared
       - Note: We need volumeID and staleNodeID (already have), but need pvcNamespace/pvcName
       - Get PVC info from PV annotation if available (AttachmentState may have PV name, look up PV to get claimRef)
       - If PVC info not available, log only (best effort, don't fail reconciliation)
       - Pattern: Best effort event posting - log warning if fails, don't block cleanup

    The reconciler should NOT fail if event posting fails - it's observability, not correctness.
  </action>
  <verify>
    ```bash
    go build ./pkg/attachment/...
    go test ./pkg/attachment/... -run "TestReconciler" -v
    ```
  </verify>
  <done>
    ReconcilerConfig accepts EventPoster, reconciler calls PostStaleAttachmentCleared when clearing stale attachments (if EventPoster provided).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire EventPoster into reconciler from driver</name>
  <files>pkg/driver/driver.go</files>
  <action>
    Pass EventPoster to AttachmentReconciler when creating it.

    In NewDriver function, where AttachmentReconciler is created (~line 157-178):

    1. Create EventPoster before creating reconciler:
       ```go
       var eventPoster *EventPoster
       if config.K8sClient != nil {
           eventPoster = NewEventPoster(config.K8sClient)
       }
       ```

    2. Pass to reconciler config:
       ```go
       reconcilerConfig := attachment.ReconcilerConfig{
           Manager:     driver.attachmentManager,
           K8sClient:   config.K8sClient,
           Interval:    config.AttachmentReconcileInterval,
           GracePeriod: config.AttachmentGracePeriod,
           Metrics:     config.Metrics,
           EventPoster: eventPoster,  // Add this line
       }
       ```

    Note: The EventPoster type from driver package must implement the interface defined in attachment package. Since both are in rds-csi-driver, this is straightforward - the driver.EventPoster has the PostStaleAttachmentCleared method that matches.

    The interface approach avoids circular dependency: attachment package defines interface, driver package implements it.
  </action>
  <verify>
    ```bash
    go build ./pkg/driver/...
    ```
  </verify>
  <done>
    EventPoster passed to AttachmentReconciler, driver builds successfully without circular dependency.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add event posting to ControllerPublishVolume and ControllerUnpublishVolume</name>
  <files>pkg/driver/controller.go</files>
  <action>
    Add calls to PostVolumeAttached and PostVolumeDetached in the controller.

    **In ControllerPublishVolume** (after line ~507 where metrics are recorded):

    1. After successful TrackAttachment and metrics recording, add event posting:
       ```go
       // Post attachment event (best effort)
       cs.postVolumeAttachedEvent(ctx, req, time.Since(startTime))
       ```

    2. Create helper method postVolumeAttachedEvent (similar to postAttachmentConflictEvent pattern):
       ```go
       func (cs *ControllerServer) postVolumeAttachedEvent(ctx context.Context, req *csi.ControllerPublishVolumeRequest, duration time.Duration) {
           volCtx := req.GetVolumeContext()
           pvcNamespace := volCtx["csi.storage.k8s.io/pvc/namespace"]
           pvcName := volCtx["csi.storage.k8s.io/pvc/name"]

           if pvcNamespace == "" || pvcName == "" {
               klog.V(3).Infof("Cannot post volume attached event: PVC info not in volume context")
               return
           }

           if cs.driver.k8sClient == nil {
               return
           }

           poster := NewEventPoster(cs.driver.k8sClient)
           if err := poster.PostVolumeAttached(ctx, pvcNamespace, pvcName, req.GetVolumeId(), req.GetNodeId(), duration); err != nil {
               klog.Warningf("Failed to post volume attached event: %v", err)
           }
       }
       ```

    **In ControllerUnpublishVolume** (after line ~552 where metrics are recorded):

    1. After successful UntrackAttachment and metrics recording, add event posting:
       ```go
       // Post detachment event (best effort)
       cs.postVolumeDetachedEvent(ctx, req)
       ```

    2. Create helper method postVolumeDetachedEvent:
       ```go
       func (cs *ControllerServer) postVolumeDetachedEvent(ctx context.Context, req *csi.ControllerUnpublishVolumeRequest) {
           // For unpublish, we don't have volume context with PVC info
           // We need to look up the PV to get the claimRef
           if cs.driver.k8sClient == nil {
               return
           }

           // Try to get PV to find the bound PVC
           pv, err := cs.driver.k8sClient.CoreV1().PersistentVolumes().Get(ctx, req.GetVolumeId(), metav1.GetOptions{})
           if err != nil {
               klog.V(3).Infof("Cannot get PV %s for detached event: %v", req.GetVolumeId(), err)
               return
           }

           claimRef := pv.Spec.ClaimRef
           if claimRef == nil {
               klog.V(3).Infof("PV %s has no claimRef for detached event", req.GetVolumeId())
               return
           }

           poster := NewEventPoster(cs.driver.k8sClient)
           if err := poster.PostVolumeDetached(ctx, claimRef.Namespace, claimRef.Name, req.GetVolumeId(), req.GetNodeId()); err != nil {
               klog.Warningf("Failed to post volume detached event: %v", err)
           }
       }
       ```

    Key design decisions:
    - Best effort: Don't fail CSI operations if event posting fails
    - PVC info from volumeContext for publish (provided by CSI)
    - PVC info from PV claimRef for unpublish (lookup required)
    - Follow existing pattern from postAttachmentConflictEvent
  </action>
  <verify>
    ```bash
    go build ./pkg/driver/...
    go test ./pkg/driver/... -run "TestController" -v
    ```
  </verify>
  <done>
    ControllerPublishVolume posts VolumeAttached event, ControllerUnpublishVolume posts VolumeDetached event. All events are best-effort (failures logged, not propagated).
  </done>
</task>

</tasks>

<verification>
1. Build all packages:
   ```bash
   go build ./pkg/...
   ```

2. Run attachment tests:
   ```bash
   go test ./pkg/attachment/... -v
   ```

3. Run driver tests:
   ```bash
   go test ./pkg/driver/... -v -run "Controller"
   ```

4. Run full test suite:
   ```bash
   make test
   ```

5. Verify no new linting issues:
   ```bash
   make lint
   ```

6. Manual verification of wiring:
   - grep for PostVolumeAttached in controller.go
   - grep for PostVolumeDetached in controller.go
   - grep for PostStaleAttachmentCleared in reconciler.go
</verification>

<success_criteria>
- All packages build without errors
- All existing tests pass
- PostVolumeAttached called in ControllerPublishVolume after successful attach
- PostVolumeDetached called in ControllerUnpublishVolume after successful detach
- PostStaleAttachmentCleared called in reconciler when clearing stale attachments
- All event posting is best-effort (failures logged, not propagated to callers)
- No circular dependencies between packages
</success_criteria>

<output>
After completion, create `.planning/phases/07-robustness-observability/07-04-SUMMARY.md`
</output>
