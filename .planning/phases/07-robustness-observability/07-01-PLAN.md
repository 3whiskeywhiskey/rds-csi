---
phase: 07-robustness-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/attachment/types.go
  - pkg/attachment/manager.go
  - pkg/observability/prometheus.go
  - pkg/driver/events.go
autonomous: true

must_haves:
  truths:
    - "AttachmentState tracks when volume was detached for grace period calculation"
    - "AttachmentManager exposes method to check if volume is within grace period"
    - "Prometheus metrics expose attachment operation counts and durations"
    - "EventPoster has methods for posting VolumeAttached and VolumeDetached events"
  artifacts:
    - path: "pkg/attachment/types.go"
      provides: "DetachedAt field in AttachmentState"
      contains: "DetachedAt"
    - path: "pkg/attachment/manager.go"
      provides: "Grace period checking and detach timestamp tracking"
      exports: ["IsWithinGracePeriod", "GetDetachTimestamp"]
    - path: "pkg/observability/prometheus.go"
      provides: "Attachment-specific metrics"
      contains: "attachmentAttachTotal"
    - path: "pkg/driver/events.go"
      provides: "Attachment lifecycle event posting methods"
      exports: ["PostVolumeAttached", "PostVolumeDetached"]
  key_links:
    - from: "pkg/attachment/manager.go"
      to: "pkg/attachment/types.go"
      via: "AttachmentState with DetachedAt field"
      pattern: "DetachedAt.*time\\.Time"
    - from: "pkg/observability/prometheus.go"
      to: "prometheus.Counter"
      via: "Attachment metrics registered"
      pattern: "attachmentAttachTotal"
---

<objective>
Add grace period tracking to AttachmentState and comprehensive Prometheus metrics for attachment operations.

Purpose: Enable grace period logic for KubeVirt live migration handoff and provide production observability for attachment lifecycle.
Output: AttachmentState with DetachedAt tracking, grace period methods, attachment Prometheus metrics, and attachment event posting methods.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.3-ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-robustness-observability/07-CONTEXT.md
@.planning/phases/07-robustness-observability/07-RESEARCH.md
@pkg/attachment/types.go
@pkg/attachment/manager.go
@pkg/observability/prometheus.go
@pkg/driver/events.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add grace period tracking to AttachmentState and AttachmentManager</name>
  <files>pkg/attachment/types.go, pkg/attachment/manager.go</files>
  <action>
1. In pkg/attachment/types.go, add DetachedAt field to AttachmentState:
   ```go
   // DetachedAt is the timestamp when the volume was detached.
   // nil if volume is currently attached. Used for grace period calculation.
   DetachedAt *time.Time
   ```

2. In pkg/attachment/manager.go, add a new map and methods for tracking detach timestamps:
   - Add `detachTimestamps map[string]time.Time` field to AttachmentManager struct (tracks last detach time per volume, separate from attachments map)
   - Initialize in NewAttachmentManager: `detachTimestamps: make(map[string]time.Time)`

3. In UntrackAttachment method, before deleting from attachments map, record the detach timestamp:
   ```go
   // Record detach timestamp for grace period tracking
   am.detachTimestamps[volumeID] = time.Now()
   ```

4. Add IsWithinGracePeriod method:
   ```go
   // IsWithinGracePeriod checks if a volume was recently detached and is within grace period.
   // This allows live migration handoff by preventing false conflicts.
   // Returns true if volume was detached less than gracePeriod ago.
   func (am *AttachmentManager) IsWithinGracePeriod(volumeID string, gracePeriod time.Duration) bool {
       am.mu.RLock()
       defer am.mu.RUnlock()

       detachTime, exists := am.detachTimestamps[volumeID]
       if !exists {
           return false
       }

       return time.Since(detachTime) < gracePeriod
   }
   ```

5. Add GetDetachTimestamp method for observability:
   ```go
   // GetDetachTimestamp returns the last detach timestamp for a volume.
   // Returns zero time if volume was never detached.
   func (am *AttachmentManager) GetDetachTimestamp(volumeID string) time.Time {
       am.mu.RLock()
       defer am.mu.RUnlock()

       return am.detachTimestamps[volumeID]
   }
   ```

6. Add ClearDetachTimestamp method (called after successful attach to clean up old timestamps):
   ```go
   // ClearDetachTimestamp removes the detach timestamp for a volume.
   // Called after successful reattachment.
   func (am *AttachmentManager) ClearDetachTimestamp(volumeID string) {
       am.mu.Lock()
       defer am.mu.Unlock()

       delete(am.detachTimestamps, volumeID)
   }
   ```
  </action>
  <verify>
go build ./pkg/attachment/...
go vet ./pkg/attachment/...
  </verify>
  <done>
AttachmentState has DetachedAt field. AttachmentManager tracks detach timestamps in separate map. IsWithinGracePeriod, GetDetachTimestamp, and ClearDetachTimestamp methods exist and build successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add attachment Prometheus metrics</name>
  <files>pkg/observability/prometheus.go</files>
  <action>
1. Add attachment-specific metric fields to Metrics struct (after existing fields):
   ```go
   // Attachment operation metrics
   attachmentAttachTotal     *prometheus.CounterVec
   attachmentDetachTotal     *prometheus.CounterVec
   attachmentConflictsTotal  prometheus.Counter
   attachmentReconcileTotal  *prometheus.CounterVec
   attachmentOpDuration      *prometheus.HistogramVec
   attachmentGracePeriodUsed prometheus.Counter
   attachmentStaleCleared    prometheus.Counter
   ```

2. Initialize metrics in NewMetrics() function (after orphansCleanedTotal initialization):
   ```go
   attachmentAttachTotal: prometheus.NewCounterVec(
       prometheus.CounterOpts{
           Namespace: namespace,
           Subsystem: "attachment",
           Name:      "attach_total",
           Help:      "Total attachment operations by status",
       },
       []string{"status"}, // success, failure
   ),

   attachmentDetachTotal: prometheus.NewCounterVec(
       prometheus.CounterOpts{
           Namespace: namespace,
           Subsystem: "attachment",
           Name:      "detach_total",
           Help:      "Total detachment operations by status",
       },
       []string{"status"},
   ),

   attachmentConflictsTotal: prometheus.NewCounter(prometheus.CounterOpts{
       Namespace: namespace,
       Subsystem: "attachment",
       Name:      "conflicts_total",
       Help:      "Total attachment conflicts (RWO violations)",
   }),

   attachmentReconcileTotal: prometheus.NewCounterVec(
       prometheus.CounterOpts{
           Namespace: namespace,
           Subsystem: "attachment",
           Name:      "reconcile_total",
           Help:      "Total reconciliation actions by type",
       },
       []string{"action"}, // clear_stale, sync_annotation
   ),

   attachmentOpDuration: prometheus.NewHistogramVec(
       prometheus.HistogramOpts{
           Namespace: namespace,
           Subsystem: "attachment",
           Name:      "operation_duration_seconds",
           Help:      "Duration of attachment operations",
           Buckets:   []float64{0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5},
       },
       []string{"operation"}, // attach, detach, reconcile
   ),

   attachmentGracePeriodUsed: prometheus.NewCounter(prometheus.CounterOpts{
       Namespace: namespace,
       Subsystem: "attachment",
       Name:      "grace_period_used_total",
       Help:      "Total times grace period prevented a conflict",
   }),

   attachmentStaleCleared: prometheus.NewCounter(prometheus.CounterOpts{
       Namespace: namespace,
       Subsystem: "attachment",
       Name:      "stale_cleared_total",
       Help:      "Total stale attachments cleared by reconciler",
   }),
   ```

3. Register metrics (add to reg.MustRegister call):
   ```go
   m.attachmentAttachTotal,
   m.attachmentDetachTotal,
   m.attachmentConflictsTotal,
   m.attachmentReconcileTotal,
   m.attachmentOpDuration,
   m.attachmentGracePeriodUsed,
   m.attachmentStaleCleared,
   ```

4. Add recording methods (after RecordEventPosted):
   ```go
   // RecordAttachmentOp records an attachment or detachment operation with duration.
   // operation should be "attach" or "detach".
   func (m *Metrics) RecordAttachmentOp(operation string, err error, duration time.Duration) {
       status := "success"
       if err != nil {
           status = "failure"
       }

       switch operation {
       case "attach":
           m.attachmentAttachTotal.WithLabelValues(status).Inc()
       case "detach":
           m.attachmentDetachTotal.WithLabelValues(status).Inc()
       }

       m.attachmentOpDuration.WithLabelValues(operation).Observe(duration.Seconds())
   }

   // RecordAttachmentConflict records an RWO attachment conflict.
   func (m *Metrics) RecordAttachmentConflict() {
       m.attachmentConflictsTotal.Inc()
   }

   // RecordGracePeriodUsed records when grace period prevented a conflict.
   func (m *Metrics) RecordGracePeriodUsed() {
       m.attachmentGracePeriodUsed.Inc()
   }

   // RecordStaleAttachmentCleared records when reconciler cleared a stale attachment.
   func (m *Metrics) RecordStaleAttachmentCleared() {
       m.attachmentStaleCleared.Inc()
   }

   // RecordReconcileAction records a reconciliation action.
   // action should be "clear_stale" or "sync_annotation".
   func (m *Metrics) RecordReconcileAction(action string) {
       m.attachmentReconcileTotal.WithLabelValues(action).Inc()
   }
   ```
  </action>
  <verify>
go build ./pkg/observability/...
go vet ./pkg/observability/...
  </verify>
  <done>
Metrics struct has attachment-specific fields. NewMetrics initializes and registers all attachment metrics. Recording methods exist for all attachment operations (RecordAttachmentOp, RecordAttachmentConflict, RecordGracePeriodUsed, RecordStaleAttachmentCleared, RecordReconcileAction).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add attachment lifecycle event posting methods</name>
  <files>pkg/driver/events.go</files>
  <action>
1. Add new event reason constants (after EventReasonAttachmentConflict):
   ```go
   // Attachment lifecycle events
   EventReasonVolumeAttached         = "VolumeAttached"
   EventReasonVolumeDetached         = "VolumeDetached"
   EventReasonStaleAttachmentCleared = "StaleAttachmentCleared"
   ```

2. Add PostVolumeAttached method:
   ```go
   // PostVolumeAttached posts a Normal event when a volume is attached to a node.
   // Parameters: ctx, pvcNamespace, pvcName, volumeID, nodeID, duration
   func (ep *EventPoster) PostVolumeAttached(ctx context.Context, pvcNamespace, pvcName, volumeID, nodeID string, duration time.Duration) error {
       pvc, err := ep.clientset.CoreV1().PersistentVolumeClaims(pvcNamespace).Get(ctx, pvcName, metav1.GetOptions{})
       if err != nil {
           klog.Warningf("Failed to get PVC %s/%s for volume attached event: %v", pvcNamespace, pvcName, err)
           return nil // Don't fail the operation
       }

       eventMessage := fmt.Sprintf("[%s]: Attached to node %s (duration: %s)", volumeID, nodeID, duration.Round(time.Millisecond))
       ep.recorder.Event(pvc, corev1.EventTypeNormal, EventReasonVolumeAttached, eventMessage)

       if ep.metrics != nil {
           ep.metrics.RecordEventPosted(EventReasonVolumeAttached)
       }

       klog.V(2).Infof("Posted volume attached event to PVC %s/%s: %s", pvcNamespace, pvcName, eventMessage)
       return nil
   }
   ```

3. Add PostVolumeDetached method:
   ```go
   // PostVolumeDetached posts a Normal event when a volume is detached from a node.
   // Parameters: ctx, pvcNamespace, pvcName, volumeID, nodeID
   func (ep *EventPoster) PostVolumeDetached(ctx context.Context, pvcNamespace, pvcName, volumeID, nodeID string) error {
       pvc, err := ep.clientset.CoreV1().PersistentVolumeClaims(pvcNamespace).Get(ctx, pvcName, metav1.GetOptions{})
       if err != nil {
           klog.Warningf("Failed to get PVC %s/%s for volume detached event: %v", pvcNamespace, pvcName, err)
           return nil
       }

       eventMessage := fmt.Sprintf("[%s]: Detached from node %s", volumeID, nodeID)
       ep.recorder.Event(pvc, corev1.EventTypeNormal, EventReasonVolumeDetached, eventMessage)

       if ep.metrics != nil {
           ep.metrics.RecordEventPosted(EventReasonVolumeDetached)
       }

       klog.V(2).Infof("Posted volume detached event to PVC %s/%s: %s", pvcNamespace, pvcName, eventMessage)
       return nil
   }
   ```

4. Add PostStaleAttachmentCleared method:
   ```go
   // PostStaleAttachmentCleared posts a Normal event when a stale attachment is cleared by reconciler.
   // Parameters: ctx, pvcNamespace, pvcName, volumeID, staleNodeID
   func (ep *EventPoster) PostStaleAttachmentCleared(ctx context.Context, pvcNamespace, pvcName, volumeID, staleNodeID string) error {
       pvc, err := ep.clientset.CoreV1().PersistentVolumeClaims(pvcNamespace).Get(ctx, pvcName, metav1.GetOptions{})
       if err != nil {
           klog.Warningf("Failed to get PVC %s/%s for stale attachment cleared event: %v", pvcNamespace, pvcName, err)
           return nil
       }

       eventMessage := fmt.Sprintf("[%s]: Cleared stale attachment from deleted node %s", volumeID, staleNodeID)
       ep.recorder.Event(pvc, corev1.EventTypeNormal, EventReasonStaleAttachmentCleared, eventMessage)

       if ep.metrics != nil {
           ep.metrics.RecordEventPosted(EventReasonStaleAttachmentCleared)
       }

       klog.V(2).Infof("Posted stale attachment cleared event to PVC %s/%s: %s", pvcNamespace, pvcName, eventMessage)
       return nil
   }
   ```

5. Add "time" import at the top if not already present.
  </action>
  <verify>
go build ./pkg/driver/...
go vet ./pkg/driver/...
  </verify>
  <done>
EventPoster has PostVolumeAttached, PostVolumeDetached, and PostStaleAttachmentCleared methods. Event reason constants defined for VolumeAttached, VolumeDetached, StaleAttachmentCleared.
  </done>
</task>

</tasks>

<verification>
# Build all modified packages
go build ./pkg/attachment/... ./pkg/observability/... ./pkg/driver/...

# Run vet on all modified packages
go vet ./pkg/attachment/... ./pkg/observability/... ./pkg/driver/...

# Run existing tests (should still pass)
go test ./pkg/attachment/... ./pkg/observability/... ./pkg/driver/... -v
</verification>

<success_criteria>
1. AttachmentState has DetachedAt field for tracking detachment time
2. AttachmentManager has detachTimestamps map and IsWithinGracePeriod method
3. Prometheus metrics exist for attachment operations (attach_total, detach_total, conflicts_total, operation_duration_seconds, grace_period_used_total, stale_cleared_total, reconcile_total)
4. EventPoster has methods for posting VolumeAttached, VolumeDetached, and StaleAttachmentCleared events
5. All packages build and pass vet checks
6. Existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-robustness-observability/07-01-SUMMARY.md`
</output>
