---
phase: 07-robustness-observability
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - pkg/attachment/reconciler_test.go
  - pkg/attachment/manager_test.go
autonomous: true

must_haves:
  truths:
    - "Unit tests verify grace period tracking in AttachmentManager"
    - "Unit tests verify AttachmentReconciler clears stale attachments from deleted nodes"
    - "Unit tests verify grace period prevents false conflicts during live migration"
    - "Unit tests verify reconciler respects context cancellation for graceful shutdown"
  artifacts:
    - path: "pkg/attachment/reconciler_test.go"
      provides: "Unit tests for AttachmentReconciler"
      contains: "TestReconciler"
    - path: "pkg/attachment/manager_test.go"
      provides: "Extended tests for grace period tracking"
      contains: "TestIsWithinGracePeriod"
  key_links:
    - from: "pkg/attachment/reconciler_test.go"
      to: "pkg/attachment/reconciler.go"
      via: "Tests reconciliation logic"
      pattern: "NewAttachmentReconciler"
    - from: "pkg/attachment/manager_test.go"
      to: "pkg/attachment/manager.go"
      via: "Tests grace period methods"
      pattern: "IsWithinGracePeriod"
---

<objective>
Add comprehensive unit tests for grace period tracking and attachment reconciliation.

Purpose: Ensure grace period logic works correctly for KubeVirt live migration and reconciler properly detects and clears stale attachments.
Output: Test files covering grace period tracking, reconciler behavior, and edge cases.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.3-ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-robustness-observability/07-CONTEXT.md
@.planning/phases/07-robustness-observability/07-01-SUMMARY.md
@.planning/phases/07-robustness-observability/07-02-SUMMARY.md
@pkg/attachment/reconciler.go
@pkg/attachment/manager.go
@pkg/attachment/manager_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add grace period tracking tests to manager_test.go</name>
  <files>pkg/attachment/manager_test.go</files>
  <action>
Add the following tests to pkg/attachment/manager_test.go (at the end of the file):

```go
func TestIsWithinGracePeriod_NoDetachTimestamp(t *testing.T) {
	am := NewAttachmentManager(nil)

	// Volume never tracked/detached should not be within grace period
	result := am.IsWithinGracePeriod("pvc-never-existed", 30*time.Second)
	if result {
		t.Error("Expected IsWithinGracePeriod to return false for non-existent volume")
	}
}

func TestIsWithinGracePeriod_WithinPeriod(t *testing.T) {
	am := NewAttachmentManager(nil)
	ctx := context.Background()
	volumeID := "pvc-test-grace-within"
	nodeID := "node-1"

	// Track and then untrack to create detach timestamp
	err := am.TrackAttachment(ctx, volumeID, nodeID)
	if err != nil {
		t.Fatalf("TrackAttachment failed: %v", err)
	}

	err = am.UntrackAttachment(ctx, volumeID)
	if err != nil {
		t.Fatalf("UntrackAttachment failed: %v", err)
	}

	// Check immediately after detach (should be within grace period)
	result := am.IsWithinGracePeriod(volumeID, 30*time.Second)
	if !result {
		t.Error("Expected IsWithinGracePeriod to return true immediately after detach")
	}
}

func TestIsWithinGracePeriod_OutsidePeriod(t *testing.T) {
	am := NewAttachmentManager(nil)
	ctx := context.Background()
	volumeID := "pvc-test-grace-outside"
	nodeID := "node-1"

	// Track and then untrack
	err := am.TrackAttachment(ctx, volumeID, nodeID)
	if err != nil {
		t.Fatalf("TrackAttachment failed: %v", err)
	}

	err = am.UntrackAttachment(ctx, volumeID)
	if err != nil {
		t.Fatalf("UntrackAttachment failed: %v", err)
	}

	// Use a very short grace period that we've already exceeded
	result := am.IsWithinGracePeriod(volumeID, 1*time.Nanosecond)
	// Sleep a tiny bit to ensure we're past the grace period
	time.Sleep(1 * time.Millisecond)

	result = am.IsWithinGracePeriod(volumeID, 1*time.Nanosecond)
	if result {
		t.Error("Expected IsWithinGracePeriod to return false after grace period expired")
	}
}

func TestGetDetachTimestamp(t *testing.T) {
	am := NewAttachmentManager(nil)
	ctx := context.Background()
	volumeID := "pvc-test-detach-time"
	nodeID := "node-1"

	// Before any tracking, should return zero time
	ts := am.GetDetachTimestamp(volumeID)
	if !ts.IsZero() {
		t.Error("Expected zero timestamp for never-tracked volume")
	}

	// Track and untrack
	_ = am.TrackAttachment(ctx, volumeID, nodeID)
	_ = am.UntrackAttachment(ctx, volumeID)

	// Should have a non-zero timestamp now
	ts = am.GetDetachTimestamp(volumeID)
	if ts.IsZero() {
		t.Error("Expected non-zero timestamp after untrack")
	}

	// Timestamp should be recent
	if time.Since(ts) > 5*time.Second {
		t.Error("Detach timestamp is too old")
	}
}

func TestClearDetachTimestamp(t *testing.T) {
	am := NewAttachmentManager(nil)
	ctx := context.Background()
	volumeID := "pvc-test-clear-time"
	nodeID := "node-1"

	// Track and untrack to create timestamp
	_ = am.TrackAttachment(ctx, volumeID, nodeID)
	_ = am.UntrackAttachment(ctx, volumeID)

	// Verify timestamp exists
	ts := am.GetDetachTimestamp(volumeID)
	if ts.IsZero() {
		t.Fatal("Expected timestamp to exist before clear")
	}

	// Clear it
	am.ClearDetachTimestamp(volumeID)

	// Should no longer be within grace period
	result := am.IsWithinGracePeriod(volumeID, 30*time.Second)
	if result {
		t.Error("Expected IsWithinGracePeriod to return false after clearing timestamp")
	}
}

func TestGracePeriod_LiveMigrationScenario(t *testing.T) {
	// Simulates KubeVirt live migration: detach from node-1, attach to node-2
	am := NewAttachmentManager(nil)
	ctx := context.Background()
	volumeID := "pvc-kubevirt-vm-disk"
	node1 := "worker-node-1"
	node2 := "worker-node-2"
	gracePeriod := 30 * time.Second

	// Initial attachment to node-1
	err := am.TrackAttachment(ctx, volumeID, node1)
	if err != nil {
		t.Fatalf("Initial track failed: %v", err)
	}

	// Detach from node-1 (VM migrating)
	err = am.UntrackAttachment(ctx, volumeID)
	if err != nil {
		t.Fatalf("Untrack failed: %v", err)
	}

	// Immediately try to attach to node-2 (migration target)
	// Should be within grace period
	if !am.IsWithinGracePeriod(volumeID, gracePeriod) {
		t.Error("Expected to be within grace period immediately after detach")
	}

	// Clear timestamp as handoff completes
	am.ClearDetachTimestamp(volumeID)

	// Track to new node
	err = am.TrackAttachment(ctx, volumeID, node2)
	if err != nil {
		t.Fatalf("Reattachment failed: %v", err)
	}

	// Verify attached to new node
	state, exists := am.GetAttachment(volumeID)
	if !exists {
		t.Fatal("Expected attachment to exist")
	}
	if state.NodeID != node2 {
		t.Errorf("Expected attachment to node %s, got %s", node2, state.NodeID)
	}
}
```
  </action>
  <verify>
go test ./pkg/attachment/... -v -run "TestIsWithinGracePeriod|TestGetDetachTimestamp|TestClearDetachTimestamp|TestGracePeriod_LiveMigrationScenario"
  </verify>
  <done>
Grace period tracking tests pass: TestIsWithinGracePeriod_NoDetachTimestamp, TestIsWithinGracePeriod_WithinPeriod, TestIsWithinGracePeriod_OutsidePeriod, TestGetDetachTimestamp, TestClearDetachTimestamp, TestGracePeriod_LiveMigrationScenario.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create reconciler unit tests</name>
  <files>pkg/attachment/reconciler_test.go</files>
  <action>
Create new file pkg/attachment/reconciler_test.go:

```go
package attachment

import (
	"context"
	"testing"
	"time"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/fake"
	k8stesting "k8s.io/client-go/testing"
)

func TestNewAttachmentReconciler_RequiresManager(t *testing.T) {
	k8sClient := fake.NewSimpleClientset()

	_, err := NewAttachmentReconciler(ReconcilerConfig{
		Manager:   nil,
		K8sClient: k8sClient,
	})

	if err == nil {
		t.Error("Expected error when manager is nil")
	}
}

func TestNewAttachmentReconciler_RequiresK8sClient(t *testing.T) {
	am := NewAttachmentManager(nil)

	_, err := NewAttachmentReconciler(ReconcilerConfig{
		Manager:   am,
		K8sClient: nil,
	})

	if err == nil {
		t.Error("Expected error when k8sClient is nil")
	}
}

func TestNewAttachmentReconciler_DefaultValues(t *testing.T) {
	am := NewAttachmentManager(nil)
	k8sClient := fake.NewSimpleClientset()

	r, err := NewAttachmentReconciler(ReconcilerConfig{
		Manager:   am,
		K8sClient: k8sClient,
		// No interval or grace period specified
	})

	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}

	// Check defaults
	if r.interval != 5*time.Minute {
		t.Errorf("Expected default interval of 5 minutes, got %v", r.interval)
	}
	if r.gracePeriod != 30*time.Second {
		t.Errorf("Expected default grace period of 30 seconds, got %v", r.gracePeriod)
	}
}

func TestReconciler_StartStop(t *testing.T) {
	am := NewAttachmentManager(nil)
	k8sClient := fake.NewSimpleClientset()

	r, err := NewAttachmentReconciler(ReconcilerConfig{
		Manager:     am,
		K8sClient:   k8sClient,
		Interval:    100 * time.Millisecond,
		GracePeriod: 10 * time.Millisecond,
	})
	if err != nil {
		t.Fatalf("Failed to create reconciler: %v", err)
	}

	ctx := context.Background()

	// Start should succeed
	err = r.Start(ctx)
	if err != nil {
		t.Fatalf("Start failed: %v", err)
	}

	// Start again should fail (already running)
	err = r.Start(ctx)
	if err == nil {
		t.Error("Expected error when starting already-running reconciler")
	}

	// Stop should succeed
	r.Stop()

	// Stop again should be safe (no-op)
	r.Stop()
}

func TestReconciler_ContextCancellation(t *testing.T) {
	am := NewAttachmentManager(nil)
	k8sClient := fake.NewSimpleClientset()

	r, err := NewAttachmentReconciler(ReconcilerConfig{
		Manager:     am,
		K8sClient:   k8sClient,
		Interval:    1 * time.Hour, // Long interval so we control timing
		GracePeriod: 30 * time.Second,
	})
	if err != nil {
		t.Fatalf("Failed to create reconciler: %v", err)
	}

	ctx, cancel := context.WithCancel(context.Background())

	err = r.Start(ctx)
	if err != nil {
		t.Fatalf("Start failed: %v", err)
	}

	// Cancel context
	cancel()

	// Give it a moment to shut down
	time.Sleep(50 * time.Millisecond)

	// Should be able to start again after context cancellation
	ctx2 := context.Background()
	r.mu.Lock()
	r.stopCh = nil
	r.doneCh = nil
	r.mu.Unlock()

	err = r.Start(ctx2)
	if err != nil {
		t.Fatalf("Failed to restart after context cancellation: %v", err)
	}

	r.Stop()
}

func TestReconciler_ClearsStaleAttachment_NodeDeleted(t *testing.T) {
	// Create fake k8s client with NO nodes
	k8sClient := fake.NewSimpleClientset()

	// Create attachment manager and track a volume
	am := NewAttachmentManager(nil)
	ctx := context.Background()
	volumeID := "pvc-test-stale"
	nodeID := "deleted-node"

	// Track attachment to a node that doesn't exist in k8s
	err := am.TrackAttachment(ctx, volumeID, nodeID)
	if err != nil {
		t.Fatalf("TrackAttachment failed: %v", err)
	}

	// Verify attachment exists
	_, exists := am.GetAttachment(volumeID)
	if !exists {
		t.Fatal("Expected attachment to exist before reconciliation")
	}

	// Create reconciler with very short grace period (already expired)
	r, err := NewAttachmentReconciler(ReconcilerConfig{
		Manager:     am,
		K8sClient:   k8sClient,
		Interval:    100 * time.Millisecond,
		GracePeriod: 1 * time.Nanosecond, // Effectively expired immediately
	})
	if err != nil {
		t.Fatalf("Failed to create reconciler: %v", err)
	}

	// Run a single reconciliation
	r.reconcile(ctx)

	// Verify attachment was cleared
	_, exists = am.GetAttachment(volumeID)
	if exists {
		t.Error("Expected stale attachment to be cleared after reconciliation")
	}
}

func TestReconciler_PreservesValidAttachment_NodeExists(t *testing.T) {
	// Create fake k8s client with a node
	existingNode := &corev1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name: "existing-node",
		},
	}
	k8sClient := fake.NewSimpleClientset(existingNode)

	// Create attachment manager and track a volume
	am := NewAttachmentManager(nil)
	ctx := context.Background()
	volumeID := "pvc-test-valid"
	nodeID := "existing-node"

	err := am.TrackAttachment(ctx, volumeID, nodeID)
	if err != nil {
		t.Fatalf("TrackAttachment failed: %v", err)
	}

	// Create reconciler
	r, err := NewAttachmentReconciler(ReconcilerConfig{
		Manager:     am,
		K8sClient:   k8sClient,
		Interval:    100 * time.Millisecond,
		GracePeriod: 1 * time.Nanosecond,
	})
	if err != nil {
		t.Fatalf("Failed to create reconciler: %v", err)
	}

	// Run reconciliation
	r.reconcile(ctx)

	// Verify attachment still exists (node exists, so attachment is valid)
	_, exists := am.GetAttachment(volumeID)
	if !exists {
		t.Error("Expected valid attachment to be preserved after reconciliation")
	}
}

func TestReconciler_RespectsGracePeriod(t *testing.T) {
	// Create fake k8s client with NO nodes
	k8sClient := fake.NewSimpleClientset()

	// Create attachment manager
	am := NewAttachmentManager(nil)
	ctx := context.Background()
	volumeID := "pvc-test-grace"
	nodeID := "deleted-node"

	// Track and then untrack to create a recent detach timestamp
	err := am.TrackAttachment(ctx, volumeID, nodeID)
	if err != nil {
		t.Fatalf("TrackAttachment failed: %v", err)
	}
	err = am.UntrackAttachment(ctx, volumeID)
	if err != nil {
		t.Fatalf("UntrackAttachment failed: %v", err)
	}

	// Re-track (simulating the state when reconciler runs)
	err = am.TrackAttachment(ctx, volumeID, nodeID)
	if err != nil {
		t.Fatalf("Re-track failed: %v", err)
	}

	// Create reconciler with long grace period
	r, err := NewAttachmentReconciler(ReconcilerConfig{
		Manager:     am,
		K8sClient:   k8sClient,
		Interval:    100 * time.Millisecond,
		GracePeriod: 1 * time.Hour, // Very long grace period
	})
	if err != nil {
		t.Fatalf("Failed to create reconciler: %v", err)
	}

	// Run reconciliation
	r.reconcile(ctx)

	// Attachment should still exist because we're within grace period
	// (detach timestamp was set just before)
	_, exists := am.GetAttachment(volumeID)
	if !exists {
		t.Error("Expected attachment to be preserved during grace period")
	}
}

func TestReconciler_HandlesAPIErrors(t *testing.T) {
	// Create fake k8s client that returns errors
	k8sClient := fake.NewSimpleClientset()
	k8sClient.PrependReactor("get", "nodes", func(action k8stesting.Action) (bool, runtime.Object, error) {
		return true, nil, &k8stesting.UnexpectedActionError{Action: action}
	})

	// Create attachment manager and track a volume
	am := NewAttachmentManager(nil)
	ctx := context.Background()
	volumeID := "pvc-test-api-error"
	nodeID := "some-node"

	err := am.TrackAttachment(ctx, volumeID, nodeID)
	if err != nil {
		t.Fatalf("TrackAttachment failed: %v", err)
	}

	// Create reconciler
	r, err := NewAttachmentReconciler(ReconcilerConfig{
		Manager:     am,
		K8sClient:   k8sClient,
		Interval:    100 * time.Millisecond,
		GracePeriod: 1 * time.Nanosecond,
	})
	if err != nil {
		t.Fatalf("Failed to create reconciler: %v", err)
	}

	// Run reconciliation (should not panic, should skip on API error)
	r.reconcile(ctx)

	// Attachment should still exist (fail-open on API errors)
	_, exists := am.GetAttachment(volumeID)
	if !exists {
		t.Error("Expected attachment to be preserved on API error (fail-open)")
	}
}

func TestReconciler_GetGracePeriod(t *testing.T) {
	am := NewAttachmentManager(nil)
	k8sClient := fake.NewSimpleClientset()

	gracePeriod := 45 * time.Second
	r, err := NewAttachmentReconciler(ReconcilerConfig{
		Manager:     am,
		K8sClient:   k8sClient,
		GracePeriod: gracePeriod,
	})
	if err != nil {
		t.Fatalf("Failed to create reconciler: %v", err)
	}

	if r.GetGracePeriod() != gracePeriod {
		t.Errorf("Expected grace period %v, got %v", gracePeriod, r.GetGracePeriod())
	}
}
```
  </action>
  <verify>
go test ./pkg/attachment/... -v -run "TestReconciler|TestNewAttachmentReconciler"
  </verify>
  <done>
All reconciler tests pass: TestNewAttachmentReconciler_RequiresManager, TestNewAttachmentReconciler_RequiresK8sClient, TestNewAttachmentReconciler_DefaultValues, TestReconciler_StartStop, TestReconciler_ContextCancellation, TestReconciler_ClearsStaleAttachment_NodeDeleted, TestReconciler_PreservesValidAttachment_NodeExists, TestReconciler_RespectsGracePeriod, TestReconciler_HandlesAPIErrors, TestReconciler_GetGracePeriod.
  </done>
</task>

</tasks>

<verification>
# Run all attachment package tests
go test ./pkg/attachment/... -v

# Run with coverage
go test ./pkg/attachment/... -cover

# Verify no race conditions
go test ./pkg/attachment/... -race

# Run full test suite
make test
</verification>

<success_criteria>
1. All grace period tests pass (IsWithinGracePeriod, GetDetachTimestamp, ClearDetachTimestamp, LiveMigrationScenario)
2. All reconciler tests pass (creation, start/stop, context cancellation, stale clearing, grace period respect, API error handling)
3. Tests verify fail-open behavior on API errors
4. Tests verify live migration handoff scenario works correctly
5. No race conditions detected
6. Test coverage for new functionality is adequate
</success_criteria>

<output>
After completion, create `.planning/phases/07-robustness-observability/07-03-SUMMARY.md`
</output>
