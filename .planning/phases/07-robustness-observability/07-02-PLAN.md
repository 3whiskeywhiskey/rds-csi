---
phase: 07-robustness-observability
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - pkg/attachment/reconciler.go
  - pkg/driver/driver.go
  - pkg/driver/controller.go
autonomous: true

must_haves:
  truths:
    - "Background reconciler detects attachments to deleted nodes and clears them"
    - "Reconciler runs on configurable interval with graceful shutdown via context"
    - "Grace period is checked before rejecting RWO conflicts in ControllerPublishVolume"
    - "Driver starts attachment reconciler during Run() with configurable settings"
  artifacts:
    - path: "pkg/attachment/reconciler.go"
      provides: "AttachmentReconciler with Start, Stop, and reconcile methods"
      exports: ["AttachmentReconciler", "NewAttachmentReconciler"]
    - path: "pkg/driver/driver.go"
      provides: "Attachment reconciler integration and configuration"
      contains: "attachmentReconciler"
    - path: "pkg/driver/controller.go"
      provides: "Grace period integration in ControllerPublishVolume"
      contains: "IsWithinGracePeriod"
  key_links:
    - from: "pkg/attachment/reconciler.go"
      to: "pkg/attachment/manager.go"
      via: "AttachmentManager.ListAttachments and UntrackAttachment"
      pattern: "manager\\.ListAttachments"
    - from: "pkg/driver/driver.go"
      to: "pkg/attachment/reconciler.go"
      via: "AttachmentReconciler started in Run"
      pattern: "attachmentReconciler\\.Start"
    - from: "pkg/driver/controller.go"
      to: "pkg/attachment/manager.go"
      via: "IsWithinGracePeriod check before conflict"
      pattern: "IsWithinGracePeriod"
---

<objective>
Implement background attachment reconciler and integrate grace period logic into ControllerPublishVolume.

Purpose: Clean stale attachments from deleted nodes automatically and allow live migration handoff via grace period.
Output: AttachmentReconciler that runs periodically, clears stale attachments, and driver integration with grace period enforcement.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.3-ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-robustness-observability/07-CONTEXT.md
@.planning/phases/07-robustness-observability/07-RESEARCH.md
@.planning/phases/07-robustness-observability/07-01-SUMMARY.md
@pkg/attachment/manager.go
@pkg/driver/driver.go
@pkg/driver/controller.go
@pkg/observability/prometheus.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AttachmentReconciler</name>
  <files>pkg/attachment/reconciler.go</files>
  <action>
Create new file pkg/attachment/reconciler.go:

```go
// Package attachment provides thread-safe tracking of volume-to-node attachments
// for the RDS CSI driver.
package attachment

import (
	"context"
	"fmt"
	"sync"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/klog/v2"

	"git.srvlab.io/whiskey/rds-csi-driver/pkg/observability"
)

// AttachmentReconciler periodically checks for stale attachments and cleans them up.
// Stale attachments occur when a node is deleted without proper cleanup of attached volumes.
type AttachmentReconciler struct {
	manager     *AttachmentManager
	k8sClient   kubernetes.Interface
	interval    time.Duration
	gracePeriod time.Duration
	metrics     *observability.Metrics

	// Control channels
	stopCh chan struct{}
	doneCh chan struct{}
	mu     sync.Mutex
}

// ReconcilerConfig holds configuration for the AttachmentReconciler.
type ReconcilerConfig struct {
	Manager     *AttachmentManager
	K8sClient   kubernetes.Interface
	Interval    time.Duration // Default: 5 minutes
	GracePeriod time.Duration // Default: 30 seconds
	Metrics     *observability.Metrics
}

// NewAttachmentReconciler creates a new AttachmentReconciler.
func NewAttachmentReconciler(config ReconcilerConfig) (*AttachmentReconciler, error) {
	if config.Manager == nil {
		return nil, fmt.Errorf("manager is required")
	}
	if config.K8sClient == nil {
		return nil, fmt.Errorf("k8sClient is required")
	}
	if config.Interval <= 0 {
		config.Interval = 5 * time.Minute
	}
	if config.GracePeriod <= 0 {
		config.GracePeriod = 30 * time.Second
	}

	return &AttachmentReconciler{
		manager:     config.Manager,
		k8sClient:   config.K8sClient,
		interval:    config.Interval,
		gracePeriod: config.GracePeriod,
		metrics:     config.Metrics,
	}, nil
}

// Start begins the background reconciliation loop.
// Returns immediately; reconciliation runs in a separate goroutine.
// Call Stop() to gracefully shut down.
func (r *AttachmentReconciler) Start(ctx context.Context) error {
	r.mu.Lock()
	if r.stopCh != nil {
		r.mu.Unlock()
		return fmt.Errorf("reconciler already running")
	}
	r.stopCh = make(chan struct{})
	r.doneCh = make(chan struct{})
	r.mu.Unlock()

	klog.Infof("Starting attachment reconciler (interval=%v, grace_period=%v)", r.interval, r.gracePeriod)

	go r.run(ctx)

	return nil
}

// Stop gracefully stops the reconciliation loop.
// Blocks until the reconciler has fully stopped.
func (r *AttachmentReconciler) Stop() {
	r.mu.Lock()
	if r.stopCh == nil {
		r.mu.Unlock()
		return
	}
	close(r.stopCh)
	doneCh := r.doneCh
	r.mu.Unlock()

	// Wait for run() to exit
	<-doneCh

	klog.Info("Attachment reconciler stopped")
}

// run is the main reconciliation loop.
func (r *AttachmentReconciler) run(ctx context.Context) {
	defer close(r.doneCh)

	ticker := time.NewTicker(r.interval)
	defer ticker.Stop()

	// Run initial reconciliation immediately
	r.reconcile(ctx)

	for {
		select {
		case <-ticker.C:
			r.reconcile(ctx)
		case <-r.stopCh:
			klog.V(2).Info("Attachment reconciler shutting down")
			return
		case <-ctx.Done():
			klog.V(2).Info("Attachment reconciler context cancelled")
			return
		}
	}
}

// reconcile performs a single reconciliation pass.
func (r *AttachmentReconciler) reconcile(ctx context.Context) {
	startTime := time.Now()
	klog.V(3).Info("Starting attachment reconciliation")

	// Get all current attachments
	attachments := r.manager.ListAttachments()

	clearedCount := 0
	for volumeID, state := range attachments {
		// Check if context is cancelled
		if ctx.Err() != nil {
			klog.V(2).Info("Reconciliation interrupted by context cancellation")
			return
		}

		// Check if node still exists
		nodeExists, err := r.nodeExists(ctx, state.NodeID)
		if err != nil {
			// API error - fail open (don't clear on transient errors)
			klog.Warningf("Failed to check node %s for volume %s: %v (skipping)", state.NodeID, volumeID, err)
			continue
		}

		if nodeExists {
			// Node exists, attachment is valid
			continue
		}

		// Node deleted - check if within grace period
		detachTime := r.manager.GetDetachTimestamp(volumeID)
		if !detachTime.IsZero() && time.Since(detachTime) < r.gracePeriod {
			klog.V(3).Infof("Node %s deleted but within grace period for volume %s", state.NodeID, volumeID)
			continue
		}

		// Clear stale attachment
		klog.Infof("Clearing stale attachment: volume=%s node=%s (node deleted)", volumeID, state.NodeID)
		if err := r.manager.UntrackAttachment(ctx, volumeID); err != nil {
			klog.Errorf("Failed to clear stale attachment for volume %s: %v", volumeID, err)
			continue
		}

		clearedCount++

		// Record metrics
		if r.metrics != nil {
			r.metrics.RecordStaleAttachmentCleared()
			r.metrics.RecordReconcileAction("clear_stale")
		}
	}

	duration := time.Since(startTime)

	// Record reconcile duration
	if r.metrics != nil {
		r.metrics.RecordAttachmentOp("reconcile", nil, duration)
	}

	if clearedCount > 0 {
		klog.Infof("Attachment reconciliation complete: cleared %d stale attachments (duration=%v)", clearedCount, duration)
	} else {
		klog.V(3).Infof("Attachment reconciliation complete: no stale attachments (duration=%v)", duration)
	}
}

// nodeExists checks if a Kubernetes node exists.
func (r *AttachmentReconciler) nodeExists(ctx context.Context, nodeID string) (bool, error) {
	_, err := r.k8sClient.CoreV1().Nodes().Get(ctx, nodeID, metav1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

// GetGracePeriod returns the configured grace period duration.
func (r *AttachmentReconciler) GetGracePeriod() time.Duration {
	return r.gracePeriod
}
```
  </action>
  <verify>
go build ./pkg/attachment/...
go vet ./pkg/attachment/...
  </verify>
  <done>
pkg/attachment/reconciler.go exists with AttachmentReconciler struct, NewAttachmentReconciler constructor, Start/Stop methods, reconcile logic that checks node existence and clears stale attachments, and metrics integration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate attachment reconciler and grace period into driver</name>
  <files>pkg/driver/driver.go</files>
  <action>
1. Add import for attachment package (already exists, just verify)

2. Add attachmentReconciler field to Driver struct (after attachmentManager):
   ```go
   // Attachment reconciler (for controller only)
   attachmentReconciler *attachment.AttachmentReconciler

   // Grace period for attachment handoff during live migration
   attachmentGracePeriod time.Duration
   ```

3. Add new fields to DriverConfig struct (after OrphanDryRun):
   ```go
   // Attachment reconciler settings
   EnableAttachmentReconciler  bool
   AttachmentReconcileInterval time.Duration // Default: 5 minutes
   AttachmentGracePeriod       time.Duration // Default: 30 seconds
   ```

4. In NewDriver, after attachment manager creation, initialize attachment reconciler:
   ```go
   // Initialize attachment reconciler if enabled
   if config.EnableController && config.EnableAttachmentReconciler && config.K8sClient != nil && driver.attachmentManager != nil {
       reconcilerConfig := attachment.ReconcilerConfig{
           Manager:     driver.attachmentManager,
           K8sClient:   config.K8sClient,
           Interval:    config.AttachmentReconcileInterval,
           GracePeriod: config.AttachmentGracePeriod,
           Metrics:     config.Metrics,
       }

       attachmentReconciler, err := attachment.NewAttachmentReconciler(reconcilerConfig)
       if err != nil {
           return nil, fmt.Errorf("failed to create attachment reconciler: %w", err)
       }

       driver.attachmentReconciler = attachmentReconciler
       driver.attachmentGracePeriod = config.AttachmentGracePeriod
       if driver.attachmentGracePeriod <= 0 {
           driver.attachmentGracePeriod = 30 * time.Second
       }
       klog.Infof("Attachment reconciler enabled (interval=%v, grace_period=%v)",
           config.AttachmentReconcileInterval, config.AttachmentGracePeriod)
   }
   ```

5. In Run() method, after attachment manager initialization and before orphan reconciler start:
   ```go
   // Start attachment reconciler if configured
   if d.attachmentReconciler != nil {
       ctx := context.Background()
       if err := d.attachmentReconciler.Start(ctx); err != nil {
           return fmt.Errorf("failed to start attachment reconciler: %w", err)
       }
       klog.Info("Attachment reconciler started")
   }
   ```

6. In Stop() method, before orphan reconciler stop:
   ```go
   // Stop attachment reconciler if running
   if d.attachmentReconciler != nil {
       d.attachmentReconciler.Stop()
       klog.Info("Attachment reconciler stopped")
   }
   ```

7. Add getter method for grace period:
   ```go
   // GetAttachmentGracePeriod returns the configured grace period for attachment handoff.
   func (d *Driver) GetAttachmentGracePeriod() time.Duration {
       return d.attachmentGracePeriod
   }
   ```
  </action>
  <verify>
go build ./pkg/driver/...
go vet ./pkg/driver/...
  </verify>
  <done>
Driver struct has attachmentReconciler and attachmentGracePeriod fields. DriverConfig has EnableAttachmentReconciler, AttachmentReconcileInterval, and AttachmentGracePeriod fields. NewDriver creates attachment reconciler when enabled. Run() starts reconciler. Stop() stops reconciler. GetAttachmentGracePeriod() method exists.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate grace period check into ControllerPublishVolume</name>
  <files>pkg/driver/controller.go</files>
  <action>
1. In ControllerPublishVolume, after checking that volume is attached to a different node (before node existence validation), add grace period check:

Find the section that handles different node attachment (around line 459 where existing.NodeID != nodeID):
```go
if existing.NodeID == nodeID {
    // ... idempotent case
}

// Different node - check grace period FIRST
gracePeriod := cs.driver.GetAttachmentGracePeriod()
if gracePeriod > 0 && am.IsWithinGracePeriod(volumeID, gracePeriod) {
    klog.V(2).Infof("Volume %s within grace period, allowing attachment handoff from %s to %s",
        volumeID, existing.NodeID, nodeID)

    // Record grace period usage metric
    if cs.driver.metrics != nil {
        cs.driver.metrics.RecordGracePeriodUsed()
    }

    // Clear the old attachment and detach timestamp before new attach
    if err := am.UntrackAttachment(ctx, volumeID); err != nil {
        klog.Warningf("Failed to clear old attachment for volume %s during grace period handoff: %v", volumeID, err)
    }
    am.ClearDetachTimestamp(volumeID)
    // Fall through to track new attachment
} else {
    // CSI-06: Before rejecting, verify blocking node still exists
    // ... existing node validation code
}
```

2. The structure should be:
   - Check if same node (idempotent - return success)
   - Check if within grace period (allow handoff - clear old, track new)
   - Check if blocking node still exists (auto-clear if deleted)
   - If blocking node exists, reject with FAILED_PRECONDITION

3. Update the code flow so that after grace period allows handoff, it falls through to the attachment tracking section rather than returning early.

4. Make sure to add metric recording for successful attach operations:
After `am.TrackAttachment(ctx, volumeID, nodeID)` succeeds:
```go
// Record attachment success metric
if cs.driver.metrics != nil {
    cs.driver.metrics.RecordAttachmentOp("attach", nil, time.Since(startTime))
}
```
Note: You'll need to capture startTime at the beginning of the function:
```go
startTime := time.Now()
```

5. In ControllerUnpublishVolume, add metric recording:
After successful untrack:
```go
// Record detachment metric
if cs.driver.metrics != nil {
    cs.driver.metrics.RecordAttachmentOp("detach", nil, time.Since(startTime))
}
```
  </action>
  <verify>
go build ./pkg/driver/...
go vet ./pkg/driver/...
  </verify>
  <done>
ControllerPublishVolume checks grace period before rejecting RWO conflicts, allowing live migration handoff. Records attachment metrics. ControllerUnpublishVolume records detachment metrics. Grace period logic integrated with AttachmentManager.IsWithinGracePeriod.
  </done>
</task>

</tasks>

<verification>
# Build all modified packages
go build ./pkg/attachment/... ./pkg/driver/...

# Run vet
go vet ./pkg/attachment/... ./pkg/driver/...

# Run existing tests
go test ./pkg/attachment/... ./pkg/driver/... -v

# Verify the full build
make build-local
</verification>

<success_criteria>
1. pkg/attachment/reconciler.go exists with AttachmentReconciler implementation
2. AttachmentReconciler has Start/Stop methods with context-based shutdown
3. Reconciler detects deleted nodes and clears stale attachments after grace period
4. Driver has attachment reconciler configuration and startup/shutdown integration
5. ControllerPublishVolume checks grace period before rejecting RWO conflicts
6. Metrics are recorded for attachment operations and reconciliation actions
7. All packages build and pass vet checks
8. Existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-robustness-observability/07-02-SUMMARY.md`
</output>
