---
phase: 09-migration-safety
plan: 04
type: execute
wave: 3
depends_on: ["09-01", "09-02", "09-03"]
files_modified:
  - pkg/attachment/types_test.go
  - pkg/attachment/manager_test.go
  - pkg/driver/params_test.go
  - pkg/nvme/device_test.go
  - pkg/driver/controller_test.go
autonomous: true

must_haves:
  truths:
    - "AttachmentState migration helper methods tested (IsMigrating, IsMigrationTimedOut)"
    - "ParseMigrationTimeout tested with valid, invalid, edge case inputs"
    - "AddSecondaryAttachment migration tracking tested"
    - "CheckDeviceInUse tested with mock lsof output"
    - "ControllerPublishVolume migration timeout rejection tested"
  artifacts:
    - path: "pkg/attachment/types_test.go"
      provides: "Tests for IsMigrating, IsMigrationTimedOut"
      contains: "TestIsMigrating"
    - path: "pkg/driver/params_test.go"
      provides: "Tests for ParseMigrationTimeout"
      contains: "TestParseMigrationTimeout"
    - path: "pkg/nvme/device_test.go"
      provides: "Tests for CheckDeviceInUse"
      contains: "TestCheckDeviceInUse"
  key_links:
    - from: "pkg/driver/controller_test.go"
      to: "pkg/driver/controller.go"
      via: "Tests for migration timeout in ControllerPublishVolume"
      pattern: "Migration.*Timeout"
---

<objective>
Comprehensive unit tests for Phase 9 migration safety features

Purpose: Verify all SAFETY requirements through automated tests covering normal, edge, and error cases
Output: Test coverage for migration tracking, timeout parsing, device-in-use detection, and controller logic
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.5-ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-migration-safety/09-01-PLAN.md
@.planning/phases/09-migration-safety/09-02-PLAN.md
@.planning/phases/09-migration-safety/09-03-PLAN.md

# Existing test patterns
@pkg/attachment/manager_test.go
@pkg/driver/controller_test.go
@pkg/driver/params_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tests for AttachmentState migration helper methods</name>
  <files>pkg/attachment/types_test.go</files>
  <action>
Create or update pkg/attachment/types_test.go with tests for the new helper methods:

```go
package attachment

import (
    "testing"
    "time"
)

func TestIsMigrating(t *testing.T) {
    tests := []struct {
        name     string
        state    *AttachmentState
        expected bool
    }{
        {
            name: "not migrating - no migration timestamp",
            state: &AttachmentState{
                Nodes: []NodeAttachment{{NodeID: "node-1"}},
            },
            expected: false,
        },
        {
            name: "not migrating - single node with timestamp",
            state: &AttachmentState{
                Nodes:              []NodeAttachment{{NodeID: "node-1"}},
                MigrationStartedAt: timePtr(time.Now()),
            },
            expected: false, // Need 2 nodes to be migrating
        },
        {
            name: "migrating - two nodes with timestamp",
            state: &AttachmentState{
                Nodes: []NodeAttachment{
                    {NodeID: "node-1"},
                    {NodeID: "node-2"},
                },
                MigrationStartedAt: timePtr(time.Now()),
            },
            expected: true,
        },
        {
            name: "not migrating - two nodes but no timestamp",
            state: &AttachmentState{
                Nodes: []NodeAttachment{
                    {NodeID: "node-1"},
                    {NodeID: "node-2"},
                },
            },
            expected: false,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := tt.state.IsMigrating()
            if result != tt.expected {
                t.Errorf("IsMigrating() = %v, want %v", result, tt.expected)
            }
        })
    }
}

func TestIsMigrationTimedOut(t *testing.T) {
    tests := []struct {
        name     string
        state    *AttachmentState
        expected bool
    }{
        {
            name: "not timed out - no migration",
            state: &AttachmentState{
                MigrationStartedAt: nil,
                MigrationTimeout:   5 * time.Minute,
            },
            expected: false,
        },
        {
            name: "not timed out - zero timeout (disabled)",
            state: &AttachmentState{
                MigrationStartedAt: timePtr(time.Now().Add(-10 * time.Minute)),
                MigrationTimeout:   0,
            },
            expected: false,
        },
        {
            name: "not timed out - within timeout",
            state: &AttachmentState{
                MigrationStartedAt: timePtr(time.Now().Add(-1 * time.Minute)),
                MigrationTimeout:   5 * time.Minute,
            },
            expected: false,
        },
        {
            name: "timed out - exceeded timeout",
            state: &AttachmentState{
                MigrationStartedAt: timePtr(time.Now().Add(-10 * time.Minute)),
                MigrationTimeout:   5 * time.Minute,
            },
            expected: true,
        },
        {
            name: "timed out - exactly at boundary",
            state: &AttachmentState{
                MigrationStartedAt: timePtr(time.Now().Add(-5*time.Minute - 1*time.Second)),
                MigrationTimeout:   5 * time.Minute,
            },
            expected: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := tt.state.IsMigrationTimedOut()
            if result != tt.expected {
                t.Errorf("IsMigrationTimedOut() = %v, want %v", result, tt.expected)
            }
        })
    }
}

// Helper to create time pointer
func timePtr(t time.Time) *time.Time {
    return &t
}
```
  </action>
  <verify>go test ./pkg/attachment/... -run "TestIsMigrat" -v passes</verify>
  <done>Tests for IsMigrating() and IsMigrationTimedOut() helper methods pass</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for ParseMigrationTimeout</name>
  <files>pkg/driver/params_test.go</files>
  <action>
Add tests for ParseMigrationTimeout to the existing params_test.go:

```go
func TestParseMigrationTimeout(t *testing.T) {
    tests := []struct {
        name           string
        params         map[string]string
        expectedMin    time.Duration
        expectedMax    time.Duration
        expectDefault  bool
    }{
        {
            name:          "not specified - returns default",
            params:        map[string]string{},
            expectedMin:   DefaultMigrationTimeout,
            expectedMax:   DefaultMigrationTimeout,
            expectDefault: true,
        },
        {
            name:          "empty string - returns default",
            params:        map[string]string{"migrationTimeoutSeconds": ""},
            expectedMin:   DefaultMigrationTimeout,
            expectedMax:   DefaultMigrationTimeout,
            expectDefault: true,
        },
        {
            name:        "valid value - 300 seconds",
            params:      map[string]string{"migrationTimeoutSeconds": "300"},
            expectedMin: 300 * time.Second,
            expectedMax: 300 * time.Second,
        },
        {
            name:        "valid value - 600 seconds",
            params:      map[string]string{"migrationTimeoutSeconds": "600"},
            expectedMin: 600 * time.Second,
            expectedMax: 600 * time.Second,
        },
        {
            name:          "invalid - not a number",
            params:        map[string]string{"migrationTimeoutSeconds": "abc"},
            expectedMin:   DefaultMigrationTimeout,
            expectedMax:   DefaultMigrationTimeout,
            expectDefault: true,
        },
        {
            name:          "invalid - negative",
            params:        map[string]string{"migrationTimeoutSeconds": "-300"},
            expectedMin:   DefaultMigrationTimeout,
            expectedMax:   DefaultMigrationTimeout,
            expectDefault: true,
        },
        {
            name:          "invalid - zero",
            params:        map[string]string{"migrationTimeoutSeconds": "0"},
            expectedMin:   DefaultMigrationTimeout,
            expectedMax:   DefaultMigrationTimeout,
            expectDefault: true,
        },
        {
            name:        "clamped - too short (10s -> 30s min)",
            params:      map[string]string{"migrationTimeoutSeconds": "10"},
            expectedMin: MinMigrationTimeout,
            expectedMax: MinMigrationTimeout,
        },
        {
            name:        "clamped - too long (7200s -> 3600s max)",
            params:      map[string]string{"migrationTimeoutSeconds": "7200"},
            expectedMin: MaxMigrationTimeout,
            expectedMax: MaxMigrationTimeout,
        },
        {
            name:        "boundary - exactly min (30s)",
            params:      map[string]string{"migrationTimeoutSeconds": "30"},
            expectedMin: 30 * time.Second,
            expectedMax: 30 * time.Second,
        },
        {
            name:        "boundary - exactly max (3600s)",
            params:      map[string]string{"migrationTimeoutSeconds": "3600"},
            expectedMin: 3600 * time.Second,
            expectedMax: 3600 * time.Second,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := ParseMigrationTimeout(tt.params)

            if result < tt.expectedMin || result > tt.expectedMax {
                t.Errorf("ParseMigrationTimeout() = %v, want between %v and %v",
                    result, tt.expectedMin, tt.expectedMax)
            }

            if tt.expectDefault && result != DefaultMigrationTimeout {
                t.Errorf("ParseMigrationTimeout() = %v, want default %v",
                    result, DefaultMigrationTimeout)
            }
        })
    }
}
```
  </action>
  <verify>go test ./pkg/driver/... -run "TestParseMigrationTimeout" -v passes</verify>
  <done>Tests for ParseMigrationTimeout cover valid, invalid, and edge cases</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for AddSecondaryAttachment migration tracking</name>
  <files>pkg/attachment/manager_test.go</files>
  <action>
Add tests for migration tracking in AddSecondaryAttachment:

```go
func TestAddSecondaryAttachment_MigrationTracking(t *testing.T) {
    ctx := context.Background()
    am := NewAttachmentManager(nil)

    // Setup: create primary attachment
    volumeID := "pvc-test-migration"
    primaryNode := "node-primary"
    secondaryNode := "node-secondary"
    migrationTimeout := 5 * time.Minute

    err := am.TrackAttachmentWithMode(ctx, volumeID, primaryNode, "RWX")
    if err != nil {
        t.Fatalf("Failed to track primary attachment: %v", err)
    }

    // Verify no migration state initially
    state, _ := am.GetAttachment(volumeID)
    if state.MigrationStartedAt != nil {
        t.Error("MigrationStartedAt should be nil before secondary attachment")
    }

    // Add secondary attachment
    beforeAdd := time.Now()
    err = am.AddSecondaryAttachment(ctx, volumeID, secondaryNode, migrationTimeout)
    if err != nil {
        t.Fatalf("Failed to add secondary attachment: %v", err)
    }
    afterAdd := time.Now()

    // Verify migration tracking
    state, _ = am.GetAttachment(volumeID)

    if state.MigrationStartedAt == nil {
        t.Fatal("MigrationStartedAt should be set after secondary attachment")
    }

    if state.MigrationStartedAt.Before(beforeAdd) || state.MigrationStartedAt.After(afterAdd) {
        t.Errorf("MigrationStartedAt %v not in expected range [%v, %v]",
            state.MigrationStartedAt, beforeAdd, afterAdd)
    }

    if state.MigrationTimeout != migrationTimeout {
        t.Errorf("MigrationTimeout = %v, want %v", state.MigrationTimeout, migrationTimeout)
    }

    // Verify IsMigrating returns true
    if !state.IsMigrating() {
        t.Error("IsMigrating() should return true after secondary attachment")
    }
}

func TestRemoveNodeAttachment_ClearsMigrationState(t *testing.T) {
    ctx := context.Background()
    am := NewAttachmentManager(nil)

    // Setup: create dual-attach migration scenario
    volumeID := "pvc-test-clear-migration"
    primaryNode := "node-primary"
    secondaryNode := "node-secondary"

    err := am.TrackAttachmentWithMode(ctx, volumeID, primaryNode, "RWX")
    if err != nil {
        t.Fatalf("Failed to track primary attachment: %v", err)
    }

    err = am.AddSecondaryAttachment(ctx, volumeID, secondaryNode, 5*time.Minute)
    if err != nil {
        t.Fatalf("Failed to add secondary attachment: %v", err)
    }

    // Verify migration is active
    state, _ := am.GetAttachment(volumeID)
    if !state.IsMigrating() {
        t.Fatal("Should be migrating after secondary attachment")
    }

    // Remove primary node (migration source) - simulates migration completion
    fullyDetached, err := am.RemoveNodeAttachment(ctx, volumeID, primaryNode)
    if err != nil {
        t.Fatalf("Failed to remove primary attachment: %v", err)
    }

    if fullyDetached {
        t.Error("Should not be fully detached - secondary still attached")
    }

    // Verify migration state cleared
    state, exists := am.GetAttachment(volumeID)
    if !exists {
        t.Fatal("Volume should still be tracked")
    }

    if state.MigrationStartedAt != nil {
        t.Error("MigrationStartedAt should be nil after migration completes")
    }

    if state.MigrationTimeout != 0 {
        t.Error("MigrationTimeout should be 0 after migration completes")
    }

    if state.IsMigrating() {
        t.Error("IsMigrating() should return false after migration completes")
    }

    // Verify secondary node is now the only attached node
    if len(state.Nodes) != 1 {
        t.Errorf("Should have 1 node, got %d", len(state.Nodes))
    }

    if state.Nodes[0].NodeID != secondaryNode {
        t.Errorf("Remaining node should be %s, got %s", secondaryNode, state.Nodes[0].NodeID)
    }
}
```
  </action>
  <verify>go test ./pkg/attachment/... -run "Migration" -v passes</verify>
  <done>Tests verify AddSecondaryAttachment sets migration state and RemoveNodeAttachment clears it</done>
</task>

<task type="auto">
  <name>Task 4: Add tests for CheckDeviceInUse</name>
  <files>pkg/nvme/device_test.go</files>
  <action>
Create pkg/nvme/device_test.go with tests for CheckDeviceInUse.

Note: These tests are limited since we can't easily mock lsof without significant infrastructure. Focus on testing the parsing logic and timeout behavior where possible:

```go
package nvme

import (
    "context"
    "testing"
    "time"
)

func TestCheckDeviceInUse_NonexistentDevice(t *testing.T) {
    // Test with a device that doesn't exist
    // lsof should return exit code 1 (no processes found)
    ctx := context.Background()
    result := CheckDeviceInUse(ctx, "/dev/nonexistent-device-xyz")

    // Should return not in use (lsof exits 1 for no matching files)
    // or an error if lsof itself fails
    if result.InUse {
        t.Errorf("Expected device not in use, got InUse=true with processes: %v", result.Processes)
    }
}

func TestCheckDeviceInUse_CanceledContext(t *testing.T) {
    // Test with already-canceled context
    ctx, cancel := context.WithCancel(context.Background())
    cancel() // Cancel immediately

    result := CheckDeviceInUse(ctx, "/dev/null")

    // Should handle cancellation gracefully
    // Result depends on timing - may timeout or get context error
    if result.InUse && len(result.Processes) > 0 {
        t.Logf("Context was canceled but lsof still ran (timing): processes=%v", result.Processes)
    }
}

func TestCheckDeviceInUse_DevNull(t *testing.T) {
    // /dev/null might have some processes using it, but test should complete
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    result := CheckDeviceInUse(ctx, "/dev/null")

    // Should complete without error (timeout or result)
    if result.TimedOut {
        t.Log("Check timed out - lsof took too long")
    } else if result.Error != nil {
        t.Logf("Check returned error: %v", result.Error)
    } else if result.InUse {
        t.Logf("Device /dev/null in use by: %v", result.Processes)
    } else {
        t.Log("Device /dev/null not in use")
    }
    // All outcomes are valid - test verifies function doesn't panic/hang
}

func TestDeviceUsageResult_Fields(t *testing.T) {
    // Test DeviceUsageResult struct usage
    tests := []struct {
        name   string
        result DeviceUsageResult
    }{
        {
            name:   "not in use",
            result: DeviceUsageResult{InUse: false},
        },
        {
            name: "in use with processes",
            result: DeviceUsageResult{
                InUse:     true,
                Processes: []string{"qemu[PID:1234]", "kubelet[PID:5678]"},
            },
        },
        {
            name: "timed out",
            result: DeviceUsageResult{
                InUse:    false,
                TimedOut: true,
            },
        },
        {
            name: "error",
            result: DeviceUsageResult{
                InUse: false,
                Error: fmt.Errorf("lsof not found"),
            },
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Verify struct is usable
            _ = tt.result.InUse
            _ = tt.result.Processes
            _ = tt.result.TimedOut
            _ = tt.result.Error
        })
    }
}
```

Add import for "fmt" in the test file.
  </action>
  <verify>go test ./pkg/nvme/... -run "TestCheckDeviceInUse" -v passes</verify>
  <done>Tests for CheckDeviceInUse verify function behavior without mocking lsof</done>
</task>

<task type="auto">
  <name>Task 5: Add controller tests for migration timeout enforcement</name>
  <files>pkg/driver/controller_test.go</files>
  <action>
Add tests for ControllerPublishVolume migration timeout enforcement:

```go
func TestControllerPublishVolume_MigrationTimeout(t *testing.T) {
    // Test that timed-out migrations reject new secondary attachments
    tests := []struct {
        name          string
        setupState    func(am *attachment.AttachmentManager)
        expectError   bool
        errorContains string
    }{
        {
            name: "allow secondary attachment - migration not started",
            setupState: func(am *attachment.AttachmentManager) {
                // Primary attachment exists, no migration yet
                am.TrackAttachmentWithMode(context.Background(), "pvc-test", "node-1", "RWX")
            },
            expectError: false,
        },
        {
            name: "allow secondary attachment - migration within timeout",
            setupState: func(am *attachment.AttachmentManager) {
                am.TrackAttachmentWithMode(context.Background(), "pvc-test", "node-1", "RWX")
                // Simulate recent migration start (1 minute ago)
                state, _ := am.GetAttachment("pvc-test")
                recentTime := time.Now().Add(-1 * time.Minute)
                state.MigrationStartedAt = &recentTime
                state.MigrationTimeout = 5 * time.Minute
            },
            expectError: false,
        },
        {
            name: "reject secondary attachment - migration timed out",
            setupState: func(am *attachment.AttachmentManager) {
                am.TrackAttachmentWithMode(context.Background(), "pvc-test", "node-1", "RWX")
                // Simulate old migration start (10 minutes ago)
                state, _ := am.GetAttachment("pvc-test")
                oldTime := time.Now().Add(-10 * time.Minute)
                state.MigrationStartedAt = &oldTime
                state.MigrationTimeout = 5 * time.Minute
            },
            expectError:   true,
            errorContains: "migration timeout exceeded",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup driver with attachment manager
            am := attachment.NewAttachmentManager(nil)
            tt.setupState(am)

            // Create controller server with mock RDS client
            driver := &Driver{
                attachmentManager: am,
                rdsClient:         newMockRDSClient(), // Use existing mock from test file
            }
            cs := NewControllerServer(driver)

            // Try to publish to a different node
            req := &csi.ControllerPublishVolumeRequest{
                VolumeId: "pvc-test",
                NodeId:   "node-2", // Different from node-1
                VolumeCapability: &csi.VolumeCapability{
                    AccessMode: &csi.VolumeCapability_AccessMode{
                        Mode: csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER,
                    },
                    AccessType: &csi.VolumeCapability_Block{
                        Block: &csi.VolumeCapability_BlockVolume{},
                    },
                },
                VolumeContext: map[string]string{
                    "migrationTimeoutSeconds": "300",
                },
            }

            _, err := cs.ControllerPublishVolume(context.Background(), req)

            if tt.expectError {
                if err == nil {
                    t.Error("Expected error but got nil")
                } else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
                    t.Errorf("Error %q does not contain %q", err.Error(), tt.errorContains)
                }
            } else {
                if err != nil {
                    t.Errorf("Unexpected error: %v", err)
                }
            }
        })
    }
}
```

Integrate with existing test infrastructure in controller_test.go. May need to adjust based on existing mock patterns.
  </action>
  <verify>go test ./pkg/driver/... -run "MigrationTimeout" -v passes</verify>
  <done>Controller tests verify migration timeout enforcement in ControllerPublishVolume</done>
</task>

</tasks>

<verification>
1. `go test ./pkg/attachment/... -v` - all attachment tests pass
2. `go test ./pkg/driver/... -v` - all driver tests pass
3. `go test ./pkg/nvme/... -v` - all nvme tests pass
4. `make test` - full test suite passes
5. Test coverage: `go test -cover ./...` shows coverage for new code
</verification>

<success_criteria>
- TestIsMigrating and TestIsMigrationTimedOut pass in types_test.go
- TestParseMigrationTimeout covers all cases (valid, invalid, edge) in params_test.go
- TestAddSecondaryAttachment_MigrationTracking verifies migration state set
- TestRemoveNodeAttachment_ClearsMigrationState verifies migration cleanup
- TestCheckDeviceInUse verifies function behavior in device_test.go
- TestControllerPublishVolume_MigrationTimeout verifies timeout enforcement
- All tests pass: `make test`
</success_criteria>

<output>
After completion, create `.planning/phases/09-migration-safety/09-04-SUMMARY.md`
</output>
