---
phase: 09-migration-safety
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - pkg/driver/node.go
  - pkg/nvme/device.go
autonomous: true

must_haves:
  truths:
    - "NodeUnstageVolume checks for open file descriptors before NVMe disconnect"
    - "Device-in-use check uses lsof with timeout (5s) to prevent hanging"
    - "Busy device returns FAILED_PRECONDITION with list of blocking processes"
    - "Timeout on device check proceeds with disconnect (device likely unresponsive)"
  artifacts:
    - path: "pkg/nvme/device.go"
      provides: "CheckDeviceInUse function using lsof"
      contains: "CheckDeviceInUse"
    - path: "pkg/driver/node.go"
      provides: "Device-in-use check in NodeUnstageVolume"
      contains: "CheckDeviceInUse"
  key_links:
    - from: "pkg/driver/node.go"
      to: "pkg/nvme/device.go"
      via: "CheckDeviceInUse call in NodeUnstageVolume"
      pattern: "CheckDeviceInUse"
---

<objective>
Implement device-in-use verification in NodeUnstageVolume to prevent data corruption from premature NVMe disconnect

Purpose: SAFETY-04 - Verify no open file descriptors before NVMe disconnect to prevent data loss during forced pod termination
Output: NodeUnstageVolume checks lsof before disconnect, blocks if device busy, proceeds after timeout
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.5-ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-migration-safety/09-RESEARCH.md

# Key existing code
@pkg/driver/node.go
@pkg/nvme/nvme.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create device utility file with CheckDeviceInUse function</name>
  <files>pkg/nvme/device.go</files>
  <action>
Create a new file pkg/nvme/device.go with device-in-use detection:

```go
package nvme

import (
    "context"
    "fmt"
    "os/exec"
    "strings"
    "time"

    "k8s.io/klog/v2"
)

const (
    // DeviceCheckTimeout is the maximum time to wait for lsof to respond.
    // If exceeded, assume device is unresponsive and proceed with disconnect.
    DeviceCheckTimeout = 5 * time.Second
)

// DeviceUsageResult contains the result of a device-in-use check.
type DeviceUsageResult struct {
    // InUse is true if processes have the device open
    InUse bool
    // Processes is a list of "command[PID]" strings holding the device open
    Processes []string
    // TimedOut is true if the check timed out (device may be unresponsive)
    TimedOut bool
    // Error is set if the check failed for reasons other than timeout
    Error error
}

// CheckDeviceInUse checks if a device has open file descriptors using lsof.
// Returns InUse=true if processes are holding the device open.
// Returns TimedOut=true if lsof didn't respond within DeviceCheckTimeout (device may be unresponsive).
// Uses context for cancellation.
func CheckDeviceInUse(ctx context.Context, devicePath string) DeviceUsageResult {
    // Create timeout context
    checkCtx, cancel := context.WithTimeout(ctx, DeviceCheckTimeout)
    defer cancel()

    // Run lsof with timeout
    cmd := exec.CommandContext(checkCtx, "lsof", devicePath)
    out, err := cmd.Output()

    // Check for timeout
    if checkCtx.Err() == context.DeadlineExceeded {
        klog.Warningf("Device busy check timed out for %s after %v (device may be unresponsive)",
            devicePath, DeviceCheckTimeout)
        return DeviceUsageResult{
            InUse:    false, // Treat as not busy - device unresponsive, proceed with disconnect
            TimedOut: true,
        }
    }

    if err != nil {
        // lsof returns exit code 1 if no processes using device
        if exitErr, ok := err.(*exec.ExitError); ok && exitErr.ExitCode() == 1 {
            // No processes using device - this is the normal "not busy" case
            return DeviceUsageResult{InUse: false}
        }

        // Other error (lsof not found, permission denied, etc.)
        klog.Warningf("lsof command failed for %s: %v", devicePath, err)
        return DeviceUsageResult{
            InUse: false, // Can't determine - proceed with caution
            Error: fmt.Errorf("lsof failed: %w", err),
        }
    }

    // Parse lsof output
    // Format: COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
    lines := strings.Split(strings.TrimSpace(string(out)), "\n")
    if len(lines) <= 1 {
        // Only header line or empty - no processes
        return DeviceUsageResult{InUse: false}
    }

    // Extract process info from output (skip header line)
    processes := make([]string, 0, len(lines)-1)
    for _, line := range lines[1:] {
        fields := strings.Fields(line)
        if len(fields) >= 2 {
            // Format as "command[PID]" for readable error messages
            processes = append(processes, fmt.Sprintf("%s[PID:%s]", fields[0], fields[1]))
        }
    }

    if len(processes) > 0 {
        klog.V(2).Infof("Device %s in use by %d process(es): %v", devicePath, len(processes), processes)
        return DeviceUsageResult{
            InUse:     true,
            Processes: processes,
        }
    }

    return DeviceUsageResult{InUse: false}
}
```
  </action>
  <verify>go build ./pkg/nvme/... compiles successfully</verify>
  <done>pkg/nvme/device.go created with CheckDeviceInUse function using lsof with timeout</done>
</task>

<task type="auto">
  <name>Task 2: Add device-in-use check to NodeUnstageVolume</name>
  <files>pkg/driver/node.go</files>
  <action>
Update NodeUnstageVolume to check if device is in use before attempting NVMe disconnect.

Add import for the nvme package if not already present.

Between the unmount step and the NVMe disconnect step, add device-in-use verification:

```go
    // Step 1: Unmount from staging path
    if err := ns.mounter.Unmount(stagingPath); err != nil {
        // ... existing unmount error handling
    }

    klog.V(2).Infof("Unmounted volume %s from %s", volumeID, stagingPath)

    // SAFETY-04: Check device-in-use before NVMe disconnect
    // This prevents data corruption if processes still have the device open
    // (e.g., during forced pod termination or node failure scenarios)
    if nqn != "" {
        devicePath, devErr := ns.nvmeConn.GetDevicePath(nqn)
        if devErr == nil && devicePath != "" {
            result := nvme.CheckDeviceInUse(ctx, devicePath)

            if result.TimedOut {
                // Device check timed out - device may be unresponsive
                // Log warning and proceed with disconnect (device likely dead anyway)
                klog.Warningf("Device %s busy check timed out, proceeding with disconnect (device may be unresponsive)",
                    devicePath)
            } else if result.InUse {
                // Device has open file descriptors - unsafe to disconnect
                klog.Errorf("Device %s in use by processes: %v", devicePath, result.Processes)

                // Log failure
                secLogger.LogVolumeUnstage(volumeID, ns.nodeID, nqn, security.OutcomeFailure,
                    fmt.Errorf("device in use"), time.Since(startTime))

                return nil, status.Errorf(codes.FailedPrecondition,
                    "Device %s has open file descriptors, cannot safely unstage. "+
                    "Ensure pod using volume has terminated. Processes: %v",
                    devicePath, result.Processes)
            } else if result.Error != nil {
                // Check failed but not critical - log and proceed
                klog.Warningf("Device busy check failed for %s: %v (proceeding with disconnect)",
                    devicePath, result.Error)
            }
            // If InUse=false and no error, proceed normally
        } else if devErr != nil {
            // Can't get device path - device may already be disconnected
            klog.V(3).Infof("Could not get device path for NQN %s: %v (may be disconnected)", nqn, devErr)
        }
    }

    // Step 2: Disconnect from NVMe/TCP target
    // ... existing disconnect code
```

The check should be:
1. After unmount (filesystem no longer needs the device)
2. Before NVMe disconnect (verifies no other processes holding device)
3. Non-blocking on timeout (device unresponsive = proceed with disconnect)
4. Blocking if device busy (return FAILED_PRECONDITION to let kubelet retry)
  </action>
  <verify>grep -n "CheckDeviceInUse" pkg/driver/node.go shows the check in NodeUnstageVolume</verify>
  <done>NodeUnstageVolume checks device-in-use before NVMe disconnect, blocks if busy, proceeds on timeout</done>
</task>

<task type="auto">
  <name>Task 3: Add GetDevicePath method to Connector interface if missing</name>
  <files>pkg/nvme/nvme.go</files>
  <action>
Check if GetDevicePath method exists on the Connector interface. If not, add it.

The method should return the block device path for a given NQN:

```go
// GetDevicePath returns the block device path for a connected NVMe target.
// Returns empty string and nil error if not connected.
// Returns error if lookup fails.
func (c *Connector) GetDevicePath(nqn string) (string, error) {
    // Use resolver to find device by NQN
    if c.resolver == nil {
        return "", fmt.Errorf("no resolver configured")
    }

    devicePath, err := c.resolver.ResolveDeviceByNQN(nqn)
    if err != nil {
        return "", err
    }

    return devicePath, nil
}
```

If the method already exists, verify it works as expected. The resolver (from Phase 1-4) should have ResolveDeviceByNQN capability.

Also ensure the Connector interface (if there is one) includes this method:

```go
type Connector interface {
    // ... existing methods
    GetDevicePath(nqn string) (string, error)
}
```
  </action>
  <verify>grep -n "GetDevicePath" pkg/nvme/nvme.go shows the method exists</verify>
  <done>GetDevicePath method available on Connector to look up device path by NQN</done>
</task>

</tasks>

<verification>
1. `go build ./...` - code compiles
2. `make test` - existing tests pass
3. Verify device check function: grep "CheckDeviceInUse" pkg/nvme/device.go
4. Verify NodeUnstageVolume integration: grep "CheckDeviceInUse" pkg/driver/node.go
5. Test lsof behavior manually: `lsof /dev/nvme0n1` (should exit 1 if not in use)
</verification>

<success_criteria>
- CheckDeviceInUse function exists in pkg/nvme/device.go
- Uses lsof with 5s timeout via exec.CommandContext
- Returns structured DeviceUsageResult with InUse, Processes, TimedOut, Error
- NodeUnstageVolume calls CheckDeviceInUse after unmount, before disconnect
- Returns FAILED_PRECONDITION if device busy (with process list in error)
- Proceeds with disconnect if check times out (logs warning)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-migration-safety/09-03-SUMMARY.md`
</output>
