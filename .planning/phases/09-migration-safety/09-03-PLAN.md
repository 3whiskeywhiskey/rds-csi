---
phase: 09-migration-safety
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - pkg/driver/node.go
  - pkg/nvme/device.go
autonomous: true

must_haves:
  truths:
    - "NodeUnstageVolume checks for open file descriptors before NVMe disconnect"
    - "Device-in-use check uses lsof with timeout (5s) to prevent hanging"
    - "Busy device returns FAILED_PRECONDITION with list of blocking processes"
    - "Timeout on device check proceeds with disconnect (device likely unresponsive)"
  artifacts:
    - path: "pkg/nvme/device.go"
      provides: "CheckDeviceInUse function using lsof"
      contains: "CheckDeviceInUse"
    - path: "pkg/driver/node.go"
      provides: "Device-in-use check in NodeUnstageVolume"
      contains: "CheckDeviceInUse"
  key_links:
    - from: "pkg/driver/node.go"
      to: "pkg/nvme/device.go"
      via: "CheckDeviceInUse call in NodeUnstageVolume"
      pattern: "CheckDeviceInUse"
    - from: "pkg/driver/node.go"
      to: "pkg/nvme/nvme.go"
      via: "GetDevicePath lookup (returns error if not connected)"
      pattern: "GetDevicePath"
---

<objective>
Implement device-in-use verification in NodeUnstageVolume to prevent data corruption from premature NVMe disconnect

Purpose: SAFETY-04 - Verify no open file descriptors before NVMe disconnect to prevent data loss during forced pod termination
Output: NodeUnstageVolume checks lsof before disconnect, blocks if device busy, proceeds after timeout
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.5-ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-migration-safety/09-RESEARCH.md

# Key existing code
@pkg/driver/node.go
@pkg/nvme/nvme.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create device utility file with CheckDeviceInUse function</name>
  <files>pkg/nvme/device.go</files>
  <action>
Create a new file pkg/nvme/device.go with device-in-use detection:

```go
package nvme

import (
    "context"
    "fmt"
    "os/exec"
    "strings"
    "time"

    "k8s.io/klog/v2"
)

const (
    // DeviceCheckTimeout is the maximum time to wait for lsof to respond.
    // If exceeded, assume device is unresponsive and proceed with disconnect.
    DeviceCheckTimeout = 5 * time.Second
)

// DeviceUsageResult contains the result of a device-in-use check.
type DeviceUsageResult struct {
    // InUse is true if processes have the device open
    InUse bool
    // Processes is a list of "command[PID]" strings holding the device open
    Processes []string
    // TimedOut is true if the check timed out (device may be unresponsive)
    TimedOut bool
    // Error is set if the check failed for reasons other than timeout
    Error error
}

// CheckDeviceInUse checks if a device has open file descriptors using lsof.
// Returns InUse=true if processes are holding the device open.
// Returns TimedOut=true if lsof didn't respond within DeviceCheckTimeout (device may be unresponsive).
// Uses context for cancellation.
func CheckDeviceInUse(ctx context.Context, devicePath string) DeviceUsageResult {
    // Create timeout context
    checkCtx, cancel := context.WithTimeout(ctx, DeviceCheckTimeout)
    defer cancel()

    // Run lsof with timeout
    cmd := exec.CommandContext(checkCtx, "lsof", devicePath)
    out, err := cmd.Output()

    // Check for timeout
    if checkCtx.Err() == context.DeadlineExceeded {
        klog.Warningf("Device busy check timed out for %s after %v (device may be unresponsive)",
            devicePath, DeviceCheckTimeout)
        return DeviceUsageResult{
            InUse:    false, // Treat as not busy - device unresponsive, proceed with disconnect
            TimedOut: true,
        }
    }

    if err != nil {
        // lsof returns exit code 1 if no processes using device
        if exitErr, ok := err.(*exec.ExitError); ok && exitErr.ExitCode() == 1 {
            // No processes using device - this is the normal "not busy" case
            return DeviceUsageResult{InUse: false}
        }

        // Other error (lsof not found, permission denied, etc.)
        klog.Warningf("lsof command failed for %s: %v", devicePath, err)
        return DeviceUsageResult{
            InUse: false, // Can't determine - proceed with caution
            Error: fmt.Errorf("lsof failed: %w", err),
        }
    }

    // Parse lsof output
    // Format: COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
    lines := strings.Split(strings.TrimSpace(string(out)), "\n")
    if len(lines) <= 1 {
        // Only header line or empty - no processes
        return DeviceUsageResult{InUse: false}
    }

    // Extract process info from output (skip header line)
    processes := make([]string, 0, len(lines)-1)
    for _, line := range lines[1:] {
        fields := strings.Fields(line)
        if len(fields) >= 2 {
            // Format as "command[PID]" for readable error messages
            processes = append(processes, fmt.Sprintf("%s[PID:%s]", fields[0], fields[1]))
        }
    }

    if len(processes) > 0 {
        klog.V(2).Infof("Device %s in use by %d process(es): %v", devicePath, len(processes), processes)
        return DeviceUsageResult{
            InUse:     true,
            Processes: processes,
        }
    }

    return DeviceUsageResult{InUse: false}
}
```
  </action>
  <verify>go build ./pkg/nvme/... compiles successfully</verify>
  <done>pkg/nvme/device.go created with CheckDeviceInUse function using lsof with timeout</done>
</task>

<task type="auto">
  <name>Task 2: Add device-in-use check to NodeUnstageVolume</name>
  <files>pkg/driver/node.go</files>
  <action>
Update NodeUnstageVolume to check if device is in use before attempting NVMe disconnect.

Add import for the nvme package if not already present.

Between the unmount step and the NVMe disconnect step, add device-in-use verification:

```go
    // Step 1: Unmount from staging path
    if err := ns.mounter.Unmount(stagingPath); err != nil {
        // ... existing unmount error handling
    }

    klog.V(2).Infof("Unmounted volume %s from %s", volumeID, stagingPath)

    // SAFETY-04: Check device-in-use before NVMe disconnect
    // This prevents data corruption if processes still have the device open
    // (e.g., during forced pod termination or node failure scenarios)
    if nqn != "" {
        // GetDevicePath returns error (not empty string) if device not connected
        // This is expected during recovery scenarios where device was already disconnected
        devicePath, devErr := ns.nvmeConn.GetDevicePath(nqn)
        if devErr != nil {
            // Device not found/not connected - skip device-in-use check
            // This can happen if:
            // 1. Device was already disconnected (idempotent unstage)
            // 2. Connection was lost (device unreachable)
            // In both cases, proceed with disconnect attempt (which will be a no-op or cleanup)
            klog.V(3).Infof("Could not get device path for NQN %s: %v (device may already be disconnected, proceeding)", nqn, devErr)
        } else {
            // Device path found - check if it's in use before disconnecting
            result := nvme.CheckDeviceInUse(ctx, devicePath)

            if result.TimedOut {
                // Device check timed out - device may be unresponsive
                // Log warning and proceed with disconnect (device likely dead anyway)
                klog.Warningf("Device %s busy check timed out, proceeding with disconnect (device may be unresponsive)",
                    devicePath)
            } else if result.InUse {
                // Device has open file descriptors - unsafe to disconnect
                klog.Errorf("Device %s in use by processes: %v", devicePath, result.Processes)

                // Log failure
                secLogger.LogVolumeUnstage(volumeID, ns.nodeID, nqn, security.OutcomeFailure,
                    fmt.Errorf("device in use"), time.Since(startTime))

                return nil, status.Errorf(codes.FailedPrecondition,
                    "Device %s has open file descriptors, cannot safely unstage. "+
                    "Ensure pod using volume has terminated. Processes: %v",
                    devicePath, result.Processes)
            } else if result.Error != nil {
                // Check failed but not critical - log and proceed
                klog.Warningf("Device busy check failed for %s: %v (proceeding with disconnect)",
                    devicePath, result.Error)
            }
            // If InUse=false and no error, proceed normally
        }
    }

    // Step 2: Disconnect from NVMe/TCP target
    // ... existing disconnect code
```

**Critical contract:** `GetDevicePath(nqn)` returns:
- `(devicePath, nil)` when device is connected and found
- `("", error)` when device is NOT connected or not found

This means Task 2 MUST check for error first, not empty devicePath. The code above handles this correctly by checking `devErr != nil` to determine if device lookup succeeded.
  </action>
  <verify>grep -n "CheckDeviceInUse" pkg/driver/node.go shows the check in NodeUnstageVolume</verify>
  <done>NodeUnstageVolume checks device-in-use before NVMe disconnect, blocks if busy, proceeds on timeout</done>
</task>

<task type="auto">
  <name>Task 3: Document GetDevicePath contract for disconnected devices</name>
  <files>pkg/nvme/nvme.go</files>
  <action>
Add clarifying documentation to the GetDevicePath method to make the error-on-not-found contract explicit.

Find the existing GetDevicePath method and enhance its doc comment:

```go
// GetDevicePath returns the block device path for a connected NVMe target.
//
// Contract:
//   - Returns (devicePath, nil) when device is connected and found
//   - Returns ("", error) when device is NOT connected or lookup fails
//   - Never returns ("", nil) - empty path always comes with an error
//
// Callers should check error first, not empty string:
//   devicePath, err := conn.GetDevicePath(nqn)
//   if err != nil {
//       // Device not connected or lookup failed
//   }
//
// The error will be from DeviceResolver.ResolveDevicePath which returns
// "device not found for NQN" when the NQN is not connected.
func (c *connector) GetDevicePath(nqn string) (string, error) {
    return c.resolver.ResolveDevicePath(nqn)
}
```

This documentation clarifies the contract that Task 2 relies on: GetDevicePath returns error (not empty string) when the device is not connected. This is important because callers (like NodeUnstageVolume) need to distinguish between "device not connected" (normal during recovery) vs "device connected but check failed" (requires different handling).
  </action>
  <verify>grep -A15 "GetDevicePath returns" pkg/nvme/nvme.go shows the documented contract including "Returns.*error.*when device is NOT connected"</verify>
  <done>GetDevicePath contract documented: returns error (not empty string) when device not connected</done>
</task>

</tasks>

<verification>
1. `go build ./...` - code compiles
2. `make test` - existing tests pass
3. Verify device check function: grep "CheckDeviceInUse" pkg/nvme/device.go
4. Verify NodeUnstageVolume integration: grep "CheckDeviceInUse" pkg/driver/node.go
5. Verify GetDevicePath contract: grep -A10 "GetDevicePath returns" pkg/nvme/nvme.go shows error contract
6. Test lsof behavior manually: `lsof /dev/nvme0n1` (should exit 1 if not in use)
</verification>

<success_criteria>
- CheckDeviceInUse function exists in pkg/nvme/device.go
- Uses lsof with 5s timeout via exec.CommandContext
- Returns structured DeviceUsageResult with InUse, Processes, TimedOut, Error
- NodeUnstageVolume calls CheckDeviceInUse after unmount, before disconnect
- NodeUnstageVolume handles GetDevicePath error correctly (skips check if device not connected)
- Returns FAILED_PRECONDITION if device busy (with process list in error)
- Proceeds with disconnect if check times out (logs warning)
- GetDevicePath contract documented explicitly
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-migration-safety/09-03-SUMMARY.md`
</output>
