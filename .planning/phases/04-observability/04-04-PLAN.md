---
phase: 04-observability
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/driver/events.go
autonomous: true

must_haves:
  truths:
    - "Driver can post connection failure events to PVCs"
    - "Driver can post connection recovery events to PVCs"
    - "Driver logs orphan detection and cleanup events for debugging"
  artifacts:
    - path: "pkg/driver/events.go"
      provides: "Additional event posting methods for comprehensive coverage"
      exports: ["PostConnectionFailure", "PostConnectionRecovery", "PostOrphanDetected", "PostOrphanCleaned"]
      contains: "EventReasonConnectionFailure"
  key_links:
    - from: "pkg/driver/events.go"
      to: "ep.recorder.Event"
      via: "event recording"
      pattern: "recorder\\.Event.*EventReason"
---

<objective>
Extend EventPoster with additional event types for comprehensive operational visibility: connection failures/recovery, orphan detection/cleanup.

Purpose: Give operators complete visibility into driver lifecycle events via Kubernetes events on PVCs.
Output: Updated events.go with PostConnectionFailure, PostConnectionRecovery, PostOrphanDetected, PostOrphanCleaned methods.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-observability/04-RESEARCH.md
@pkg/driver/events.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add new event reason constants</name>
  <files>pkg/driver/events.go</files>
  <action>
Add new event reason constants to the existing const block:

```go
const (
    // Existing events
    EventReasonMountFailure       = "MountFailure"
    EventReasonRecoveryFailed     = "RecoveryFailed"
    EventReasonStaleMountDetected = "StaleMountDetected"

    // New events for comprehensive coverage
    EventReasonConnectionFailure  = "ConnectionFailure"
    EventReasonConnectionRecovery = "ConnectionRecovery"
    EventReasonOrphanDetected     = "OrphanDetected"
    EventReasonOrphanCleaned      = "OrphanCleaned"
)
```

These constants provide consistent event reason strings for filtering and alerting.
  </action>
  <verify>Run `go build ./pkg/driver/...` to verify compilation.</verify>
  <done>Four new event reason constants added to events.go.</done>
</task>

<task type="auto">
  <name>Task 2: Add connection and orphan event posting methods</name>
  <files>pkg/driver/events.go</files>
  <action>
Add four new event posting methods to EventPoster:

1. PostConnectionFailure - Posts Warning event when NVMe connection fails
```go
// PostConnectionFailure posts a Warning event when NVMe connection fails
// Parameters: ctx, pvcNamespace, pvcName, volumeID, nodeName, targetAddress, err
func (ep *EventPoster) PostConnectionFailure(ctx context.Context, pvcNamespace, pvcName, volumeID, nodeName, targetAddress string, err error) error {
    pvc, getErr := ep.clientset.CoreV1().PersistentVolumeClaims(pvcNamespace).Get(ctx, pvcName, metav1.GetOptions{})
    if getErr != nil {
        klog.Warningf("Failed to get PVC %s/%s for connection failure event: %v", pvcNamespace, pvcName, getErr)
        return nil
    }

    eventMessage := fmt.Sprintf("[%s] on [%s]: Connection to %s failed: %v", volumeID, nodeName, targetAddress, err)
    ep.recorder.Event(pvc, corev1.EventTypeWarning, EventReasonConnectionFailure, eventMessage)

    klog.V(2).Infof("Posted connection failure event to PVC %s/%s: %s", pvcNamespace, pvcName, eventMessage)
    return nil
}
```

2. PostConnectionRecovery - Posts Normal event when connection recovered
```go
// PostConnectionRecovery posts a Normal event when NVMe connection is recovered
func (ep *EventPoster) PostConnectionRecovery(ctx context.Context, pvcNamespace, pvcName, volumeID, nodeName, targetAddress string, attempts int) error {
    pvc, getErr := ep.clientset.CoreV1().PersistentVolumeClaims(pvcNamespace).Get(ctx, pvcName, metav1.GetOptions{})
    if getErr != nil {
        klog.Warningf("Failed to get PVC %s/%s for connection recovery event: %v", pvcNamespace, pvcName, getErr)
        return nil
    }

    eventMessage := fmt.Sprintf("[%s] on [%s]: Connection to %s recovered after %d attempts", volumeID, nodeName, targetAddress, attempts)
    ep.recorder.Event(pvc, corev1.EventTypeNormal, EventReasonConnectionRecovery, eventMessage)

    klog.V(2).Infof("Posted connection recovery event to PVC %s/%s: %s", pvcNamespace, pvcName, eventMessage)
    return nil
}
```

3. PostOrphanDetected - Logs warning when orphan connection detected (no PVC to post to)
```go
// PostOrphanDetected logs when an orphan NVMe connection is detected.
// Orphans have no associated PVC, so this logs rather than posting a K8s event.
// The log format is structured for easy parsing by log aggregation systems.
func (ep *EventPoster) PostOrphanDetected(ctx context.Context, nodeName, nqn string) error {
    klog.Infof("OrphanDetected: node=%s nqn=%s", nodeName, nqn)
    return nil
}
```

4. PostOrphanCleaned - Logs when orphan cleaned up (no PVC to post to)
```go
// PostOrphanCleaned logs when an orphan NVMe connection is cleaned up.
// Orphans have no associated PVC, so this logs rather than posting a K8s event.
func (ep *EventPoster) PostOrphanCleaned(ctx context.Context, nodeName, nqn string) error {
    klog.Infof("OrphanCleaned: node=%s nqn=%s", nodeName, nqn)
    return nil
}
```

Note: Orphan events are logged rather than posted to K8s because orphaned connections by definition have no associated PVC. The log format is structured for easy filtering in log aggregation (e.g., `OrphanDetected: node=worker-1 nqn=nqn.2000-02.com.mikrotik:pvc-xxx`).

All methods follow existing patterns:
- Return nil on PVC lookup failure (best-effort, don't block operations)
- Format message with [volumeID] on [nodeName] prefix for PVC events
- Use appropriate EventType (Warning for failures, Normal for informational)
  </action>
  <verify>
1. Run `go build ./pkg/driver/...` to verify compilation
2. Run `go test ./pkg/driver/... -v` to verify tests pass
  </verify>
  <done>EventPoster has PostConnectionFailure, PostConnectionRecovery, PostOrphanDetected, PostOrphanCleaned methods.</done>
</task>

</tasks>

<verification>
1. `go build ./pkg/driver/...` compiles successfully
2. `go test ./pkg/driver/... -v` passes all tests
3. Verify new constants: `grep -c "EventReason" pkg/driver/events.go` shows 7 constants
4. Verify new methods: `grep -c "func (ep \*EventPoster)" pkg/driver/events.go` shows 7 methods
</verification>

<success_criteria>
- Four new EventReason constants added
- Four new event posting methods added
- Connection events post to PVCs via K8s event recorder
- Orphan events log in structured format (no PVC available)
- All methods follow existing patterns (best-effort, don't block on failures)
- Code compiles and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-observability/04-04-SUMMARY.md`
</output>
