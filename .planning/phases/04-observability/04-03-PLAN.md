---
phase: 04-observability
plan: 03
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - cmd/rds-csi-plugin/main.go
  - pkg/driver/driver.go
  - pkg/driver/node.go
  - pkg/nvme/nvme.go
  - pkg/mount/recovery.go
autonomous: true

must_haves:
  truths:
    - "Operators can scrape /metrics endpoint while driver serves CSI requests"
    - "Metrics endpoint is accessible at /metrics path on configurable port"
    - "CSI operations record metrics for volume ops, NVMe connections, and mounts"
  artifacts:
    - path: "cmd/rds-csi-plugin/main.go"
      provides: "HTTP metrics server startup and --metrics-address flag"
      contains: "metricsAddr"
    - path: "pkg/driver/driver.go"
      provides: "Metrics integration point for driver operations"
      contains: "observability.Metrics"
    - path: "pkg/driver/node.go"
      provides: "Metrics recording in node operations"
      contains: "metrics.Record"
    - path: "pkg/nvme/nvme.go"
      provides: "Metrics recording in NVMe operations"
      contains: "metrics.Record"
  key_links:
    - from: "cmd/rds-csi-plugin/main.go"
      to: "http.ListenAndServe"
      via: "metrics server start"
      pattern: "ListenAndServe.*metricsAddr"
    - from: "cmd/rds-csi-plugin/main.go"
      to: "observability.NewMetrics"
      via: "metrics initialization"
      pattern: "observability\\.NewMetrics"
    - from: "pkg/driver/node.go"
      to: "metrics.RecordVolumeOp"
      via: "operation instrumentation"
      pattern: "RecordVolumeOp"
    - from: "pkg/nvme/nvme.go"
      to: "metrics.RecordNVMeConnect"
      via: "NVMe connect instrumentation"
      pattern: "RecordNVMeConnect"
---

<objective>
Add HTTP metrics server to main.go that exposes Prometheus metrics on a configurable port, integrate metrics into driver, and instrument CSI operations with metrics recording.

Purpose: Enable Prometheus to scrape driver metrics via HTTP /metrics endpoint with real operation data.
Output: Updated main.go with metrics server, updated driver.go to accept and use metrics instance, instrumented node.go and nvme.go with metrics recording calls.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-observability/04-RESEARCH.md
@cmd/rds-csi-plugin/main.go
@pkg/driver/driver.go
@pkg/driver/node.go
@pkg/nvme/nvme.go
@pkg/mount/recovery.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add metrics flag and HTTP server to main.go</name>
  <files>cmd/rds-csi-plugin/main.go</files>
  <action>
Update main.go to add Prometheus metrics HTTP server:

1. Add import for observability package:
   ```go
   "git.srvlab.io/whiskey/rds-csi-driver/pkg/observability"
   "net/http"
   ```

2. Add metrics address flag in var block:
   ```go
   metricsAddr = flag.String("metrics-address", ":9809", "Address for Prometheus metrics endpoint (empty to disable)")
   ```

   Port 9809 is common for storage controllers (per RESEARCH.md).

3. Before creating driver config, create metrics instance:
   ```go
   // Create Prometheus metrics
   var promMetrics *observability.Metrics
   if *metricsAddr != "" {
       promMetrics = observability.NewMetrics()
       klog.Infof("Prometheus metrics enabled on %s", *metricsAddr)
   }
   ```

4. Add promMetrics to DriverConfig (requires Task 2 to add field):
   ```go
   config := driver.DriverConfig{
       // ... existing fields ...
       Metrics: promMetrics,
   }
   ```

5. After creating driver but before Run(), start metrics HTTP server in goroutine:
   ```go
   // Start metrics HTTP server
   if promMetrics != nil {
       go func() {
           mux := http.NewServeMux()
           mux.Handle("/metrics", promMetrics.Handler())

           klog.Infof("Starting metrics server on %s", *metricsAddr)
           if err := http.ListenAndServe(*metricsAddr, mux); err != nil && err != http.ErrServerClosed {
               klog.Errorf("Metrics server failed: %v", err)
           }
       }()
   }
   ```

Place metrics server startup after driver creation but before drv.Run().
  </action>
  <verify>Run `go build ./cmd/rds-csi-plugin/...` to verify compilation (may fail until Task 2 completes).</verify>
  <done>main.go has --metrics-address flag and starts HTTP metrics server on configured port.</done>
</task>

<task type="auto">
  <name>Task 2: Add Metrics field to DriverConfig and Driver</name>
  <files>pkg/driver/driver.go</files>
  <action>
Update driver.go to accept and store metrics instance:

1. Add import for observability package:
   ```go
   "git.srvlab.io/whiskey/rds-csi-driver/pkg/observability"
   ```

2. Add Metrics field to DriverConfig struct:
   ```go
   type DriverConfig struct {
       // ... existing fields ...

       // Prometheus metrics (optional, nil to disable)
       Metrics *observability.Metrics
   }
   ```

3. Add Metrics field to Driver struct:
   ```go
   type Driver struct {
       // ... existing fields ...

       // Prometheus metrics (may be nil if disabled)
       metrics *observability.Metrics
   }
   ```

4. In NewDriver(), store metrics from config:
   ```go
   driver := &Driver{
       name:      config.DriverName,
       version:   config.Version,
       nodeID:    config.NodeID,
       k8sClient: config.K8sClient,
       metrics:   config.Metrics, // Add this line
   }
   ```

5. Add getter method for metrics (for node/controller servers to use):
   ```go
   // GetMetrics returns the Prometheus metrics instance (may be nil if disabled)
   func (d *Driver) GetMetrics() *observability.Metrics {
       return d.metrics
   }
   ```

Note: Actual metrics recording will be added in Task 3.
  </action>
  <verify>
1. Run `go build ./...` to verify compilation
2. Run `go test ./pkg/driver/... -v` to verify tests pass
  </verify>
  <done>DriverConfig has Metrics field, Driver stores metrics, GetMetrics() method exists.</done>
</task>

<task type="auto">
  <name>Task 3: Instrument CSI operations with metrics recording</name>
  <files>pkg/driver/node.go, pkg/nvme/nvme.go, pkg/mount/recovery.go</files>
  <action>
Add metrics recording calls to CSI operations. All calls must nil-check metrics first.

1. **pkg/driver/node.go** - Instrument NodeStageVolume and NodeUnstageVolume:

   At the START of NodeStageVolume, record timing:
   ```go
   start := time.Now()
   defer func() {
       if d.metrics != nil {
           d.metrics.RecordVolumeOp("stage", err, time.Since(start))
       }
   }()
   ```

   At the START of NodeUnstageVolume, same pattern:
   ```go
   start := time.Now()
   defer func() {
       if d.metrics != nil {
           d.metrics.RecordVolumeOp("unstage", err, time.Since(start))
       }
   }()
   ```

   In the stale mount detection block within NodeGetVolumeStats (around line 446):
   ```go
   if d.metrics != nil {
       d.metrics.RecordStaleMountDetected()
   }
   ```

2. **pkg/nvme/nvme.go** - Instrument Connect and Disconnect:

   First, add metrics field to NVMeManager struct if not present, and pass from driver.

   In Connect(), wrap the connection attempt:
   ```go
   start := time.Now()
   // ... existing connect logic ...
   if m.metrics != nil {
       m.metrics.RecordNVMeConnect(err, time.Since(start))
       if err == nil {
           // Increment active connections on success
           // (handled internally by RecordNVMeConnect)
       }
   }
   ```

   In Disconnect():
   ```go
   if m.metrics != nil {
       m.metrics.RecordNVMeDisconnect()
   }
   ```

3. **pkg/mount/recovery.go** - Instrument recovery operations:

   In RecoverStaleMount or equivalent recovery function:
   ```go
   if r.metrics != nil {
       r.metrics.RecordStaleRecovery(err)
   }
   ```

Pattern for all instrumentation:
- Always nil-check metrics before recording
- Use defer for timing to capture both success and error paths
- Pass operation name as string constant ("stage", "unstage", "connect")
- Pass err to let metrics package determine success/failure label
  </action>
  <verify>
1. Run `go build ./...` to verify compilation
2. Run `go test ./... -v` to verify all tests pass
3. Verify instrumentation: `grep -r "RecordVolumeOp\|RecordNVMeConnect\|RecordStaleMount" pkg/`
  </verify>
  <done>NodeStageVolume, NodeUnstageVolume record volume op metrics. NVMe Connect/Disconnect record connection metrics. Stale mount detection and recovery record respective metrics.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles successfully
2. `go test ./pkg/driver/... -v` passes all tests
3. Verify flag exists: `grep -n "metrics-address" cmd/rds-csi-plugin/main.go`
4. Verify HTTP server: `grep -n "ListenAndServe" cmd/rds-csi-plugin/main.go`
5. Verify Metrics field: `grep -n "metrics.*Metrics" pkg/driver/driver.go`
6. Verify instrumentation: `grep -rn "RecordVolumeOp\|RecordNVMeConnect" pkg/driver/ pkg/nvme/`
</verification>

<success_criteria>
- --metrics-address flag added to main.go with default :9809
- HTTP server starts in goroutine serving /metrics endpoint
- DriverConfig and Driver have Metrics field
- GetMetrics() method available on Driver
- NodeStageVolume and NodeUnstageVolume record volume operation metrics
- NVMe Connect/Disconnect record connection metrics
- Stale mount detection and recovery record metrics
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-observability/04-03-SUMMARY.md`
</output>
