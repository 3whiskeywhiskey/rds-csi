---
phase: 04-observability
plan: 03
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - cmd/rds-csi-plugin/main.go
  - pkg/driver/driver.go
autonomous: true

must_haves:
  truths:
    - "Driver exposes Prometheus metrics on configurable HTTP port"
    - "Metrics endpoint is accessible at /metrics path"
    - "Metrics server runs in background without blocking gRPC server"
  artifacts:
    - path: "cmd/rds-csi-plugin/main.go"
      provides: "HTTP metrics server startup and --metrics-address flag"
      contains: "metricsAddr"
    - path: "pkg/driver/driver.go"
      provides: "Metrics integration point for driver operations"
      contains: "observability.Metrics"
  key_links:
    - from: "cmd/rds-csi-plugin/main.go"
      to: "http.ListenAndServe"
      via: "metrics server start"
      pattern: "ListenAndServe.*metricsAddr"
    - from: "cmd/rds-csi-plugin/main.go"
      to: "observability.NewMetrics"
      via: "metrics initialization"
      pattern: "observability\\.NewMetrics"
---

<objective>
Add HTTP metrics server to main.go that exposes Prometheus metrics on a configurable port, integrate metrics into driver.

Purpose: Enable Prometheus to scrape driver metrics via HTTP /metrics endpoint.
Output: Updated main.go with metrics server, updated driver.go to accept and use metrics instance.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-observability/04-RESEARCH.md
@cmd/rds-csi-plugin/main.go
@pkg/driver/driver.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add metrics flag and HTTP server to main.go</name>
  <files>cmd/rds-csi-plugin/main.go</files>
  <action>
Update main.go to add Prometheus metrics HTTP server:

1. Add import for observability package:
   ```go
   "git.srvlab.io/whiskey/rds-csi-driver/pkg/observability"
   "net/http"
   ```

2. Add metrics address flag in var block:
   ```go
   metricsAddr = flag.String("metrics-address", ":9809", "Address for Prometheus metrics endpoint (empty to disable)")
   ```

   Port 9809 is common for storage controllers (per RESEARCH.md).

3. Before creating driver config, create metrics instance:
   ```go
   // Create Prometheus metrics
   var promMetrics *observability.Metrics
   if *metricsAddr != "" {
       promMetrics = observability.NewMetrics()
       klog.Infof("Prometheus metrics enabled on %s", *metricsAddr)
   }
   ```

4. Add promMetrics to DriverConfig (requires Task 2 to add field):
   ```go
   config := driver.DriverConfig{
       // ... existing fields ...
       Metrics: promMetrics,
   }
   ```

5. After creating driver but before Run(), start metrics HTTP server in goroutine:
   ```go
   // Start metrics HTTP server
   if promMetrics != nil {
       go func() {
           mux := http.NewServeMux()
           mux.Handle("/metrics", promMetrics.Handler())

           klog.Infof("Starting metrics server on %s", *metricsAddr)
           if err := http.ListenAndServe(*metricsAddr, mux); err != nil && err != http.ErrServerClosed {
               klog.Errorf("Metrics server failed: %v", err)
           }
       }()
   }
   ```

Place metrics server startup after driver creation but before drv.Run().
  </action>
  <verify>Run `go build ./cmd/rds-csi-plugin/...` to verify compilation (may fail until Task 2 completes).</verify>
  <done>main.go has --metrics-address flag and starts HTTP metrics server on configured port.</done>
</task>

<task type="auto">
  <name>Task 2: Add Metrics field to DriverConfig and Driver</name>
  <files>pkg/driver/driver.go</files>
  <action>
Update driver.go to accept and store metrics instance:

1. Add import for observability package:
   ```go
   "git.srvlab.io/whiskey/rds-csi-driver/pkg/observability"
   ```

2. Add Metrics field to DriverConfig struct:
   ```go
   type DriverConfig struct {
       // ... existing fields ...

       // Prometheus metrics (optional, nil to disable)
       Metrics *observability.Metrics
   }
   ```

3. Add Metrics field to Driver struct:
   ```go
   type Driver struct {
       // ... existing fields ...

       // Prometheus metrics (may be nil if disabled)
       metrics *observability.Metrics
   }
   ```

4. In NewDriver(), store metrics from config:
   ```go
   driver := &Driver{
       name:      config.DriverName,
       version:   config.Version,
       nodeID:    config.NodeID,
       k8sClient: config.K8sClient,
       metrics:   config.Metrics, // Add this line
   }
   ```

5. Add getter method for metrics (for node/controller servers to use):
   ```go
   // GetMetrics returns the Prometheus metrics instance (may be nil if disabled)
   func (d *Driver) GetMetrics() *observability.Metrics {
       return d.metrics
   }
   ```

Note: Actual metrics recording will be added in a later plan. This just establishes the plumbing.
  </action>
  <verify>
1. Run `go build ./...` to verify compilation
2. Run `go test ./pkg/driver/... -v` to verify tests pass
  </verify>
  <done>DriverConfig has Metrics field, Driver stores metrics, GetMetrics() method exists.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles successfully
2. `go test ./pkg/driver/... -v` passes all tests
3. Verify flag exists: `grep -n "metrics-address" cmd/rds-csi-plugin/main.go`
4. Verify HTTP server: `grep -n "ListenAndServe" cmd/rds-csi-plugin/main.go`
5. Verify Metrics field: `grep -n "metrics.*Metrics" pkg/driver/driver.go`
</verification>

<success_criteria>
- --metrics-address flag added to main.go with default :9809
- HTTP server starts in goroutine serving /metrics endpoint
- DriverConfig and Driver have Metrics field
- GetMetrics() method available on Driver
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-observability/04-03-SUMMARY.md`
</output>
