---
phase: 23-mock-rds-enhancements
plan: 02
type: execute
wave: 2
depends_on: [23-01]
files_modified:
  - test/mock/rds_server_test.go
  - test/mock/stress_test.go
  - docs/TESTING.md
autonomous: true

must_haves:
  truths:
    - "Concurrent SSH connections are handled without state corruption"
    - "Error injection modes are validated through automated tests"
    - "Timing simulation is validated through automated tests"
    - "Mock server behavior is documented in TESTING.md"
  artifacts:
    - path: "test/mock/rds_server_test.go"
      provides: "Unit tests for config, timing, error injection"
      contains: "TestLoadConfigFromEnv"
    - path: "test/mock/stress_test.go"
      provides: "Concurrent connection stress tests"
      contains: "TestConcurrentConnections"
    - path: "docs/TESTING.md"
      provides: "Mock configuration documentation"
      contains: "MOCK_RDS_"
  key_links:
    - from: "test/mock/stress_test.go"
      to: "test/mock/rds_server.go"
      via: "NewMockRDSServer and concurrent CreateVolume calls"
      pattern: "NewMockRDSServer"
    - from: "test/mock/rds_server_test.go"
      to: "test/mock/error_injection.go"
      via: "Testing ShouldFailDiskAdd with different modes"
      pattern: "ErrorInjector"
---

<objective>
Validate mock RDS enhancements through stress tests and update documentation

Purpose: Ensure concurrent operations work correctly and document mock configuration for other developers
Output: Comprehensive test coverage for mock enhancements and updated TESTING.md
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-mock-rds-enhancements/23-CONTEXT.md
@.planning/phases/23-mock-rds-enhancements/23-RESEARCH.md
@test/mock/rds_server.go
@docs/TESTING.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit tests for configuration, timing, and error injection</name>
  <files>
    test/mock/rds_server_test.go
  </files>
  <action>
Create or extend rds_server_test.go with comprehensive unit tests:

```go
// rds_server_test.go
package mock

import (
    "os"
    "testing"
)

// Config tests
func TestLoadConfigFromEnv(t *testing.T) {
    // Test defaults (no env vars)
    // Test each env var individually
    // Test boolean parsing (true/false/empty)
    // Test integer parsing (valid/invalid/empty)
}

func TestLoadConfigFromEnv_Defaults(t *testing.T) {
    // Clear env vars, verify defaults
    os.Unsetenv("MOCK_RDS_REALISTIC_TIMING")
    os.Unsetenv("MOCK_RDS_ERROR_MODE")
    // ...
    config := LoadConfigFromEnv()
    // Assert defaults
}

func TestLoadConfigFromEnv_RealisticTiming(t *testing.T) {
    t.Setenv("MOCK_RDS_REALISTIC_TIMING", "true")
    config := LoadConfigFromEnv()
    if !config.RealisticTiming {
        t.Error("expected RealisticTiming=true")
    }
}

// Timing tests
func TestTimingSimulator_Disabled(t *testing.T) {
    config := MockRDSConfig{RealisticTiming: false}
    timing := NewTimingSimulator(config)
    // Should return immediately
    start := time.Now()
    timing.SimulateSSHLatency()
    if time.Since(start) > 10*time.Millisecond {
        t.Error("timing should be disabled")
    }
}

func TestTimingSimulator_Enabled(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping timing test in short mode")
    }
    config := MockRDSConfig{
        RealisticTiming:    true,
        SSHLatencyMs:       200,
        SSHLatencyJitterMs: 50,
    }
    timing := NewTimingSimulator(config)
    start := time.Now()
    timing.SimulateSSHLatency()
    elapsed := time.Since(start)
    // Should be between 150-250ms
    if elapsed < 150*time.Millisecond || elapsed > 250*time.Millisecond {
        t.Errorf("expected latency 150-250ms, got %v", elapsed)
    }
}

// Error injection tests
func TestErrorInjector_None(t *testing.T) {
    config := MockRDSConfig{ErrorMode: "none"}
    injector := NewErrorInjector(config)
    shouldFail, _ := injector.ShouldFailDiskAdd()
    if shouldFail {
        t.Error("expected no error injection")
    }
}

func TestErrorInjector_DiskFull(t *testing.T) {
    config := MockRDSConfig{ErrorMode: "disk_full", ErrorAfterN: 0}
    injector := NewErrorInjector(config)
    shouldFail, errMsg := injector.ShouldFailDiskAdd()
    if !shouldFail {
        t.Error("expected disk full error")
    }
    if errMsg != "failure: not enough space\n" {
        t.Errorf("unexpected error message: %s", errMsg)
    }
}

func TestErrorInjector_AfterN(t *testing.T) {
    config := MockRDSConfig{ErrorMode: "disk_full", ErrorAfterN: 2}
    injector := NewErrorInjector(config)

    // First call - should not fail
    shouldFail, _ := injector.ShouldFailDiskAdd()
    if shouldFail {
        t.Error("first call should not fail")
    }

    // Second call - should fail
    shouldFail, _ = injector.ShouldFailDiskAdd()
    if !shouldFail {
        t.Error("second call should fail")
    }
}

func TestErrorInjector_Reset(t *testing.T) {
    config := MockRDSConfig{ErrorMode: "disk_full", ErrorAfterN: 1}
    injector := NewErrorInjector(config)

    // Trigger failure
    injector.ShouldFailDiskAdd()

    // Reset
    injector.Reset()

    // Should not fail again (counter reset)
    shouldFail, _ := injector.ShouldFailDiskAdd()
    if shouldFail {
        t.Error("after reset, should not fail immediately")
    }
}

func TestParseErrorMode(t *testing.T) {
    tests := []struct {
        input    string
        expected ErrorMode
    }{
        {"none", ErrorModeNone},
        {"disk_full", ErrorModeDiskFull},
        {"ssh_timeout", ErrorModeSSHTimeout},
        {"command_fail", ErrorModeCommandFail},
        {"", ErrorModeNone},
        {"invalid", ErrorModeNone},
    }
    for _, tt := range tests {
        t.Run(tt.input, func(t *testing.T) {
            if got := ParseErrorMode(tt.input); got != tt.expected {
                t.Errorf("ParseErrorMode(%q) = %v, want %v", tt.input, got, tt.expected)
            }
        })
    }
}
```

Run tests with: `go test ./test/mock/... -v`
  </action>
  <verify>
`go test ./test/mock/... -v` passes all tests.
Coverage for config.go, timing.go, error_injection.go > 80%.
  </verify>
  <done>
Unit tests for LoadConfigFromEnv, TimingSimulator, and ErrorInjector exist.
All tests pass.
Tests verify defaults, environment variable parsing, timing ranges, and error modes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create concurrent stress tests</name>
  <files>
    test/mock/stress_test.go
  </files>
  <action>
Create stress_test.go to validate MOCK-07 (concurrent SSH connections):

```go
// stress_test.go
package mock

import (
    "fmt"
    "sync"
    "sync/atomic"
    "testing"

    "git.srvlab.io/whiskey/rds-csi-driver/pkg/rds"
)

func TestConcurrentConnections(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping stress test in short mode")
    }

    // Start mock server
    server, err := NewMockRDSServer(0) // Port 0 = random available
    if err != nil {
        t.Fatalf("failed to create server: %v", err)
    }
    if err := server.Start(); err != nil {
        t.Fatalf("failed to start server: %v", err)
    }
    defer server.Stop()

    // Create SSH client (use production rds.Client)
    client := rds.NewClient(
        server.Address(),
        server.Port(),
        "admin",
        "", // No key needed - NoClientAuth
        "/storage-pool/test",
    )

    // Run concurrent CreateVolume operations
    const numGoroutines = 10
    const opsPerGoroutine = 5

    var wg sync.WaitGroup
    var successCount, failCount atomic.Int32
    var mu sync.Mutex
    createdVolumes := make([]string, 0)

    for g := 0; g < numGoroutines; g++ {
        wg.Add(1)
        go func(goroutineID int) {
            defer wg.Done()

            for op := 0; op < opsPerGoroutine; op++ {
                volumeID := fmt.Sprintf("test-vol-%d-%d", goroutineID, op)

                err := client.CreateVolume(volumeID, 1*1024*1024*1024) // 1 GiB
                if err != nil {
                    failCount.Add(1)
                    t.Logf("CreateVolume %s failed: %v", volumeID, err)
                } else {
                    successCount.Add(1)
                    mu.Lock()
                    createdVolumes = append(createdVolumes, volumeID)
                    mu.Unlock()
                }
            }
        }(g)
    }

    wg.Wait()

    // Verify results
    t.Logf("Success: %d, Failed: %d", successCount.Load(), failCount.Load())

    // All operations should succeed (no state corruption)
    expectedTotal := numGoroutines * opsPerGoroutine
    if int(successCount.Load()) != expectedTotal {
        t.Errorf("expected %d successes, got %d", expectedTotal, successCount.Load())
    }

    // Verify state consistency
    volumes := server.ListVolumes()
    if len(volumes) != expectedTotal {
        t.Errorf("expected %d volumes in server state, got %d", expectedTotal, len(volumes))
    }

    // Cleanup - delete all created volumes
    for _, volID := range createdVolumes {
        if err := client.DeleteVolume(volID); err != nil {
            t.Logf("DeleteVolume %s failed: %v", volID, err)
        }
    }
}

func TestConcurrentSameVolume(t *testing.T) {
    // Test concurrent CreateVolume with same ID (should have exactly one succeed)
    if testing.Short() {
        t.Skip("skipping stress test in short mode")
    }

    server, _ := NewMockRDSServer(0)
    server.Start()
    defer server.Stop()

    client := rds.NewClient(server.Address(), server.Port(), "admin", "", "/storage")

    const numGoroutines = 10
    volumeID := "concurrent-same-vol"

    var wg sync.WaitGroup
    var successCount, failCount atomic.Int32

    for g := 0; g < numGoroutines; g++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            err := client.CreateVolume(volumeID, 1*1024*1024*1024)
            if err != nil {
                failCount.Add(1)
            } else {
                successCount.Add(1)
            }
        }()
    }

    wg.Wait()

    // Exactly one should succeed (idempotency)
    if successCount.Load() != 1 {
        t.Errorf("expected exactly 1 success, got %d", successCount.Load())
    }
    if failCount.Load() != int32(numGoroutines-1) {
        t.Errorf("expected %d failures, got %d", numGoroutines-1, failCount.Load())
    }
}

func TestConcurrentCreateDelete(t *testing.T) {
    // Test concurrent create and delete operations
    if testing.Short() {
        t.Skip("skipping stress test in short mode")
    }

    server, _ := NewMockRDSServer(0)
    server.Start()
    defer server.Stop()

    client := rds.NewClient(server.Address(), server.Port(), "admin", "", "/storage")

    const numPairs = 5
    var wg sync.WaitGroup

    for i := 0; i < numPairs; i++ {
        volumeID := fmt.Sprintf("pair-vol-%d", i)

        // Create goroutine
        wg.Add(1)
        go func(volID string) {
            defer wg.Done()
            _ = client.CreateVolume(volID, 1*1024*1024*1024)
        }(volumeID)

        // Delete goroutine (may run before create completes)
        wg.Add(1)
        go func(volID string) {
            defer wg.Done()
            _ = client.DeleteVolume(volID)
        }(volumeID)
    }

    wg.Wait()

    // State should be consistent (no panics, no data corruption)
    // Final state depends on race but should be valid
    t.Logf("Final volume count: %d", len(server.ListVolumes()))
}
```

Run with: `go test ./test/mock/... -run TestConcurrent -v`
  </action>
  <verify>
`go test ./test/mock/... -run TestConcurrent -v` passes.
No data races (run with `-race`): `go test ./test/mock/... -run TestConcurrent -race`
TestConcurrentConnections creates all 50 volumes without state corruption.
TestConcurrentSameVolume has exactly 1 success and 9 failures.
  </verify>
  <done>
Stress tests validate MOCK-07 (concurrent SSH connections).
Tests pass with -race flag (no data races).
Concurrent operations do not corrupt state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update TESTING.md with mock configuration documentation</name>
  <files>
    docs/TESTING.md
  </files>
  <action>
Update docs/TESTING.md to document mock RDS configuration. Add a new section:

```markdown
## Mock RDS Server Configuration

The mock RDS server (`test/mock/rds_server.go`) simulates a MikroTik RDS server for testing without real hardware. It supports environment-based configuration for timing simulation and error injection.

### Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `MOCK_RDS_REALISTIC_TIMING` | `false` | Enable realistic operation delays |
| `MOCK_RDS_SSH_LATENCY_MS` | `200` | Base SSH connection latency (ms) |
| `MOCK_RDS_SSH_LATENCY_JITTER_MS` | `50` | Latency jitter range +/- (ms) |
| `MOCK_RDS_DISK_ADD_DELAY_MS` | `500` | Disk add operation delay (ms) |
| `MOCK_RDS_DISK_REMOVE_DELAY_MS` | `300` | Disk remove operation delay (ms) |
| `MOCK_RDS_ERROR_MODE` | `none` | Error injection mode |
| `MOCK_RDS_ERROR_AFTER_N` | `0` | Fail after N operations (0 = immediate) |
| `MOCK_RDS_ENABLE_HISTORY` | `true` | Enable command history logging |
| `MOCK_RDS_HISTORY_DEPTH` | `100` | Max commands in history |
| `MOCK_RDS_ROUTEROS_VERSION` | `7.16` | RouterOS version to simulate |

### Error Injection Modes

| Mode | Description | Error Message |
|------|-------------|---------------|
| `none` | No errors injected | - |
| `disk_full` | Simulate disk full condition | `failure: not enough space` |
| `ssh_timeout` | Simulate SSH connection timeout | (connection hangs) |
| `command_fail` | Simulate command execution failure | `failure: execution error` |

### Usage Examples

**Run sanity tests with error injection:**
```bash
MOCK_RDS_ERROR_MODE=disk_full make sanity
```

**Run tests with realistic timing:**
```bash
MOCK_RDS_REALISTIC_TIMING=true go test ./test/sanity/... -v
```

**Fail after 3rd operation (for idempotency testing):**
```bash
MOCK_RDS_ERROR_MODE=disk_full MOCK_RDS_ERROR_AFTER_N=3 make sanity
```

### Stress Testing

Run concurrent connection stress tests:
```bash
go test ./test/mock/... -run TestConcurrent -v -race
```

These tests validate the mock server handles multiple simultaneous SSH connections without state corruption (MOCK-07).
```

Place this section after the existing "Running Tests" section but before "Troubleshooting".
  </action>
  <verify>
docs/TESTING.md contains "Mock RDS Server Configuration" section.
All environment variables are documented with defaults and descriptions.
Error injection modes are documented with example usage.
Stress testing instructions included.
  </verify>
  <done>
TESTING.md updated with comprehensive mock configuration documentation.
Developers can configure mock behavior without reading source code.
Examples show common testing scenarios.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Unit tests pass**: `go test ./test/mock/... -v` shows all tests passing
2. **Stress tests pass**: `go test ./test/mock/... -run TestConcurrent -race` passes without races
3. **Documentation**: docs/TESTING.md contains mock configuration section
4. **Sanity regression**: `make sanity` still passes (no regression from Plan 01)
5. **CI-ready**: Tests can be run in CI without real hardware
</verification>

<success_criteria>
- MOCK-07 satisfied: Concurrent SSH connections validated through stress tests
- MOCK-04 fully satisfied: All error injection modes have unit tests
- MOCK-03 fully satisfied: Timing simulation validated through unit tests
- Documentation enables other developers to configure mock behavior
- All requirements MOCK-01 through MOCK-07 addressed by end of Phase 23
</success_criteria>

<output>
After completion, create `.planning/phases/23-mock-rds-enhancements/23-02-SUMMARY.md`
</output>
