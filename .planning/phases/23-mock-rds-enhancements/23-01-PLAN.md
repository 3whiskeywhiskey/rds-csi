---
phase: 23-mock-rds-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - test/mock/rds_server.go
  - test/mock/config.go
  - test/mock/timing.go
  - test/mock/error_injection.go
autonomous: true

must_haves:
  truths:
    - "Mock RDS server supports configurable timing simulation via environment variables"
    - "Error injection allows simulating disk full, SSH timeout, and command failures"
    - "Timing is disabled by default (fast tests) and enabled via MOCK_RDS_REALISTIC_TIMING=true"
    - "Error mode is configured via MOCK_RDS_ERROR_MODE environment variable"
  artifacts:
    - path: "test/mock/config.go"
      provides: "MockRDSConfig struct and environment loading"
      exports: ["MockRDSConfig", "LoadConfigFromEnv"]
    - path: "test/mock/timing.go"
      provides: "Timing simulation with SSH latency and operation delays"
      exports: ["TimingSimulator", "NewTimingSimulator"]
    - path: "test/mock/error_injection.go"
      provides: "Error injection modes (disk_full, ssh_timeout, command_fail)"
      exports: ["ErrorInjector", "NewErrorInjector", "ErrorMode"]
    - path: "test/mock/rds_server.go"
      provides: "Integration of config, timing, and error injection"
      contains: "timing.Simulate"
  key_links:
    - from: "test/mock/rds_server.go"
      to: "test/mock/config.go"
      via: "LoadConfigFromEnv in NewMockRDSServer"
      pattern: "LoadConfigFromEnv"
    - from: "test/mock/rds_server.go"
      to: "test/mock/timing.go"
      via: "timing.SimulateSSHLatency and timing.SimulateDiskOperation"
      pattern: "timing\\.Simulate"
    - from: "test/mock/rds_server.go"
      to: "test/mock/error_injection.go"
      via: "errorInjector.ShouldFail* checks in command handlers"
      pattern: "errorInjector\\.ShouldFail"
---

<objective>
Add configuration system, timing simulation, and error injection to mock RDS server

Purpose: Enable realistic testing scenarios that catch timeout bugs and validate error handling without real hardware
Output: Enhanced mock RDS with environment-based configuration for timing and error injection
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-mock-rds-enhancements/23-CONTEXT.md
@.planning/phases/23-mock-rds-enhancements/23-RESEARCH.md
@test/mock/rds_server.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create configuration and timing simulation infrastructure</name>
  <files>
    test/mock/config.go
    test/mock/timing.go
  </files>
  <action>
Create config.go with MockRDSConfig struct and LoadConfigFromEnv function:

```go
// config.go
package mock

type MockRDSConfig struct {
    // Timing control
    RealisticTiming   bool   // MOCK_RDS_REALISTIC_TIMING (default: false)
    SSHLatencyMs      int    // MOCK_RDS_SSH_LATENCY_MS (default: 200)
    SSHLatencyJitterMs int   // MOCK_RDS_SSH_LATENCY_JITTER_MS (default: 50, gives 150-250ms range)
    DiskAddDelayMs    int    // MOCK_RDS_DISK_ADD_DELAY_MS (default: 500)
    DiskRemoveDelayMs int    // MOCK_RDS_DISK_REMOVE_DELAY_MS (default: 300)

    // Error injection
    ErrorMode         string // MOCK_RDS_ERROR_MODE (none|disk_full|ssh_timeout|command_fail)
    ErrorAfterN       int    // MOCK_RDS_ERROR_AFTER_N (fail after N operations, default: 0 = immediate)

    // Observability
    EnableHistory     bool   // MOCK_RDS_ENABLE_HISTORY (default: true for backward compat)
    HistoryDepth      int    // MOCK_RDS_HISTORY_DEPTH (default: 100)
    RouterOSVersion   string // MOCK_RDS_ROUTEROS_VERSION (default: "7.16")
}

func LoadConfigFromEnv() MockRDSConfig
func getEnvBool(key string, defaultVal bool) bool
func getEnvInt(key string, defaultVal int) int
func getEnvString(key string, defaultVal string) string
```

Create timing.go with TimingSimulator:

```go
// timing.go
package mock

type TimingSimulator struct {
    enabled         bool
    sshLatency      time.Duration
    sshLatencyJitter time.Duration
    diskAddDelay    time.Duration
    diskRemoveDelay time.Duration
}

func NewTimingSimulator(config MockRDSConfig) *TimingSimulator
func (t *TimingSimulator) SimulateSSHLatency()    // Called at session start
func (t *TimingSimulator) SimulateDiskOperation(opType string) // "add" or "remove"
```

Key implementation details:
- Use math/rand for jitter (seeded with time.Now().UnixNano())
- Only add delays when enabled=true
- Log timing events at V(4) level for debugging
- Document environment variables in package doc comment
  </action>
  <verify>
Run `go build ./test/mock/...` to verify compilation.
Run `go test ./test/mock/... -run TestConfig -v` (add basic unit tests).
  </verify>
  <done>
config.go exports MockRDSConfig and LoadConfigFromEnv.
timing.go exports TimingSimulator with SimulateSSHLatency and SimulateDiskOperation.
Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error injection infrastructure</name>
  <files>
    test/mock/error_injection.go
  </files>
  <action>
Create error_injection.go with layered error injection:

```go
// error_injection.go
package mock

type ErrorMode int
const (
    ErrorModeNone ErrorMode = iota
    ErrorModeDiskFull      // Simulate "failure: not enough space"
    ErrorModeSSHTimeout    // Simulate SSH connection timeout
    ErrorModeCommandFail   // Simulate command execution failure
)

type ErrorInjector struct {
    mode         ErrorMode
    operationNum int
    triggerAfter int
    mu           sync.Mutex // Protect operation counter
}

func NewErrorInjector(config MockRDSConfig) *ErrorInjector
func ParseErrorMode(s string) ErrorMode

// Layer-specific failure checks
func (e *ErrorInjector) ShouldFailSSHConnect() bool           // Returns true if SSH should timeout
func (e *ErrorInjector) ShouldFailDiskAdd() (bool, string)    // Returns (shouldFail, errorMessage)
func (e *ErrorInjector) ShouldFailDiskRemove() (bool, string) // Returns (shouldFail, errorMessage)
func (e *ErrorInjector) Reset()                               // Reset operation counter for test isolation
```

Error messages must match production RDS format:
- Disk full: "failure: not enough space\n"
- Command fail: "failure: execution error\n"
- SSH timeout: Don't return message, simulate with delay (handled differently)

Implementation notes:
- Mutex protects operationNum counter for concurrent calls
- Log error injection events at V(2) with "MOCK ERROR INJECTION:" prefix
- ParseErrorMode accepts: "none", "disk_full", "ssh_timeout", "command_fail"
  </action>
  <verify>
Run `go build ./test/mock/...` to verify compilation.
Run `go test ./test/mock/... -run TestErrorInjection -v` (add unit tests).
  </verify>
  <done>
error_injection.go exports ErrorInjector, ErrorMode constants, and ParseErrorMode.
ShouldFailDiskAdd returns correct error message matching production format.
Compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate configuration, timing, and error injection into rds_server.go</name>
  <files>
    test/mock/rds_server.go
  </files>
  <action>
Modify rds_server.go to integrate the new components:

1. Add fields to MockRDSServer struct:
```go
type MockRDSServer struct {
    // ... existing fields ...
    config        MockRDSConfig
    timing        *TimingSimulator
    errorInjector *ErrorInjector
}
```

2. Update NewMockRDSServer to load config and create components:
```go
func NewMockRDSServer(port int) (*MockRDSServer, error) {
    config := LoadConfigFromEnv()

    server := &MockRDSServer{
        // ... existing initialization ...
        config:        config,
        timing:        NewTimingSimulator(config),
        errorInjector: NewErrorInjector(config),
    }
    // ...
}
```

3. Add timing simulation in handleSession (after SSH handshake, before processing requests):
```go
func (s *MockRDSServer) handleSession(channel ssh.Channel, requests <-chan *ssh.Request) {
    defer func() { _ = channel.Close() }()

    // Simulate SSH latency at session start
    s.timing.SimulateSSHLatency()

    for req := range requests {
        // ... existing code ...
    }
}
```

4. Add error injection checks in handleDiskAdd:
```go
func (s *MockRDSServer) handleDiskAdd(command string) (string, int) {
    // Check error injection BEFORE normal processing
    if shouldFail, errMsg := s.errorInjector.ShouldFailDiskAdd(); shouldFail {
        klog.V(2).Infof("MOCK ERROR INJECTION: Disk add failed - %s", strings.TrimSpace(errMsg))
        return errMsg, 1
    }

    // ... existing code ...

    // Add timing simulation before state modification
    s.timing.SimulateDiskOperation("add")

    // ... rest of existing code ...
}
```

5. Add error injection in handleDiskRemove:
```go
func (s *MockRDSServer) handleDiskRemove(command string) (string, int) {
    if shouldFail, errMsg := s.errorInjector.ShouldFailDiskRemove(); shouldFail {
        klog.V(2).Infof("MOCK ERROR INJECTION: Disk remove failed - %s", strings.TrimSpace(errMsg))
        return errMsg, 1
    }

    // ... existing code ...

    s.timing.SimulateDiskOperation("remove")

    // ... rest of existing code ...
}
```

6. Add ResetErrorInjector method for test isolation:
```go
func (s *MockRDSServer) ResetErrorInjector() {
    s.errorInjector.Reset()
}
```

7. Update history depth based on config (in recordCommand):
```go
func (s *MockRDSServer) recordCommand(command, response string, exitCode int) {
    if !s.config.EnableHistory {
        return
    }

    s.mu.Lock()
    defer s.mu.Unlock()

    // Trim history if over depth limit
    if len(s.commandHistory) >= s.config.HistoryDepth {
        s.commandHistory = s.commandHistory[1:]
    }

    s.commandHistory = append(s.commandHistory, CommandLog{...})
}
```
  </action>
  <verify>
Run `go build ./test/mock/...` to verify compilation.
Run existing sanity tests: `make sanity` - must still pass (no regression).
Test with environment variables:
```bash
MOCK_RDS_REALISTIC_TIMING=true MOCK_RDS_ERROR_MODE=disk_full go test ./test/sanity/... -v -count=1 2>&1 | head -50
```
Verify error injection triggers (CreateVolume should fail with "not enough space").
  </verify>
  <done>
MockRDSServer integrates config, timing, and error injection.
Existing sanity tests pass without environment variables (backward compatible).
Error injection triggered via MOCK_RDS_ERROR_MODE=disk_full causes CreateVolume to fail.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Compilation**: `go build ./test/mock/...` succeeds
2. **Backward compatibility**: `make sanity` passes without environment variables
3. **Timing simulation**: With MOCK_RDS_REALISTIC_TIMING=true, observe delays in test output
4. **Error injection**: With MOCK_RDS_ERROR_MODE=disk_full, CreateVolume fails with "not enough space"
5. **Configuration loading**: Environment variables are read correctly (add test or verify via logs)
</verification>

<success_criteria>
- MOCK-03 satisfied: Timing simulation with 200ms average SSH latency (150-250ms with jitter)
- MOCK-04 partially satisfied: Error injection for disk_full and command_fail modes
- Configuration system enables test-specific mock behavior without code changes
- All existing tests pass (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/23-mock-rds-enhancements/23-01-SUMMARY.md`
</output>
