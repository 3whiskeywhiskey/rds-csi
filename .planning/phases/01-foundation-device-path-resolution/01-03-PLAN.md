---
phase: 01-foundation-device-path-resolution
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - pkg/nvme/sysfs_test.go
  - pkg/nvme/resolver_test.go
autonomous: true

must_haves:
  truths:
    - "Sysfs scanning works with mock filesystem"
    - "Resolver cache behavior is verified (hit, miss, TTL expiry, device gone)"
    - "Orphan detection is tested"
    - "Tests use t.TempDir() for mock sysfs, no root access needed"
  artifacts:
    - path: "pkg/nvme/sysfs_test.go"
      provides: "Unit tests for sysfs scanning"
      min_lines: 100
    - path: "pkg/nvme/resolver_test.go"
      provides: "Unit tests for DeviceResolver"
      min_lines: 150
  key_links:
    - from: "pkg/nvme/sysfs_test.go"
      to: "pkg/nvme/sysfs.go"
      via: "tests create mock sysfs and call scanner functions"
      pattern: "SysfsScanner|ScanControllers|ReadSubsysNQN|FindBlockDevice"
    - from: "pkg/nvme/resolver_test.go"
      to: "pkg/nvme/resolver.go"
      via: "tests verify cache and orphan behavior"
      pattern: "DeviceResolver|ResolveDevicePath|Invalidate|IsOrphanedSubsystem"
---

<objective>
Create comprehensive unit tests for sysfs scanning and DeviceResolver.

Purpose: Ensure the new components work correctly across edge cases (cache hits, misses, TTL expiry, orphan detection) using mock filesystems that don't require root access.

Output: Two test files with full coverage of sysfs scanning and resolver behavior.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-device-path-resolution/01-RESEARCH.md

# Prior plan output
@.planning/phases/01-foundation-device-path-resolution/01-01-SUMMARY.md

# Files to test
@pkg/nvme/sysfs.go
@pkg/nvme/resolver.go

# Existing test patterns
@pkg/nvme/nvme_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sysfs scanning tests</name>
  <files>pkg/nvme/sysfs_test.go</files>
  <action>
Create `pkg/nvme/sysfs_test.go` with tests using mock filesystem.

**Test helper function:**
```go
// createMockSysfs creates a mock sysfs structure in a temp directory
// Returns the temp dir path (use with NewSysfsScannerWithRoot)
func createMockSysfs(t *testing.T, controllers []mockController) string {
    tmpDir := t.TempDir()

    for _, ctrl := range controllers {
        // Create controller directory: {tmpDir}/class/nvme/nvme0
        ctrlDir := filepath.Join(tmpDir, "class", "nvme", ctrl.name)
        if err := os.MkdirAll(ctrlDir, 0755); err != nil {
            t.Fatalf("Failed to create controller dir: %v", err)
        }

        // Write subsysnqn file
        if ctrl.nqn != "" {
            nqnPath := filepath.Join(ctrlDir, "subsysnqn")
            if err := os.WriteFile(nqnPath, []byte(ctrl.nqn+"\n"), 0644); err != nil {
                t.Fatalf("Failed to write subsysnqn: %v", err)
            }
        }

        // Create namespace directories
        for _, ns := range ctrl.namespaces {
            nsDir := filepath.Join(ctrlDir, ns)
            if err := os.MkdirAll(nsDir, 0755); err != nil {
                t.Fatalf("Failed to create namespace dir: %v", err)
            }
        }

        // Create block device entries in /sys/class/block
        for _, bd := range ctrl.blockDevices {
            bdDir := filepath.Join(tmpDir, "class", "block", bd)
            if err := os.MkdirAll(bdDir, 0755); err != nil {
                t.Fatalf("Failed to create block device dir: %v", err)
            }
        }
    }

    return tmpDir
}

type mockController struct {
    name         string   // e.g., "nvme0"
    nqn          string   // NQN value
    namespaces   []string // e.g., ["nvme0n1", "nvme0c1n1"]
    blockDevices []string // e.g., ["nvme0n1"]
}
```

**Test cases for ScanControllers:**
- Empty sysfs (no controllers)
- Single controller
- Multiple controllers
- Invalid directory structure

**Test cases for ReadSubsysNQN:**
- Valid NQN file
- NQN with trailing whitespace
- Missing subsysnqn file
- Invalid path

**Test cases for FindBlockDevice:**
- Simple nvmeXnY device
- Controller-based nvmeXcYnZ device (should find nvmeXnY if exists)
- No matching block device
- Multiple namespaces (return first)
  </action>
  <verify>
```bash
cd /Users/whiskey/code/rds-csi && go test ./pkg/nvme/... -v -run "TestSysfs" -count=1
```
  </verify>
  <done>
- `createMockSysfs()` helper creates test filesystem
- Tests for `ScanControllers()` cover empty, single, multiple controllers
- Tests for `ReadSubsysNQN()` cover valid, whitespace, missing file
- Tests for `FindBlockDevice()` cover nvmeXnY, nvmeXcYnZ, missing device
- All tests use `t.TempDir()` (automatic cleanup)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DeviceResolver tests</name>
  <files>pkg/nvme/resolver_test.go</files>
  <action>
Create `pkg/nvme/resolver_test.go` with tests for caching and orphan detection.

**Test cases for ResolveDevicePath:**

1. **Cache miss - device found:**
   - Create mock sysfs with matching NQN
   - Call ResolveDevicePath
   - Verify correct device path returned
   - Verify cache populated

2. **Cache hit - TTL valid:**
   - Create resolver with mock sysfs
   - Call ResolveDevicePath twice
   - Verify second call uses cache (can verify by removing mock files between calls)

3. **Cache miss - TTL expired:**
   - Create resolver with very short TTL (1ms)
   - Call ResolveDevicePath
   - Wait for TTL to expire
   - Call again - should rescan

4. **Cache invalidation - device gone:**
   - Create resolver with mock sysfs
   - Call ResolveDevicePath (populates cache)
   - Delete the device from mock sysfs
   - Call again - should detect device gone and rescan

5. **Device not found:**
   - Create resolver with empty mock sysfs
   - Call ResolveDevicePath
   - Verify appropriate error returned

**Test cases for Invalidate:**
- Invalidate existing entry
- Invalidate non-existent entry (should not error)

**Test cases for IsOrphanedSubsystem:**

1. **Not orphaned - not connected:**
   - Set isConnectedFn to return false
   - Call IsOrphanedSubsystem
   - Verify returns (false, nil)

2. **Not orphaned - connected with device:**
   - Set isConnectedFn to return true
   - Create mock sysfs with matching device
   - Call IsOrphanedSubsystem
   - Verify returns (false, nil)

3. **Orphaned - connected but no device:**
   - Set isConnectedFn to return true
   - Create mock sysfs WITHOUT matching device
   - Call IsOrphanedSubsystem
   - Verify returns (true, nil)

4. **No connection function set:**
   - Don't set isConnectedFn
   - Call IsOrphanedSubsystem
   - Verify returns (false, nil) - can't check orphan status

**Test structure:**
```go
func TestResolveDevicePath_CacheMiss(t *testing.T) { ... }
func TestResolveDevicePath_CacheHit(t *testing.T) { ... }
func TestResolveDevicePath_TTLExpired(t *testing.T) { ... }
func TestResolveDevicePath_DeviceGone(t *testing.T) { ... }
func TestResolveDevicePath_NotFound(t *testing.T) { ... }
func TestInvalidate(t *testing.T) { ... }
func TestIsOrphanedSubsystem(t *testing.T) { ... }
```
  </action>
  <verify>
```bash
cd /Users/whiskey/code/rds-csi && go test ./pkg/nvme/... -v -run "TestResolve|TestInvalidate|TestIsOrphaned" -count=1
```
  </verify>
  <done>
- Tests for cache miss/hit behavior
- Tests for TTL expiration
- Tests for device existence validation
- Tests for cache invalidation
- Tests for orphan detection (all scenarios)
- All tests pass without requiring root access
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify test coverage</name>
  <files>pkg/nvme/sysfs_test.go, pkg/nvme/resolver_test.go</files>
  <action>
Run tests with coverage and ensure adequate coverage of new code.

```bash
cd /Users/whiskey/code/rds-csi
go test ./pkg/nvme/... -coverprofile=coverage.out -covermode=atomic
go tool cover -func=coverage.out | grep -E "sysfs|resolver"
```

**Target coverage:**
- sysfs.go: >80%
- resolver.go: >80%

If coverage is below target, add additional tests for uncovered paths.
  </action>
  <verify>
```bash
cd /Users/whiskey/code/rds-csi && go test ./pkg/nvme/... -cover | grep -E "sysfs|resolver"
```
Coverage output shows >80% for both files.
  </verify>
  <done>
- All tests pass
- sysfs.go coverage >80%
- resolver.go coverage >80%
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/whiskey/code/rds-csi

# All tests pass
go test ./pkg/nvme/... -v -count=1

# Coverage is adequate
go test ./pkg/nvme/... -cover

# No race conditions
go test ./pkg/nvme/... -race -count=1
```
</verification>

<success_criteria>
1. `pkg/nvme/sysfs_test.go` exists with >100 lines of tests
2. `pkg/nvme/resolver_test.go` exists with >150 lines of tests
3. All tests pass without root access (use mock filesystem)
4. Coverage >80% for sysfs.go and resolver.go
5. Tests pass race detector
6. Test cases cover: cache hit, cache miss, TTL expiry, device gone, orphan detection
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-device-path-resolution/01-03-SUMMARY.md`
</output>
