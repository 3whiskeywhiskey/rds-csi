---
phase: 01-foundation-device-path-resolution
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - pkg/nvme/resolver.go
  - pkg/nvme/nvme.go
autonomous: true

must_haves:
  truths:
    - "DeviceResolver detects orphaned subsystems before returning device path"
    - "Connector uses DeviceResolver instead of inline sysfs scanning"
    - "Connector invalidates cache on disconnect"
    - "GetDevicePath delegates to resolver"
  artifacts:
    - path: "pkg/nvme/resolver.go"
      provides: "Orphan detection method"
      exports: ["IsOrphanedSubsystem"]
    - path: "pkg/nvme/nvme.go"
      provides: "Connector with integrated resolver"
      contains: "DeviceResolver"
  key_links:
    - from: "pkg/nvme/nvme.go"
      to: "pkg/nvme/resolver.go"
      via: "connector.resolver field"
      pattern: "resolver\\.ResolveDevicePath|resolver\\.Invalidate"
    - from: "pkg/nvme/resolver.go"
      to: "nvme list-subsys"
      via: "IsOrphanedSubsystem checks connection state"
      pattern: "IsConnected"
---

<objective>
Add orphan detection to DeviceResolver and integrate it into the existing NVMe connector.

Purpose: Complete the DeviceResolver with orphan detection (DEVP-02) and wire it into the connector so all device lookups use the cached resolver instead of inline sysfs scanning.

Output: Enhanced resolver with orphan detection, connector refactored to use resolver.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-device-path-resolution/01-RESEARCH.md

# Prior plan output
@.planning/phases/01-foundation-device-path-resolution/01-01-SUMMARY.md

# Files to modify
@pkg/nvme/nvme.go
@pkg/nvme/resolver.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add orphan detection to DeviceResolver</name>
  <files>pkg/nvme/resolver.go</files>
  <action>
Add orphan detection method to `pkg/nvme/resolver.go`.

**Add to DeviceResolver struct:**
```go
type DeviceResolver struct {
    scanner       *SysfsScanner
    cache         map[string]*cacheEntry
    mu            sync.RWMutex
    ttl           time.Duration
    isConnectedFn func(nqn string) (bool, error) // Injected for testing
}
```

**Add method:**
```go
// IsOrphanedSubsystem detects orphaned subsystems - appear connected but have no device.
// An orphaned subsystem occurs when the controller loses connection but the
// subsystem entry persists in nvme list-subsys output.
//
// Returns:
// - (true, nil): Subsystem appears connected but no device found - orphaned
// - (false, nil): Not connected OR connected with valid device - not orphaned
// - (false, err): Error checking connection state
func (r *DeviceResolver) IsOrphanedSubsystem(nqn string) (bool, error)

// SetIsConnectedFn sets the connection check function (for integration with connector)
func (r *DeviceResolver) SetIsConnectedFn(fn func(nqn string) (bool, error))
```

**IsOrphanedSubsystem logic:**
1. If `isConnectedFn` is nil, return (false, nil) - can't check without connector
2. Call `isConnectedFn(nqn)` to check if subsystem appears connected
3. If not connected, return (false, nil) - not orphaned
4. If connected, try to find device via sysfs scan (bypass cache)
5. If device found, return (false, nil) - not orphaned
6. If no device found, log warning and return (true, nil) - orphaned

**Logging:**
- `klog.Warningf` when orphan detected: "Orphaned subsystem detected: NQN %s appears connected but has no device"
- `klog.V(4)` for orphan check results
  </action>
  <verify>
```bash
cd /Users/whiskey/code/rds-csi && go build ./pkg/nvme/... && go vet ./pkg/nvme/...
```
  </verify>
  <done>
- `IsOrphanedSubsystem()` method added to DeviceResolver
- `SetIsConnectedFn()` for connector integration
- Method checks connection state then verifies device existence
- Warning logged when orphan detected
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate DeviceResolver into connector</name>
  <files>pkg/nvme/nvme.go</files>
  <action>
Refactor the connector in `pkg/nvme/nvme.go` to use DeviceResolver.

**Changes to connector struct:**
```go
type connector struct {
    execCommand       func(name string, args ...string) *exec.Cmd
    config            Config
    metrics           *Metrics
    activeOperations  map[string]*operationTracker
    activeOpsMu       sync.Mutex
    healthcheckDone   chan struct{}
    healthcheckCancel context.CancelFunc
    resolver          *DeviceResolver  // NEW: Add resolver field
}
```

**Changes to NewConnectorWithConfig:**
```go
func NewConnectorWithConfig(config Config) Connector {
    // ... existing setup ...

    c := &connector{
        // ... existing fields ...
        resolver: NewDeviceResolver(), // NEW: Initialize resolver
    }

    // NEW: Wire up connection check for orphan detection
    c.resolver.SetIsConnectedFn(func(nqn string) (bool, error) {
        return c.IsConnected(nqn)
    })

    // ... rest of function ...
}
```

**Changes to GetDevicePath:**
Replace the entire inline sysfs scanning with:
```go
func (c *connector) GetDevicePath(nqn string) (string, error) {
    return c.resolver.ResolveDevicePath(nqn)
}
```

**Changes to DisconnectWithContext:**
Add cache invalidation after successful disconnect:
```go
func (c *connector) DisconnectWithContext(ctx context.Context, nqn string) error {
    // ... existing disconnect logic ...

    // After successful disconnect, invalidate cache
    c.resolver.Invalidate(nqn)

    klog.V(2).Infof("Successfully disconnected from NVMe target: %s", nqn)
    return nil
}
```

**Changes to ConnectWithContext (orphan handling):**
The existing code at lines 493-505 already handles orphans by attempting reconnect. Enhance it:
```go
if connected {
    klog.V(2).Infof("Already connected to NQN: %s", target.NQN)

    // Check for orphaned subsystem
    orphaned, err := c.resolver.IsOrphanedSubsystem(target.NQN)
    if err != nil {
        klog.Warningf("Failed to check orphan status for %s: %v", target.NQN, err)
    }

    if orphaned {
        klog.Warningf("NQN %s is orphaned, forcing disconnect and reconnect", target.NQN)
        c.resolver.Invalidate(target.NQN)
        _ = c.DisconnectWithContext(ctx, target.NQN)
        // Fall through to connect logic
    } else {
        // Not orphaned - return cached device path
        return c.resolver.ResolveDevicePath(target.NQN)
    }
}
```

**DO NOT:**
- Remove the existing `GetDevicePath` method signature (it's part of Connector interface)
- Change the Connector interface
- Remove the inline sysfs scanning code yet - mark it as deprecated with `//nolint:unused`
  </action>
  <verify>
```bash
cd /Users/whiskey/code/rds-csi && go build ./... && go vet ./...
```
Full project compiles and passes vet.
  </verify>
  <done>
- Connector has `resolver` field
- `GetDevicePath()` delegates to resolver
- `DisconnectWithContext()` invalidates cache
- `ConnectWithContext()` uses `IsOrphanedSubsystem()` for orphan detection
- Orphan detection triggers disconnect and reconnect
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/whiskey/code/rds-csi

# Full build succeeds
go build ./...

# Vet passes
go vet ./...

# Verify integration points exist
grep -n "resolver.*DeviceResolver\|resolver.ResolveDevicePath\|resolver.Invalidate\|IsOrphanedSubsystem" pkg/nvme/nvme.go

# Existing tests still pass
go test ./pkg/nvme/... -v -count=1
```
</verification>

<success_criteria>
1. `IsOrphanedSubsystem()` method exists on DeviceResolver
2. Connector struct has `resolver` field of type `*DeviceResolver`
3. `GetDevicePath()` delegates to `resolver.ResolveDevicePath()`
4. `DisconnectWithContext()` calls `resolver.Invalidate()`
5. `ConnectWithContext()` checks for orphaned subsystems
6. All existing tests pass
7. Full project compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-device-path-resolution/01-02-SUMMARY.md`
</output>
