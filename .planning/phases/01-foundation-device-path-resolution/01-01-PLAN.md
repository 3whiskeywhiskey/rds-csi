---
phase: 01-foundation-device-path-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/nvme/sysfs.go
  - pkg/nvme/resolver.go
autonomous: true

must_haves:
  truths:
    - "DeviceResolver can resolve device path from NQN via sysfs scan"
    - "Cache returns cached path if TTL not expired and device exists"
    - "Cache invalidates and re-scans if TTL expired or device gone"
    - "Sysfs root is configurable for testing"
  artifacts:
    - path: "pkg/nvme/sysfs.go"
      provides: "Sysfs scanning functions"
      exports: ["ScanControllers", "ReadSubsysNQN", "FindBlockDevice"]
    - path: "pkg/nvme/resolver.go"
      provides: "DeviceResolver with TTL cache"
      exports: ["DeviceResolver", "NewDeviceResolver", "ResolveDevicePath", "Invalidate"]
  key_links:
    - from: "pkg/nvme/resolver.go"
      to: "pkg/nvme/sysfs.go"
      via: "scanSysfs calls sysfs functions"
      pattern: "ScanControllers|ReadSubsysNQN|FindBlockDevice"
---

<objective>
Create the foundational DeviceResolver component with sysfs scanning and TTL caching.

Purpose: This is the core component that enables reliable NQN-to-device-path resolution. It replaces the fragile inline sysfs scanning in `GetDevicePath()` with a dedicated, cacheable, testable resolver.

Output: Two new files (`sysfs.go`, `resolver.go`) that provide NQN-based device resolution with TTL caching.
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-device-path-resolution/01-RESEARCH.md

# Existing code to refactor from
@pkg/nvme/nvme.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sysfs scanning functions</name>
  <files>pkg/nvme/sysfs.go</files>
  <action>
Create `pkg/nvme/sysfs.go` with low-level sysfs scanning functions extracted from the existing `GetDevicePath()` logic.

**Required types and functions:**

```go
// SysfsScanner provides configurable sysfs access for testing
type SysfsScanner struct {
    Root string // "/sys" in production, temp dir in tests
}

// NewSysfsScanner creates scanner with default root
func NewSysfsScanner() *SysfsScanner

// NewSysfsScannerWithRoot creates scanner with custom root (for testing)
func NewSysfsScannerWithRoot(root string) *SysfsScanner

// ScanControllers returns all NVMe controller paths
// e.g., ["/sys/class/nvme/nvme0", "/sys/class/nvme/nvme1"]
func (s *SysfsScanner) ScanControllers() ([]string, error)

// ReadSubsysNQN reads the subsysnqn file from a controller path
func (s *SysfsScanner) ReadSubsysNQN(controllerPath string) (string, error)

// FindBlockDevice finds the block device for a controller
// Handles both nvmeXnY (preferred) and nvmeXcYnZ (fallback) naming
func (s *SysfsScanner) FindBlockDevice(controllerPath string) (string, error)
```

**Implementation notes:**
- Extract logic from existing `GetDevicePath()` in nvme.go (lines 326-403)
- Use `filepath.Glob` for scanning, `os.ReadFile` for reading
- Prefer `nvmeXnY` format over `nvmeXcYnZ` (subsystem-based over controller-based)
- Return descriptive errors with context (wrap with `fmt.Errorf`)
- Use `strings.TrimSpace` when reading NQN to handle trailing newlines

**DO NOT:**
- Add any caching here - that's the resolver's job
- Import nvme-cli or exec anything - pure filesystem operations
- Use hardcoded "/sys" path - always use s.Root
  </action>
  <verify>
```bash
cd /Users/whiskey/code/rds-csi && go build ./pkg/nvme/...
```
File compiles without errors.
  </verify>
  <done>
- `SysfsScanner` struct with configurable Root
- `ScanControllers()` returns controller paths
- `ReadSubsysNQN()` reads NQN from controller
- `FindBlockDevice()` resolves block device path
- All functions use configurable sysfs root
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DeviceResolver with TTL cache</name>
  <files>pkg/nvme/resolver.go</files>
  <action>
Create `pkg/nvme/resolver.go` with the DeviceResolver that provides NQN-to-device-path resolution with TTL caching.

**Required types and functions:**

```go
// DeviceResolver resolves NQN to device paths with caching
type DeviceResolver struct {
    scanner *SysfsScanner
    cache   map[string]*cacheEntry
    mu      sync.RWMutex
    ttl     time.Duration
}

type cacheEntry struct {
    devicePath string
    resolvedAt time.Time
}

// ResolverConfig holds resolver configuration
type ResolverConfig struct {
    SysfsRoot string        // Default: "/sys"
    TTL       time.Duration // Default: 10 * time.Second
}

// DefaultResolverConfig returns sensible defaults
func DefaultResolverConfig() ResolverConfig

// NewDeviceResolver creates resolver with default config
func NewDeviceResolver() *DeviceResolver

// NewDeviceResolverWithConfig creates resolver with custom config
func NewDeviceResolverWithConfig(cfg ResolverConfig) *DeviceResolver

// ResolveDevicePath resolves NQN to device path, using cache if valid
func (r *DeviceResolver) ResolveDevicePath(nqn string) (string, error)

// Invalidate removes an NQN from the cache (call on disconnect)
func (r *DeviceResolver) Invalidate(nqn string)

// InvalidateAll clears the entire cache
func (r *DeviceResolver) InvalidateAll()
```

**ResolveDevicePath logic:**
1. Check cache under read lock
2. If cached AND TTL not expired AND device still exists (os.Stat): return cached
3. Otherwise, scan sysfs for matching NQN
4. Update cache under write lock
5. Return device path or error

**Cache validation:**
- TTL check: `time.Since(entry.resolvedAt) < r.ttl`
- Device existence check: `os.Stat(entry.devicePath)` succeeds
- Both must pass to use cached value

**Defaults:**
- SysfsRoot: "/sys"
- TTL: 10 seconds (short enough to catch reconnections, long enough to avoid overhead)

**Logging:**
- Use `klog.V(4)` for cache hits
- Use `klog.V(3)` for cache misses and rescans
- Use `klog.V(2)` for resolution results
  </action>
  <verify>
```bash
cd /Users/whiskey/code/rds-csi && go build ./pkg/nvme/... && go vet ./pkg/nvme/...
```
File compiles and passes vet.
  </verify>
  <done>
- `DeviceResolver` struct with TTL cache
- `ResolveDevicePath()` checks cache, validates, rescans if needed
- `Invalidate()` removes single entry
- `InvalidateAll()` clears cache
- Configurable TTL (default 10s)
- Configurable sysfs root for testing
- Thread-safe with RWMutex
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/whiskey/code/rds-csi

# Build succeeds
go build ./pkg/nvme/...

# Vet passes
go vet ./pkg/nvme/...

# Verify exports exist
grep -n "func.*ScanControllers\|func.*ReadSubsysNQN\|func.*FindBlockDevice" pkg/nvme/sysfs.go
grep -n "func.*ResolveDevicePath\|func.*Invalidate\|func.*NewDeviceResolver" pkg/nvme/resolver.go
```
</verification>

<success_criteria>
1. `pkg/nvme/sysfs.go` exists with SysfsScanner and scanning functions
2. `pkg/nvme/resolver.go` exists with DeviceResolver and caching logic
3. Both files compile without errors
4. Sysfs root is configurable (not hardcoded "/sys")
5. TTL is configurable with sensible default (10s)
6. Cache uses RWMutex for thread safety
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-device-path-resolution/01-01-SUMMARY.md`
</output>
