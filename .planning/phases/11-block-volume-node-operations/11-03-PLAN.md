---
phase: 11-block-volume-node-operations
plan: 03
type: execute
wave: 3
depends_on: ["11-02"]
files_modified:
  - pkg/driver/node.go
  - pkg/driver/node_test.go
autonomous: true

must_haves:
  truths:
    - "NodeUnstageVolume handles block volumes correctly without attempting filesystem unmount"
    - "NodeUnstageVolume cleans up staging metadata file for block volumes"
    - "Block volume operations have unit test coverage"
  artifacts:
    - path: "pkg/driver/node.go"
      provides: "Block volume unstaging logic"
      contains: "isBlockVolume"
    - path: "pkg/driver/node_test.go"
      provides: "Unit tests for block volume operations"
      contains: "Block"
  key_links:
    - from: "pkg/driver/node.go NodeUnstageVolume"
      to: "staging metadata detection"
      via: "os.Stat check"
      pattern: "filepath\\.Join.*staging.*device"
---

<objective>
Implement block volume support in NodeUnstageVolume and add comprehensive unit tests for all block volume node operations.

Purpose: Complete the unstage path for block volumes (skip filesystem unmount, clean up metadata file) and ensure all block volume operations are properly tested.

Output:
- NodeUnstageVolume detects block volumes via staging metadata and handles cleanup correctly
- Unit tests covering NodeStageVolume, NodePublishVolume, NodeUnpublishVolume, NodeUnstageVolume for block volumes
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-block-volume-node-operations/11-RESEARCH.md
@.planning/phases/11-block-volume-node-operations/11-01-SUMMARY.md
@.planning/phases/11-block-volume-node-operations/11-02-SUMMARY.md
@pkg/driver/node.go
@pkg/driver/node_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement block volume support in NodeUnstageVolume</name>
  <files>pkg/driver/node.go</files>
  <action>
Modify NodeUnstageVolume in pkg/driver/node.go to handle block volumes:

1. After validation and before the unmount step, detect if this was a block volume by checking for the staging metadata file:

```go
// Detect if this was a block volume by checking for staging metadata file
// Block volumes have a "device" file in staging directory instead of a mounted filesystem
metadataPath := filepath.Join(stagingPath, "device")
isBlockVolume := false
if _, err := os.Stat(metadataPath); err == nil {
    isBlockVolume = true
}

klog.V(2).Infof("NodeUnstageVolume: volume %s, isBlock=%v", volumeID, isBlockVolume)
```

2. Add branching for unstage logic (before the existing unmount step):

```go
if isBlockVolume {
    // Block volume: no filesystem to unmount, just clean up staging metadata and directory
    klog.V(2).Infof("Unstaging block volume %s from %s", volumeID, stagingPath)

    // SAFETY-04: Check device-in-use before NVMe disconnect
    // For block volumes, check the actual NVMe device, not the staging path
    if nqn != "" {
        deviceBytes, err := os.ReadFile(metadataPath)
        if err == nil {
            devicePath := strings.TrimSpace(string(deviceBytes))
            result := nvme.CheckDeviceInUse(ctx, devicePath)

            if result.TimedOut {
                klog.Warningf("Device %s busy check timed out, proceeding with disconnect", devicePath)
            } else if result.InUse {
                klog.Errorf("Device %s in use by processes: %v", devicePath, result.Processes)
                secLogger.LogVolumeUnstage(volumeID, ns.nodeID, nqn, security.OutcomeFailure,
                    fmt.Errorf("device in use"), time.Since(startTime))
                return nil, status.Errorf(codes.FailedPrecondition,
                    "Device %s has open file descriptors, cannot safely unstage. "+
                        "Ensure pod using volume has terminated. Processes: %v",
                    devicePath, result.Processes)
            } else if result.Error != nil {
                klog.Warningf("Device busy check failed for %s: %v (proceeding)", devicePath, result.Error)
            }
        }
    }

    // Remove metadata file
    if err := os.Remove(metadataPath); err != nil && !os.IsNotExist(err) {
        klog.Warningf("Failed to remove block volume metadata file %s: %v", metadataPath, err)
    }

    // Remove staging directory (should be empty now)
    if err := os.Remove(stagingPath); err != nil && !os.IsNotExist(err) {
        klog.Warningf("Failed to remove staging directory %s: %v", stagingPath, err)
    }

    // Skip to NVMe disconnect (below)
} else {
    // Filesystem volume: existing unmount logic
    // ... existing Step 1: Unmount from staging path code ...
}
```

3. Ensure the existing unmount code is in an else block, and the NVMe disconnect (Step 2) happens for both block and filesystem volumes.

Key points from research:
- Block volumes don't have filesystems mounted, so Unmount() is NOT needed
- Clean up metadata file and staging directory
- Device-in-use check should use the actual /dev/nvmeXnY device path, not staging path
- NVMe disconnect is needed for both block and filesystem volumes
  </action>
  <verify>
Run `make build` to ensure code compiles.
Run `grep -n "isBlockVolume" pkg/driver/node.go` shows detection in NodeUnstageVolume.
Run `grep -n "metadataPath" pkg/driver/node.go` shows metadata file handling.
  </verify>
  <done>
NodeUnstageVolume detects block volumes via staging metadata file, skips filesystem unmount for block volumes, cleans up metadata file and staging directory, performs device-in-use check on actual NVMe device.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for block volume operations</name>
  <files>pkg/driver/node_test.go</files>
  <action>
Add comprehensive unit tests for block volume operations in pkg/driver/node_test.go.

First, examine existing test structure and mock patterns in node_test.go.

Add test cases covering:

1. **TestNodeStageVolume_BlockVolume**
   - Test that block volume staging:
     - Creates staging directory
     - Writes device path to metadata file
     - Does NOT call Format()
     - Does NOT call Mount()
   - Use mock NVMe connector that returns success with device path
   - Verify metadata file contains expected device path

2. **TestNodeStageVolume_FilesystemVolume_Unchanged**
   - Verify filesystem volume staging still calls Format() and Mount()
   - Ensures no regression from block volume changes

3. **TestNodePublishVolume_BlockVolume**
   - Test that block volume publishing:
     - Reads device path from staging metadata
     - Creates target file with MakeFile
     - Bind-mounts device to target
   - Mock staging metadata file with device path
   - Verify Mount() called with correct source (device) and target

4. **TestNodePublishVolume_BlockVolume_MissingMetadata**
   - Test error when staging metadata file doesn't exist
   - Should return FailedPrecondition error

5. **TestNodeUnpublishVolume_BlockVolume**
   - Test that unpublish works for file targets (block volumes)
   - Verify Unmount() called
   - Verify target path removed

6. **TestNodeUnstageVolume_BlockVolume**
   - Test that block volume unstaging:
     - Does NOT call Unmount()
     - Removes metadata file
     - Removes staging directory
     - Calls NVMe disconnect
   - Create staging directory with metadata file before test

7. **TestNodeUnstageVolume_FilesystemVolume_Unchanged**
   - Verify filesystem volume unstaging still calls Unmount()
   - Ensures no regression

Create helper functions as needed:
- `createBlockVolumeCapability()` - returns VolumeCapability with Block access type
- `createFilesystemVolumeCapability()` - returns VolumeCapability with Mount access type

Use existing mock patterns from node_test.go for mocking Mounter and NVMe connector.
  </action>
  <verify>
Run `make test` and verify all new tests pass.
Run `go test -v ./pkg/driver/... -run Block` shows block volume tests running.
Run `go test -cover ./pkg/driver/...` shows coverage.
  </verify>
  <done>
Unit tests exist for all block volume node operations: stage, publish, unpublish, unstage. Tests verify correct behavior for block volumes and no regression for filesystem volumes. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `make build` succeeds
2. `make test` passes all tests including new block volume tests
3. NodeUnstageVolume has clear branching for block vs filesystem volumes
4. Block volume unstage: no Unmount(), metadata cleanup, directory cleanup
5. Unit tests cover positive and negative cases for block volumes
6. No regression in filesystem volume behavior
</verification>

<success_criteria>
- NodeUnstageVolume detects block volumes via staging metadata
- NodeUnstageVolume skips Unmount() for block volumes
- NodeUnstageVolume cleans up metadata file and staging directory
- Unit tests exist for all block volume operations
- All tests pass (make test)
- Requirements BLOCK-01 through BLOCK-05 are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/11-block-volume-node-operations/11-03-SUMMARY.md`
</output>
