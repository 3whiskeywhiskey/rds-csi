---
phase: 11-block-volume-node-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/mount/mount.go
  - pkg/mount/mount_test.go
  - pkg/driver/node.go
autonomous: true

must_haves:
  truths:
    - "NodeStageVolume connects to NVMe target for block volumes without creating filesystem"
    - "NodeStageVolume stores device path metadata in staging directory for block volumes"
    - "Block volume staging creates staging directory with device metadata file"
  artifacts:
    - path: "pkg/mount/mount.go"
      provides: "MakeFile method for creating empty files for block volume targets"
      contains: "MakeFile"
    - path: "pkg/driver/node.go"
      provides: "Block volume detection and staging logic"
      contains: "GetBlock()"
  key_links:
    - from: "pkg/driver/node.go"
      to: "pkg/mount/mount.go"
      via: "MakeFile method call"
      pattern: "ns\\.mounter\\.MakeFile"
---

<objective>
Add MakeFile helper to Mounter interface and implement block volume staging in NodeStageVolume.

Purpose: Enable block volume support by adding the foundation (MakeFile helper) and modifying NodeStageVolume to detect block volumes and skip filesystem formatting, instead storing device path metadata in staging directory.

Output:
- MakeFile method added to Mounter interface and implemented
- NodeStageVolume detects block volumes via GetBlock() and handles them differently
- Block volumes get device path stored in staging_target_path/device file
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-block-volume-node-operations/11-RESEARCH.md
@pkg/mount/mount.go
@pkg/driver/node.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MakeFile helper to Mounter interface</name>
  <files>pkg/mount/mount.go, pkg/mount/mount_test.go</files>
  <action>
Add MakeFile method to the Mounter interface in pkg/mount/mount.go:

1. Add to interface definition (after IsMountInUse):
```go
// MakeFile creates an empty file at the given path
// Used for block volume target paths where target must be a file, not directory
MakeFile(pathname string) error
```

2. Implement in mounter struct:
```go
func (m *mounter) MakeFile(pathname string) error {
    klog.V(4).Infof("Creating file at %s", pathname)

    // Create parent directory if needed
    parent := filepath.Dir(pathname)
    if err := os.MkdirAll(parent, 0750); err != nil {
        return fmt.Errorf("failed to create parent directory: %w", err)
    }

    // Create empty file - use O_CREATE|O_EXCL for atomic creation
    f, err := os.OpenFile(pathname, os.O_CREATE|os.O_EXCL, 0640)
    if err != nil {
        if os.IsExist(err) {
            // File already exists - this is OK for idempotency
            klog.V(4).Infof("File %s already exists", pathname)
            return nil
        }
        return fmt.Errorf("failed to create file: %w", err)
    }
    f.Close()

    klog.V(4).Infof("Successfully created file at %s", pathname)
    return nil
}
```

3. Add unit test in pkg/mount/mount_test.go:
- Test creating a new file
- Test idempotency (calling MakeFile on existing file returns nil)
- Test parent directory creation
- Test error case (permission denied in read-only dir)

Note: Do NOT use mknod - bind mount approach is simpler and the research confirms this is the standard pattern.
  </action>
  <verify>
Run `make test` and verify mount tests pass.
Run `grep -n "MakeFile" pkg/mount/mount.go` shows interface method and implementation.
  </verify>
  <done>
MakeFile method exists in Mounter interface, is implemented in mounter struct, and has unit tests covering normal and edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement block volume detection and staging in NodeStageVolume</name>
  <files>pkg/driver/node.go</files>
  <action>
Modify NodeStageVolume in pkg/driver/node.go to handle block volumes:

1. Add import for "path/filepath" if not present.

2. After validation and before extracting fsType, add block volume detection:
```go
// Detect volume mode early - block volumes don't have filesystems
isBlockVolume := req.GetVolumeCapability().GetBlock() != nil
```

3. Move fsType extraction inside a conditional (only needed for filesystem volumes):
```go
// Get filesystem type from capability or use default (only for filesystem volumes)
fsType := defaultFSType
if !isBlockVolume {
    if mnt := req.GetVolumeCapability().GetMount(); mnt != nil {
        if mnt.FsType != "" {
            fsType = mnt.FsType
        }
    }
}
```

4. After NVMe connect succeeds (after `klog.V(2).Infof("Connected to NVMe target, device: %s", devicePath)`), add branching logic:

```go
if isBlockVolume {
    // Block volume: store device path in staging directory, skip format/mount
    // CSI spec: staging_target_path is ALWAYS a directory, even for block volumes
    if err := os.MkdirAll(stagingPath, 0750); err != nil {
        _ = ns.nvmeConn.Disconnect(nqn)
        secLogger.LogVolumeStage(volumeID, ns.nodeID, nqn, nvmeAddress, security.OutcomeFailure, err, time.Since(startTime))
        return nil, status.Errorf(codes.Internal, "failed to create staging directory: %v", err)
    }

    // Store device path in metadata file for NodePublishVolume to read
    metadataPath := filepath.Join(stagingPath, "device")
    if err := os.WriteFile(metadataPath, []byte(devicePath), 0600); err != nil {
        _ = ns.nvmeConn.Disconnect(nqn)
        secLogger.LogVolumeStage(volumeID, ns.nodeID, nqn, nvmeAddress, security.OutcomeFailure, err, time.Since(startTime))
        return nil, status.Errorf(codes.Internal, "failed to write device metadata: %v", err)
    }

    klog.V(2).Infof("Successfully staged block volume %s to %s (device: %s)", volumeID, stagingPath, devicePath)
    secLogger.LogVolumeStage(volumeID, ns.nodeID, nqn, nvmeAddress, security.OutcomeSuccess, nil, time.Since(startTime))
    return &csi.NodeStageVolumeResponse{}, nil
}

// Filesystem volume: format and mount (existing code follows)
```

5. The existing format + mount code remains unchanged for filesystem volumes.

Key points from research:
- Do NOT format block volumes - KubeVirt creates its own filesystem inside the VM
- staging_target_path is always a directory per CSI spec
- Store device path in simple text file (not JSON/YAML - unnecessary complexity)
  </action>
  <verify>
Run `make build` to ensure code compiles.
Run `grep -n "isBlockVolume" pkg/driver/node.go` shows detection logic.
Run `grep -n "GetBlock()" pkg/driver/node.go` shows capability check.
  </verify>
  <done>
NodeStageVolume detects block volumes using GetBlock(), skips Format() and Mount() for block volumes, creates staging directory and writes device path to staging_target_path/device metadata file.
  </done>
</task>

</tasks>

<verification>
1. `make build` succeeds
2. `make test` passes (existing tests + new MakeFile tests)
3. Code review: NodeStageVolume has clear branching for block vs filesystem volumes
4. Code review: No Format() or Mount() called for block volumes
5. Code review: Device path stored in staging_target_path/device file
</verification>

<success_criteria>
- MakeFile method exists and is tested
- NodeStageVolume handles block volumes by storing device path without formatting
- Filesystem volume behavior unchanged (no regression)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-block-volume-node-operations/11-01-SUMMARY.md`
</output>
