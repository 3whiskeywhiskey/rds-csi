---
phase: 11-block-volume-node-operations
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - pkg/driver/node.go
autonomous: true

must_haves:
  truths:
    - "NodePublishVolume creates block device file at target path for block volumes"
    - "NodePublishVolume bind-mounts the NVMe device to the target file"
    - "NodeUnpublishVolume unmounts and removes target path for both volume types"
  artifacts:
    - path: "pkg/driver/node.go"
      provides: "Block volume publish/unpublish logic"
      contains: "nodePublishBlockVolume"
  key_links:
    - from: "pkg/driver/node.go NodePublishVolume"
      to: "staging metadata file"
      via: "os.ReadFile"
      pattern: "filepath\\.Join.*staging.*device"
    - from: "pkg/driver/node.go NodePublishVolume"
      to: "pkg/mount/mount.go MakeFile"
      via: "method call for target file creation"
      pattern: "ns\\.mounter\\.MakeFile"
---

<objective>
Implement block volume support in NodePublishVolume and enhance NodeUnpublishVolume for block volumes.

Purpose: Complete the publish path for block volumes by reading device path from staging metadata, creating target file, and bind-mounting the NVMe device. Enhance unpublish to clean up both file and directory targets.

Output:
- NodePublishVolume handles block volumes by reading staging metadata and bind-mounting device to target file
- NodeUnpublishVolume handles cleanup for both block (file) and filesystem (directory) targets
</objective>

<execution_context>
@/Users/whiskey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whiskey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-block-volume-node-operations/11-RESEARCH.md
@.planning/phases/11-block-volume-node-operations/11-01-SUMMARY.md
@pkg/driver/node.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement block volume support in NodePublishVolume</name>
  <files>pkg/driver/node.go</files>
  <action>
Modify NodePublishVolume in pkg/driver/node.go to handle block volumes:

1. Add imports if not present:
```go
import (
    "os"
    "path/filepath"
    "strings"
)
```

2. After validation (after checking VolumeCapability is not nil), add block detection:
```go
// Detect volume mode early
isBlockVolume := req.GetVolumeCapability().GetBlock() != nil
```

3. Replace the existing staging path check and publish logic with branching:

```go
if isBlockVolume {
    // Block volume: read device path from staging metadata and bind mount to target file

    // Read device path from staging metadata (written by NodeStageVolume)
    metadataPath := filepath.Join(stagingPath, "device")
    deviceBytes, err := os.ReadFile(metadataPath)
    if err != nil {
        return nil, status.Errorf(codes.FailedPrecondition,
            "failed to read device metadata from staging path %s: %v (was NodeStageVolume called?)",
            stagingPath, err)
    }
    devicePath := strings.TrimSpace(string(deviceBytes))

    // Verify device exists before attempting mount
    if _, err := os.Stat(devicePath); err != nil {
        return nil, status.Errorf(codes.Internal, "block device not found: %s", devicePath)
    }

    klog.V(2).Infof("Publishing block volume %s: device %s -> target %s", volumeID, devicePath, targetPath)

    // Log volume publish request
    secLogger := security.GetLogger()
    secLogger.LogVolumePublish(volumeID, ns.nodeID, targetPath, security.OutcomeUnknown, nil, 0)
    startTime := time.Now()

    // Create target FILE (not directory) - kubelet creates parent directory
    // CSI spec: target_path for block volumes must be a file
    if err := ns.mounter.MakeFile(targetPath); err != nil {
        secLogger.LogVolumePublish(volumeID, ns.nodeID, targetPath, security.OutcomeFailure, err, time.Since(startTime))
        return nil, status.Errorf(codes.Internal, "failed to create target file: %v", err)
    }

    // Bind mount device to target file
    mountOptions := []string{"bind"}
    if req.GetReadonly() {
        mountOptions = append(mountOptions, "ro")
    }

    // Use empty fstype for bind mount of block device
    if err := ns.mounter.Mount(devicePath, targetPath, "", mountOptions); err != nil {
        // Clean up created file on failure
        _ = os.Remove(targetPath)
        secLogger.LogVolumePublish(volumeID, ns.nodeID, targetPath, security.OutcomeFailure, err, time.Since(startTime))
        return nil, status.Errorf(codes.Internal, "failed to bind mount block device: %v", err)
    }

    klog.V(2).Infof("Successfully published block volume %s to %s", volumeID, targetPath)
    secLogger.LogVolumePublish(volumeID, ns.nodeID, targetPath, security.OutcomeSuccess, nil, time.Since(startTime))
    return &csi.NodePublishVolumeResponse{}, nil
}

// Filesystem volume: existing bind mount from staging to target (keep existing code)
```

4. Keep all existing filesystem volume code after the block volume branch.

Key points from research:
- target_path for block volumes is a FILE, not a directory
- Use MakeFile (added in Plan 01), not MkdirAll
- Bind mount from /dev/nvmeXnY to target file (not mknod)
- Clean up target file if mount fails
- Do NOT call stale mount recovery for block volumes (recovery is for mounted filesystems)
  </action>
  <verify>
Run `make build` to ensure code compiles.
Run `grep -n "isBlockVolume" pkg/driver/node.go` shows detection in NodePublishVolume.
Run `grep -n "MakeFile" pkg/driver/node.go` shows target file creation for block volumes.
  </verify>
  <done>
NodePublishVolume handles block volumes: reads device path from staging metadata, creates target file with MakeFile, bind-mounts NVMe device to target file. Filesystem volume path unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance NodeUnpublishVolume for block volume cleanup</name>
  <files>pkg/driver/node.go</files>
  <action>
Enhance NodeUnpublishVolume to properly clean up both block (file) and filesystem (directory) targets:

1. After the existing unmount succeeds (after `klog.V(2).Infof("Successfully unpublished volume %s from %s"...)`), add cleanup logic:

```go
// Clean up target path after unmount
// For block volumes, target is a file; for filesystem volumes, target is a directory
// Use os.RemoveAll which handles both cases
if err := os.RemoveAll(targetPath); err != nil {
    // Log but don't fail - unmount succeeded, cleanup is best-effort
    klog.Warningf("Failed to remove target path %s: %v", targetPath, err)
}
```

Note: The existing Unmount() call already handles both bind-mounted files and directories, so the main change is adding explicit cleanup of the target path after unmount.

The research notes that os.RemoveAll handles both file and directory targets, making this a unified cleanup path.

Current code may not clean up the target path after unmount - verify and add if missing.
  </action>
  <verify>
Run `make build` to ensure code compiles.
Run `grep -A5 "Successfully unpublished" pkg/driver/node.go` shows cleanup logic after unmount.
  </verify>
  <done>
NodeUnpublishVolume properly cleans up target path after unmount for both block (file) and filesystem (directory) volumes.
  </done>
</task>

</tasks>

<verification>
1. `make build` succeeds
2. NodePublishVolume has clear branching for block vs filesystem volumes
3. Block volume publish: reads device metadata, creates file, bind mounts device
4. NodeUnpublishVolume cleans up target path after unmount
5. Filesystem volume publish behavior unchanged (no regression)
</verification>

<success_criteria>
- NodePublishVolume reads device path from staging metadata for block volumes
- NodePublishVolume creates target as file (not directory) for block volumes
- NodePublishVolume bind-mounts NVMe device to target file
- NodeUnpublishVolume removes target path after unmount
- All tests pass (make test)
</success_criteria>

<output>
After completion, create `.planning/phases/11-block-volume-node-operations/11-02-SUMMARY.md`
</output>
