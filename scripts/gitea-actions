#!/usr/bin/env bash
# gitea-actions - A simple CLI for monitoring Gitea Actions
# Usage: gitea-actions [command] [options]

set -euo pipefail

# Configuration (customize these or use env vars)
GITEA_HOST="${GITEA_HOST:-https://gitea.whiskey.works}"
GITEA_TOKEN="${GITEA_TOKEN:-}"
REPO_OWNER="${GITEA_REPO_OWNER:-whiskey}"
REPO_NAME="${GITEA_REPO_NAME:-rds-csi}"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# Helper function for API calls
api_call() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"

    local curl_args=(
        -s
        -X "$method"
        -H "accept: application/json"
    )

    if [ -n "$GITEA_TOKEN" ]; then
        curl_args+=(-H "Authorization: token $GITEA_TOKEN")
    fi

    if [ -n "$data" ]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi

    curl "${curl_args[@]}" "${GITEA_HOST}/api/v1${endpoint}"
}

# Get repository info to extract ID
get_repo_id() {
    api_call GET "/repos/${REPO_OWNER}/${REPO_NAME}" | jq -r '.id'
}

# List workflow runs
cmd_run_list() {
    local limit="${1:-10}"

    echo -e "${BLUE}Fetching workflow runs for ${REPO_OWNER}/${REPO_NAME}...${NC}"

    # Try the actions/runs endpoint (newer API)
    local response
    response=$(api_call GET "/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs?limit=${limit}" 2>/dev/null || echo "{\"workflow_runs\":[]}")

    # Check if we got data
    local run_count
    run_count=$(echo "$response" | jq -r '.workflow_runs | length // 0')

    if [ "$run_count" -eq 0 ]; then
        echo -e "${YELLOW}No workflow runs found or API endpoint not available.${NC}"
        echo "Note: Actions API requires Gitea 1.21+ with endpoints from PR #35382"
        return 1
    fi

    echo -e "\n${GREEN}Recent Workflow Runs:${NC}\n"

    echo "$response" | jq -r '
        .workflow_runs[] |
        [
            .run_number,
            .workflow_id,
            .event,
            .status,
            .conclusion // "pending",
            .created_at
        ] | @tsv
    ' | while IFS=$'\t' read -r num workflow event status conclusion created; do
        # Color code status
        local status_color="$GRAY"
        case "$status" in
            completed)
                [ "$conclusion" = "success" ] && status_color="$GREEN" || status_color="$RED"
                ;;
            running) status_color="$BLUE" ;;
            waiting) status_color="$YELLOW" ;;
        esac

        printf "${status_color}#%-4s${NC} ${GRAY}%-20s${NC} %-10s %-15s %-15s %s\n" \
            "$num" "$workflow" "$event" "$status" "$conclusion" "$created"
    done
}

# View specific run
cmd_run_view() {
    local run_id="$1"

    echo -e "${BLUE}Fetching run #${run_id}...${NC}"

    local response
    response=$(api_call GET "/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs/${run_id}" 2>/dev/null || echo "{}")

    if [ "$(echo "$response" | jq -r '.id // ""')" = "" ]; then
        echo -e "${RED}Run not found or API error${NC}"
        return 1
    fi

    echo "$response" | jq -r '
        "
Run #\(.run_number) - \(.name // .workflow_id)
════════════════════════════════════════════════════════════

Status:      \(.status)
Conclusion:  \(.conclusion // "pending")
Event:       \(.event)
Branch:      \(.head_branch)
Commit:      \(.head_sha[0:7])
Created:     \(.created_at)
Updated:     \(.updated_at)
"
    '
}

# Get run logs
cmd_run_logs() {
    local run_id="$1"
    local follow="${2:-false}"

    if [ "$follow" = "true" ] || [ "$follow" = "-f" ]; then
        echo -e "${BLUE}Following logs for run #${run_id}...${NC}\n"

        # Stream logs using cursor-based API
        local cursor=0
        while true; do
            local response
            response=$(api_call POST "/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs/${run_id}/logs" "{\"cursor\": $cursor}" 2>/dev/null || echo "{}")

            local new_logs
            new_logs=$(echo "$response" | jq -r '.logs // empty')

            if [ -n "$new_logs" ]; then
                echo "$new_logs"
                cursor=$((cursor + $(echo "$new_logs" | wc -l)))
            fi

            # Check if run is complete
            local status
            status=$(api_call GET "/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs/${run_id}" 2>/dev/null | jq -r '.status')

            if [ "$status" = "completed" ]; then
                echo -e "\n${GREEN}Run completed${NC}"
                break
            fi

            sleep 2
        done
    else
        echo -e "${BLUE}Fetching logs for run #${run_id}...${NC}\n"

        # Download full logs archive
        local temp_file="/tmp/gitea-actions-${run_id}.zip"
        curl -s -H "Authorization: token $GITEA_TOKEN" \
            "${GITEA_HOST}/api/v1/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs/${run_id}/logs" \
            -o "$temp_file"

        if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
            echo -e "${GREEN}Logs downloaded to: $temp_file${NC}"
            echo -e "${YELLOW}Extract with: unzip $temp_file${NC}"
        else
            echo -e "${RED}Failed to download logs or no logs available${NC}"
            rm -f "$temp_file"
        fi
    fi
}

# Watch a running workflow
cmd_run_watch() {
    local run_id="$1"
    local interval="${2:-5}"

    echo -e "${BLUE}Watching run #${run_id} (refresh every ${interval}s, Ctrl+C to stop)...${NC}\n"

    while true; do
        clear
        cmd_run_view "$run_id"

        # Check if completed
        local status
        status=$(api_call GET "/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs/${run_id}" 2>/dev/null | jq -r '.status')

        if [ "$status" = "completed" ]; then
            echo -e "\n${GREEN}Run completed!${NC}"
            break
        fi

        sleep "$interval"
    done
}

# List workflows
cmd_workflow_list() {
    echo -e "${BLUE}Fetching workflows for ${REPO_OWNER}/${REPO_NAME}...${NC}\n"

    # Note: This endpoint may not be available in all Gitea versions
    local response
    response=$(api_call GET "/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows" 2>/dev/null || echo "{\"workflows\":[]}")

    echo "$response" | jq -r '
        if .workflows | length > 0 then
            .workflows[] | "\(.id)\t\(.name)\t\(.path)\t\(.state)"
        else
            "No workflows found or API not available"
        end
    ' | column -t -s $'\t' -N "ID,NAME,PATH,STATE"
}

# Show usage
usage() {
    cat <<EOF
${GREEN}gitea-actions${NC} - Monitor Gitea Actions from the command line

${YELLOW}USAGE:${NC}
    gitea-actions <command> [options]

${YELLOW}COMMANDS:${NC}
    ${GREEN}run list [limit]${NC}         List recent workflow runs (default: 10)
    ${GREEN}run view <run-id>${NC}        View details of a specific run
    ${GREEN}run watch <run-id>${NC}       Watch a running workflow (auto-refresh)
    ${GREEN}run logs <run-id> [-f]${NC}   Get logs (use -f to follow live)
    ${GREEN}workflow list${NC}             List all workflows

${YELLOW}ENVIRONMENT:${NC}
    GITEA_HOST         Gitea instance URL (default: https://git.whiskey.works)
    GITEA_TOKEN        Authentication token (required for private repos)
    GITEA_REPO_OWNER   Repository owner (default: whiskey)
    GITEA_REPO_NAME    Repository name (default: rds-csi)

${YELLOW}EXAMPLES:${NC}
    # List recent runs
    gitea-actions run list

    # View run #3
    gitea-actions run view 3

    # Watch run #4 in real-time
    gitea-actions run watch 4

    # Get logs for run #3
    gitea-actions run logs 3

    # Follow logs live
    gitea-actions run logs 6 -f

    # Use with different repo
    GITEA_REPO_NAME=my-other-repo gitea-actions run list

${YELLOW}NOTES:${NC}
    - Requires Gitea 1.21+ with Actions API support
    - Some endpoints may require authentication token
    - API implementation varies by Gitea version

EOF
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        usage
        exit 0
    fi

    local command="$1"
    shift

    case "$command" in
        run)
            if [ $# -eq 0 ]; then
                echo -e "${RED}Error: 'run' requires a subcommand${NC}\n"
                usage
                exit 1
            fi

            local subcommand="$1"
            shift

            case "$subcommand" in
                list) cmd_run_list "$@" ;;
                view)
                    if [ $# -eq 0 ]; then
                        echo -e "${RED}Error: 'run view' requires a run ID${NC}"
                        exit 1
                    fi
                    cmd_run_view "$@"
                    ;;
                watch)
                    if [ $# -eq 0 ]; then
                        echo -e "${RED}Error: 'run watch' requires a run ID${NC}"
                        exit 1
                    fi
                    cmd_run_watch "$@"
                    ;;
                logs)
                    if [ $# -eq 0 ]; then
                        echo -e "${RED}Error: 'run logs' requires a run ID${NC}"
                        exit 1
                    fi
                    cmd_run_logs "$@"
                    ;;
                *)
                    echo -e "${RED}Unknown subcommand: run $subcommand${NC}\n"
                    usage
                    exit 1
                    ;;
            esac
            ;;
        workflow)
            if [ $# -eq 0 ]; then
                echo -e "${RED}Error: 'workflow' requires a subcommand${NC}\n"
                usage
                exit 1
            fi

            local subcommand="$1"
            shift

            case "$subcommand" in
                list) cmd_workflow_list "$@" ;;
                *)
                    echo -e "${RED}Unknown subcommand: workflow $subcommand${NC}\n"
                    usage
                    exit 1
                    ;;
            esac
            ;;
        help|-h|--help)
            usage
            ;;
        *)
            echo -e "${RED}Unknown command: $command${NC}\n"
            usage
            exit 1
            ;;
    esac
}

# Check dependencies
if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: 'jq' is required but not installed${NC}"
    echo "Install with: brew install jq"
    exit 1
fi

main "$@"
